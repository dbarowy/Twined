12
Preface .................................................................................................................................... 6
Preface to the first edition ........................................................................................................ 8
Chapter 1 - A Tutorial Introduction ......................................................................................... 9
1.1 Getting Started .............................................................................................................. 9
1.2 Variables and Arithmetic Expressions .......................................................................... 11
1.3 The for statement ......................................................................................................... 15
1.4 Symbolic Constants ...................................................................................................... 17
1.5 Character Input and Output ......................................................................................... 17
1.5.1 File Copying .......................................................................................................... 18
1.5.2 Character Counting ............................................................................................... 19
1.5.3 Line Counting ....................................................................................................... 20
1.5.4 Word Counting ..................................................................................................... 21
1.6 Arrays .......................................................................................................................... 23
1.7 Functions ..................................................................................................................... 25
1.8 Arguments - Call by Value ........................................................................................... 28
1.9 Character Arrays .......................................................................................................... 29
1.10 External Variables and Scope ..................................................................................... 31
Chapter 2 - Types, Operators and Expressions ....................................................................... 35
2.1 Variable Names ............................................................................................................ 35
2.2 Data Types and Sizes ................................................................................................... 35
2.3 Constants ..................................................................................................................... 36
2.4 Declarations ................................................................................................................. 38
2.5 Arithmetic Operators ................................................................................................... 39
2.6 Relational and Logical Operators ................................................................................. 39
2.7 Type Conversions ........................................................................................................ 40
2.8 Increment and Decrement Operators ............................................................................ 43
2.9 Bitwise Operators ........................................................................................................ 45
2.10 Assignment Operators and Expressions ...................................................................... 46
2.11 Conditional Expressions ............................................................................................. 47
2.12 Precedence and Order of Evaluation .......................................................................... 48
Chapter 3 - Control Flow ....................................................................................................... 50
3.1 Statements and Blocks ................................................................................................. 50
3.2 If-Else .......................................................................................................................... 50
3.3 Else-If .......................................................................................................................... 51
3.4 Switch .......................................................................................................................... 52
3.5 Loops - While and For ................................................................................................. 53
3.6 Loops - Do-While ........................................................................................................ 56
3.7 Break and Continue ..................................................................................................... 57
3.8 Goto and labels ............................................................................................................ 57
Chapter 4 - Functions and Program Structure ........................................................................ 59
4.1 Basics of Functions ...................................................................................................... 59
4.2 Functions Returning Non-integers ................................................................................ 61
4.3 External Variables ........................................................................................................ 63
4.4 Scope Rules ................................................................................................................. 68
4.5 Header Files ................................................................................................................. 69
4.6 Static Variables ............................................................................................................ 70
4.7 Register Variables ........................................................................................................ 71
4.8 Block Structure ............................................................................................................ 71
4.9 Initialization ................................................................................................................. 72
4.10 Recursion ................................................................................................................... 73
4.11 The C Preprocessor .................................................................................................... 74
4.11.1 File Inclusion ....................................................................................................... 75
4.11.2 Macro Substitution .............................................................................................. 753
4.11.3 Conditional Inclusion .......................................................................................... 77
Chapter 5 - Pointers and Arrays ............................................................................................. 78
5.1 Pointers and Addresses ................................................................................................ 78
5.2 Pointers and Function Arguments ................................................................................. 79
5.3 Pointers and Arrays ...................................................................................................... 81
5.4 Address Arithmetic ...................................................................................................... 84
5.5 Character Pointers and Functions ................................................................................. 87
5.6 Pointer Arrays; Pointers to Pointers ............................................................................. 89
5.7 Multi-dimensional Arrays ............................................................................................. 92
5.8 Initialization of Pointer Arrays ..................................................................................... 93
5.9 Pointers vs. Multi-dimensional Arrays .......................................................................... 94
5.10 Command-line Arguments .......................................................................................... 95
5.11 Pointers to Functions ................................................................................................. 98
5.12 Complicated Declarations ......................................................................................... 100
Chapter 6 - Structures .......................................................................................................... 105
6.1 Basics of Structures ................................................................................................... 105
6.2 Structures and Functions ............................................................................................ 107
6.3 Arrays of Structures ................................................................................................... 109
6.4 Pointers to Structures ................................................................................................. 112
6.5 Self-referential Structures ........................................................................................... 113
6.6 Table Lookup ............................................................................................................ 117
6.7 Typedef ...................................................................................................................... 119
6.8 Unions ....................................................................................................................... 120
6.9 Bit-fields .................................................................................................................... 121
Chapter 7 - Input and Output ............................................................................................... 124
7.1 Standard Input and Output ......................................................................................... 124
7.2 Formatted Output - printf ........................................................................................... 125
7.3 Variable-length Argument Lists .................................................................................. 127
7.4 Formatted Input - Scanf ............................................................................................. 128
7.5 File Access ................................................................................................................. 130
7.6 Error Handling - Stderr and Exit ................................................................................ 132
7.7 Line Input and Output ................................................................................................ 134
7.8 Miscellaneous Functions ............................................................................................ 135
7.8.1 String Operations ................................................................................................ 135
7.8.2 Character Class Testing and Conversion .............................................................. 135
7.8.3 Ungetc ................................................................................................................ 135
7.8.4 Command Execution ........................................................................................... 135
7.8.5 Storage Management .......................................................................................... 136
7.8.6 Mathematical Functions ....................................................................................... 136
7.8.7 Random Number generation ................................................................................ 136
Chapter 8 - The UNIX System Interface .............................................................................. 138
8.1 File Descriptors .......................................................................................................... 138
8.2 Low Level I/O - Read and Write ................................................................................ 139
8.3 Open, Creat, Close, Unlink ........................................................................................ 140
8.4 Random Access - Lseek ............................................................................................. 142
8.5 Example - An implementation of Fopen and Getc ....................................................... 142
8.6 Example - Listing Directories ..................................................................................... 145
8.7 Example - A Storage Allocator .................................................................................. 149
Appendix A - Reference Manual .......................................................................................... 154
A.1 Introduction .............................................................................................................. 154
A.2 Lexical Conventions .................................................................................................. 154
A.2.1 Tokens ............................................................................................................... 154
A.2.2 Comments .......................................................................................................... 1544
A.2.3 Identifiers ........................................................................................................... 154
A.2.4 Keywords ........................................................................................................... 154
A.2.5 Constants ........................................................................................................... 155
A.2.6 String Literals ..................................................................................................... 156
A.3 Syntax Notation ........................................................................................................ 156
A.4 Meaning of Identifiers ............................................................................................... 157
A.4.1 Storage Class ..................................................................................................... 157
A.4.2 Basic Types ........................................................................................................ 157
A.4.3 Derived types ..................................................................................................... 158
A.4.4 Type Qualifiers ................................................................................................... 158
A.5 Objects and Lvalues .................................................................................................. 158
A.6 Conversions .............................................................................................................. 159
A.6.1 Integral Promotion ............................................................................................. 159
A.6.2 Integral Conversions ........................................................................................... 159
A.6.3 Integer and Floating ........................................................................................... 159
A.6.4 Floating Types .................................................................................................... 159
A.6.5 Arithmetic Conversions ...................................................................................... 159
A.6.6 Pointers and Integers .......................................................................................... 160
A.6.7 Void ................................................................................................................... 160
A.6.8 Pointers to Void ................................................................................................. 161
A.7 Expressions ............................................................................................................... 161
A.7.1 Pointer Conversion ............................................................................................. 161
A.7.2 Primary Expressions ........................................................................................... 161
A.7.3 Postfix Expressions ............................................................................................ 162
A.7.4 Unary Operators ................................................................................................. 164
A.7.5 Casts .................................................................................................................. 165
A.7.6 Multiplicative Operators ..................................................................................... 165
A.7.7 Additive Operators ............................................................................................. 166
A.7.8 Shift Operators ................................................................................................... 166
A.7.9 Relational Operators ........................................................................................... 167
A.7.10 Equality Operators ........................................................................................... 167
A.7.11 Bitwise AND Operator ..................................................................................... 167
A.7.12 Bitwise Exclusive OR Operator ........................................................................ 167
A.7.13 Bitwise Inclusive OR Operator ......................................................................... 168
A.7.14 Logical AND Operator ..................................................................................... 168
A.7.15 Logical OR Operator ........................................................................................ 168
A.7.16 Conditional Operator ........................................................................................ 168
A.7.17 Assignment Expressions ................................................................................... 169
A.7.18 Comma Operator .............................................................................................. 169
A.7.19 Constant Expressions ....................................................................................... 169
A.8 Declarations .............................................................................................................. 170
A.8.1 Storage Class Specifiers ..................................................................................... 170
A.8.2 Type Specifiers ................................................................................................... 171
A.8.3 Structure and Union Declarations ....................................................................... 172
A.8.4 Enumerations ..................................................................................................... 174
A.8.5 Declarators ......................................................................................................... 175
A.8.6 Meaning of Declarators ...................................................................................... 176
A.8.7 Initialization ....................................................................................................... 178
A.8.8 Type names ........................................................................................................ 180
A.8.9 Typedef .............................................................................................................. 181
A.8.10 Type Equivalence ............................................................................................. 181
A.9 Statements ................................................................................................................ 181
A.9.1 Labeled Statements ............................................................................................. 1825
A.9.2 Expression Statement ......................................................................................... 182
A.9.3 Compound Statement ......................................................................................... 182
A.9.4 Selection Statements .......................................................................................... 183
A.9.5 Iteration Statements ........................................................................................... 183
A.9.6 Jump statements ................................................................................................. 184
A.10 External Declarations .............................................................................................. 184
A.10.1 Function Definitions ......................................................................................... 185
A.10.2 External Declarations ....................................................................................... 186
A.11 Scope and Linkage .................................................................................................. 186
A.11.1 Lexical Scope ................................................................................................... 187
A.11.2 Linkage ............................................................................................................ 187
A.12 Preprocessing .......................................................................................................... 187
A.12.1 Trigraph Sequences .......................................................................................... 188
A.12.2 Line Splicing .................................................................................................... 188
A.12.3 Macro Definition and Expansion ....................................................................... 188
A.12.4 File Inclusion .................................................................................................... 190
A.12.5 Conditional Compilation ................................................................................... 191
A.12.6 Line Control ..................................................................................................... 192
A.12.7 Error Generation .............................................................................................. 192
A.12.8 Pragmas ............................................................................................................ 192
A.12.9 Null directive .................................................................................................... 192
A.12.10 Predefined names ............................................................................................ 192
A.13 Grammar ................................................................................................................. 193
Appendix B - Standard Library ............................................................................................ 199
B.1 Input and Output: <stdio.h> ...................................................................................... 199
B.1.1 File Operations ................................................................................................... 199
B.1.2 Formatted Output ............................................................................................... 200
B.1.3 Formatted Input .................................................................................................. 202
B.1.4 Character Input and Output Functions ................................................................ 203
B.1.5 Direct Input and Output Functions ...................................................................... 204
B.1.6 File Positioning Functions ................................................................................... 204
B.1.7 Error Functions .................................................................................................. 205
B.2 Character Class Tests: <ctype.h> ............................................................................... 205
B.3 String Functions: <string.h> ...................................................................................... 205
B.4 Mathematical Functions: <math.h> ............................................................................ 206
B.5 Utility Functions: <stdlib.h> ...................................................................................... 207
B.6 Diagnostics: <assert.h> .............................................................................................. 209
B.7 Variable Argument Lists: <stdarg.h> ......................................................................... 209
B.8 Non-local Jumps: <setjmp.h> .................................................................................... 210
B.9 Signals: <signal.h> .................................................................................................... 210
B.10 Date and Time Functions: <time.h> ......................................................................... 210
B.11 Implementation-defined Limits: <limits.h> and <float.h> ......................................... 212
Appendix C - Summary of Changes ..................................................................................... 2146
Preface
Thecomputing world hasundergone arevolution since thepublication ofTheCProgramming
Language in1978. Bigcomputers aremuch bigger, andpersonal computers have capabilities
that rival mainframes ofadecade ago. During thistime, Chaschanged too, although only
modestly, andithasspread farbeyond itsorigins asthelanguage oftheUNIX operating
system. 
The growing popularity ofC,thechanges inthelanguage over theyears, andthecreation of
compilers bygroups notinvolved initsdesign, combined todemonstrate aneed foramore
precise andmore contemporary definition ofthelanguage than thefirst edition ofthisbook
provided. In1983, theAmerican National Standards Institute (ANSI) established acommittee
whose goal was toproduce ``an unambiguous and machine-independent definition ofthe
language C'', while still retaining its spirit. The result is the ANSI standard for C. 
The standard formalizes constructions that were hinted butnotdescribed inthefirst edition,
particularly structure assignment and enumerations. Itprovides anew form offunction
declaration that permits cross-checking ofdefinition with use. Itspecifies astandard library,
with anextensive setoffunctions forperforming input andoutput, memory management,
string manipulation, andsimilar tasks. Itmakes precise thebehavior offeatures thatwere not
spelled outintheoriginal definition, andatthesame time states explicitly which aspects ofthe
language remain machine-dependent. 
This Second Edition ofTheCProgramming Language describes Casdefined bytheANSI
standard. Although wehave noted theplaces where thelanguage hasevolved, wehave chosen
towrite exclusively inthenew form. Forthemost part, thismakes nosignificant difference;
themost visible change isthenew form offunction declaration and definition. Modern
compilers already support most features of the standard. 
Wehave tried toretain thebrevity ofthefirstedition. Cisnotabiglanguage, anditisnotwell
served byabigbook. Wehave improved theexposition ofcritical features, such aspointers,
that are central to C programming. We have refined the original examples, and have added new
examples inseveral chapters. For instance, thetreatment ofcomplicated declarations is
augmented byprograms that convert declarations into words andvice versa. Asbefore, all
examples have been tested directly from the text, which is in machine-readable form. 
Appendix A,thereference manual, isnotthestandard, butourattempt toconvey theessentials
ofthestandard inasmaller space. Itismeant foreasy comprehension byprogrammers, butnot
asadefinition forcompiler writers --that role properly belongs tothestandard itself.
Appendix Bisasummary ofthefacilities ofthestandard library. Ittooismeant forreference
byprogrammers, notimplementers. Appendix Cisaconcise summary ofthechanges from the
original version. 
Aswesaidinthepreface tothefirstedition, C``wears well asone's experience with itgrows''.
With adecade more experience, westillfeelthatway. Wehope thatthisbook willhelp you
learn C and use it well. 
Wearedeeply indebted tofriends who helped ustoproduce thissecond edition. JonBently,
Doug Gwyn, Doug McIlroy, Peter Nelson, andRob Pike gave usperceptive comments on
almost every page ofdraft manuscripts. Wearegrateful forcareful reading byAlAho, Dennis
Allison, Joe Campbell, G.R. Emlin, Karen Fortgang, Allen Holub, Andrew Hume, Dave
Kristol, John Linderman, Dave Prosser, Gene Spafford, andChris vanWyk. Wealso received
helpful suggestions from BillCheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom7
London, Jim Reeds, Clovis Tondo, and Peter Weinberger. Dave Prosser answered many
detailed questions about theANSI standard. Weused Bjarne Stroustrup's C++ translator
extensively forlocal testing ofourprograms, andDave Kristol provided uswith anANSI C
compiler for final testing. Rich Drechsler helped greatly with typesetting. 
Our sincere thanks to all. 
Brian W. Kernighan
Dennis M. Ritchie 8
Preface to the first edition
Cisageneral-purpose programming language with features economy ofexpression, modern
flow control anddata structures, andarich setofoperators. Cisnota``very high level''
language, nora``big'' one, andisnotspecialized toanyparticular area ofapplication. Butits
absence ofrestrictions anditsgenerality make itmore convenient andeffective formany tasks
than supposedly more powerful languages. 
Cwas originally designed forandimplemented ontheUNIX operating system ontheDEC
PDP-11, byDennis Ritchie. The operating system, theCcompiler, andessentially allUNIX
applications programs (including allofthesoftware used toprepare thisbook) arewritten in
C.Production compilers also exist forseveral other machines, including theIBM System/370,
theHoneywell 6000, andtheInterdata 8/32. Cisnottiedtoanyparticular hardware orsystem,
however, anditiseasy towrite programs that willrunwithout change onanymachine that
supports C. 
This book ismeant tohelp thereader learn how toprogram inC.Itcontains atutorial
introduction togetnew users started assoon aspossible, separate chapters oneach major
feature, and areference manual. Most ofthetreatment isbased onreading, writing and
revising examples, rather than onmere statements ofrules. Forthemost part, theexamples are
complete, realprograms rather than isolated fragments. Allexamples have been tested directly
from thetext, which isinmachine-readable form. Besides showing how tomake effective use
ofthelanguage, wehave alsotried where possible toillustrate useful algorithms andprinciples
of good style and sound design. 
The book isnotanintroductory programming manual; itassumes some familiarity with basic
programming concepts like variables, assignment statements, loops, and functions.
Nonetheless, anovice programmer should beable toread along andpick upthelanguage,
although access to more knowledgeable colleague will help. 
Inourexperience, Chasproven tobeapleasant, expressive andversatile language forawide
variety ofprograms. Itiseasy tolearn, anditwears well ason'sexperience with itgrows. We
hope that this book will help you to use it well. 
The thoughtful criticisms and suggestions of many friends and colleagues have added greatly to
thisbook andtoourpleasure inwriting it.Inparticular, Mike Bianchi, JimBlue, StuFeldman,
Doug McIlroy BillRoome, Bob Rosin andLarry Rosler allread multiple volumes with care.
Wearealso indebted toAlAho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley,
Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter
Nelson, Elliot Pinson, BillPlauger, Jerry Spivack, Ken Thompson, andPeter Weinberger for
helpful comments atvarious stages, and toMile Lesk and Joe Ossanna forinvaluable
assistance with typesetting. 
Brian W. Kernighan
Dennis M. Ritchie 9
Chapter 1 - A Tutorial Introduction
Letusbegin with aquick introduction inC.Our aimistoshow theessential elements ofthe
language inrealprograms, butwithout getting bogged down indetails, rules, andexceptions.
Atthispoint, wearenottrying tobecomplete oreven precise (save that theexamples are
meant tobecorrect). Wewant togetyouasquickly aspossible tothepoint where youcan
write useful programs, andtodothat wehave toconcentrate onthebasics: variables and
constants, arithmetic, control flow, functions, andtherudiments ofinput andoutput. Weare
intentionally leaving outofthischapter features ofCthat areimportant forwriting bigger
programs. These include pointers, structures, most ofC'srichsetofoperators, several control-
flow statements, and the standard library. 
This approach anditsdrawbacks. Most notable isthat thecomplete story onanyparticular
feature isnotfound here, andthetutorial, bybeing brief, may alsobemisleading. And because
theexamples donotusethefullpower ofC,they arenotasconcise andelegant asthey might
be.Wehave tried tominimize these effects, butbewarned. Another drawback isthat later
chapters willnecessarily repeat some ofthischapter. Wehope thattherepetition willhelp you
more than it annoys. 
Inanycase, experienced programmers should beable toextrapolate from thematerial inthis
chapter totheir own programming needs. Beginners should supplement itbywriting small,
similar programs oftheir own. Both groups canuseitasaframework onwhich tohang the
more detailed descriptions that begin in Chapter 2 . 
1.1 Getting Started
The only way to learn a new programming language is by writing programs in it. The first
program to write is the same for all languages:
 Print the words
 hello, world  
This isabighurdle; toleap over ityouhave tobeable tocreate theprogram textsomewhere,
compile itsuccessfully, load it,runit,and find outwhere your output went. With these
mechanical details mastered, everything else is comparatively easy. 
In C, the program to print `` hello, world '' is 
   #include <stdio.h>
   main()
   {
     printf("hello, world\n");
   }
Just how torunthisprogram depends onthesystem youareusing. Asaspecific example, on
theUNIX operating system youmust create theprogram inafilewhose name ends in``.c'',
such as hello.c , then compile it with the command 
   cc hello.c
Ifyou haven't botched anything, such asomitting acharacter ormisspelling something, the
compilation willproceed silently, andmake anexecutable filecalleda.out .Ifyouruna.out
by typing the command 
   a.out
it will print 10
   hello, world
On other systems, the rules will be different; check with a local expert. 
Now, forsome explanations about theprogram itself. ACprogram, whatever itssize, consists
offunctions and variables .Afunction contains statements that specify thecomputing
operations tobedone, andvariables store values used during thecomputation. Cfunctions are
likethesubroutines andfunctions inFortran ortheprocedures andfunctions ofPascal. Our
example isafunction namedmain .Normally you areatliberty togive functions whatever
names you like, but``main ''isspecial -your program begins executing atthebeginning of
main. This means that every program must have a main  somewhere. 
main willusually callother functions tohelp perform itsjob,some thatyouwrote, andothers
from libraries that are provided for you. The first line of the program, 
   #include <stdio.h>
tells thecompiler toinclude information about thestandard input/output library; theline
appears atthebeginning ofmany Csource files. Thestandard library isdescribed inChapter 7
and Appendix B . 
One method ofcommunicating data between functions isforthecalling function toprovide a
list of values, called arguments , to the function it calls. The parentheses after the function name
surround theargument list.Inthisexample, main isdefined tobeafunction thatexpects no
arguments, which is indicated by the empty list ( ). 
#include <stdio.h>                include information about standard
library
main()                            define a function called main
                                  that received no argument values
{                                 statements of main are enclosed in braces
    printf("hello, world\n");     main calls library function printf
                                  to print this sequence of characters
}                                 \n represents the newline character
The first C program  
Thestatements ofafunction areenclosed inbraces{}.Thefunctionmain contains only one
statement, 
   printf("hello, world\n");
Afunction iscalled bynaming it,followed byaparenthesized listofarguments, sothiscalls
thefunctionprintf with theargument "hello, world\n" .printf isalibrary function that
prints output, in this case the string of characters between the quotes. 
Asequence ofcharacters indouble quotes, like"hello, world\n" ,iscalled acharacter
string orstring constant .For themoment our only useofcharacter strings will beas
arguments for printf  and other functions. 
The sequence \ninthestring isCnotation forthenewline character ,which when printed
advances theoutput totheleftmargin onthenext line. Ifyouleave outthe\n(aworthwhile
experiment), youwillfindthatthere isnolineadvance after theoutput isprinted. You must
use \n to include a newline character in the printf  argument; if you try something like 
   printf("hello, world
   ");11
the C compiler will produce an error message. 
printf never supplies anewline character automatically, soseveral calls may beused tobuild
up an output line in stages. Our first program could just as well have been written 
   #include <stdio.h>
   main()
   {
     printf("hello, ");
     printf("world");
     printf("\n");
   }
to produce identical output. 
Notice that\nrepresents only asingle character. Anescape sequence like\nprovides a
general andextensible mechanism forrepresenting hard-to-type orinvisible characters. Among
theothers thatCprovides are\tfortab,\bforbackspace, \"forthedouble quote and\\for
the backslash itself. There is a complete list in Section 2.3 . 
Exercise 1-1.Run the``hello,world ''program onyour system. Experiment with leaving out
parts of the program, to see what error messages you get. 
Exercise 1-2. Experiment tofind outwhat happens whenprints 'sargument string contains
\c, where c is some character not listed above. 
1.2 Variables and Arithmetic Expressions
The next program uses theformulaoC=(5/9)(oF-32) toprint thefollowing table ofFahrenheit
temperatures and their centigrade or Celsius equivalents: 12
   1    -17
   20   -6
   40   4
   60   15
   80   26
   100  37
   120  48
   140  60
   160  71
   180  82
   200  93
   220  104
   240  115
   260  126
   280  137
   300  148
The program itself stillconsists ofthedefinition ofasingle function namedmain .Itislonger
than theonethat printed ``hello,world '',butnotcomplicated. Itintroduces several new
ideas, including comments, declarations, variables, arithmetic expressions, loops ,and
formatted output. 
   #include <stdio.h>
   /* print Fahrenheit-Celsius table
       for fahr = 0, 20, ..., 300 */
   main()
   {
     int fahr, celsius;
     int lower, upper, step;
     lower = 0;      /* lower limit of temperature scale */
     upper = 300;    /* upper limit */
     step = 20;      /* step size */
     fahr = lower;
     while (fahr <= upper) {
         celsius = 5 * (fahr-32) / 9;
         printf("%d\t%d\n", fahr, celsius);
         fahr = fahr + step;
     }
   }
The two lines 
  /* print Fahrenheit-Celsius table
      for fahr = 0, 20, ..., 300 */
areacomment ,which inthiscase explains briefly what theprogram does. Any characters
between/*and*/areignored bythecompiler; they may beused freely tomake aprogram
easier to understand. Comments may appear anywhere where a blank, tab or newline can. 
InC,allvariables must bedeclared before they areused, usually atthebeginning ofthe
function before any executable statements. Adeclaration announces theproperties of
variables; it consists of a name and a list of variables, such as 
    int fahr, celsius;
    int lower, upper, step;
Thetypeintmeans thatthevariables listed areintegers; bycontrast withfloat ,which means
floating point, i.e.,numbers thatmay have afractional part. Therange ofbothintandfloat
depends onthemachine youareusing; 16-bitsints,which liebetween -32768 and+32767,
arecommon, asare32-bitints.Afloat number istypically a32-bit quantity, with atleast six
significant digits and magnitude generally between about 10-38 and 1038. 
C provides several other data types besides int and float , including: 13
 char    character - a single byte
 short    short integer
 long    long integer
 double   double-precision floating point  
The size ofthese objects isalso machine-dependent. There arealso arrays ,structures and
unions ofthese basic types, pointers tothem, andfunctions thatreturn them, allofwhich we
will meet in due course. 
Computation in the temperature conversion program begins with the assignment statements  
    lower = 0;
    upper = 300;
    step = 20;
which setthevariables totheir initial values. Individual statements areterminated by
semicolons. 
Each lineofthetable iscomputed thesame way, soweusealoop thatrepeats once peroutput
line; this is the purpose of the while  loop 
    while (fahr <= upper) {
       ...
    }
Thewhile loop operates asfollows: Thecondition inparentheses istested. Ifitistrue (fahr
is less than or equal to upper ), the body of the loop (the three statements enclosed in braces) is
executed. Then the condition is re-tested, and if true, the body is executed again. When the test
becomes false (fahr exceedsupper )theloop ends, andexecution continues atthestatement
that follows the loop. There are no further statements in this program, so it terminates. 
Thebody ofawhile canbeoneormore statements enclosed inbraces, asinthetemperature
converter, or a single statement without braces, as in 
   while (i < j)
       i = 2 * i;
Ineither case, wewillalways indent thestatements controlled bythewhile byonetabstop
(which wehave shown asfour spaces) soyoucanseeataglance which statements areinside
theloop. The indentation emphasizes thelogical structure oftheprogram. Although C
compilers donotcare about how aprogram looks, proper indentation andspacing arecritical
inmaking programs easy forpeople toread. Werecommend writing only onestatement per
line, andusing blanks around operators toclarify grouping. The position ofbraces isless
important, although people hold passionate beliefs. Wehave chosen oneofseveral popular
styles. Pick a style that suits you, then use it consistently. 
Most ofthework gets done inthebody oftheloop. TheCelsius temperature iscomputed and
assigned to the variable celsius  by the statement 
        celsius = 5 * (fahr-32) / 9;
The reason formultiplying by5anddividing by9instead ofjustmultiplying by5/9isthatin
C,asinmany other languages, integer division truncates :anyfractional part isdiscarded.
Since5and9areintegers.5/9would betruncated tozero andsoalltheCelsius temperatures
would be reported as zero. 
This example also shows abitmore ofhowprintf works.printf isageneral-purpose
output formatting function, which wewilldescribe indetail inChapter 7 .Itsfirstargument isa
string ofcharacters tobeprinted, with each%indicating where oneoftheother (second, third,14
...)arguments istobesubstituted, and inwhat form itistobeprinted. Forinstance, %d
specifies an integer argument, so the statement 
        printf("%d\t%d\n", fahr, celsius);
causes thevalues ofthetwointegersfahr andcelsius tobeprinted, with atab(\t)between
them. 
Each%construction inthefirst argument ofprintf ispaired with thecorresponding second
argument, third argument, etc.; they must match upproperly bynumber andtype, oryouwill
get wrong answers. 
Bytheway,printf isnotpart oftheClanguage; there isnoinput oroutput defined inC
itself.printf isjustauseful function from thestandard library offunctions thatarenormally
accessible toCprograms. Thebehaviour ofprintf isdefined intheANSI standard, however,
soitsproperties should bethesame with any compiler and library that conforms tothe
standard. 
Inorder toconcentrate onCitself, wedon't talkmuch about input andoutput until chapter 7 .
Inparticular, wewilldefer formatted input until then. Ifyouhave toinput numbers, read the
discussion ofthefunctionscanf inSection 7.4 .scanf islikeprintf ,except that itreads
input instead of writing output. 
There areacouple ofproblems with thetemperature conversion program. Thesimpler oneis
thattheoutput isn'tvery pretty because thenumbers arenotright-justified. That's easy tofix;if
weaugment each%dintheprintf statement with awidth, thenumbers printed willberight-
justified in their fields. For instance, we might say 
   printf("%3d %6d\n", fahr, celsius);
toprint thefirst number ofeach lineinafield three digits wide, andthesecond inafield six
digits wide, like this: 
     0     -17
    20      -6
    40       4
    60      15
    80      26
   100      37
   ...
The more serious problem isthat because wehave used integer arithmetic, theCelsius
temperatures arenotvery accurate; forinstance, 0oFisactually about -17.8oC,not-17. Toget
more accurate answers, weshould use floating-point arithmetic instead ofinteger. This
requires some changes in the program. Here is the second version: 
   #include <stdio.h>
   /* print Fahrenheit-Celsius table
       for fahr = 0, 20, ..., 300; floating-point version */
   main()
   {
     float fahr, celsius;
     float lower, upper, step;
     lower = 0;      /* lower limit of temperatuire scale */
     upper = 300;    /* upper limit */
     step = 20;      /* step size */
     fahr = lower;
     while (fahr <= upper) {
         celsius = (5.0/9.0) * (fahr-32.0);
         printf("%3.0f %6.1f\n", fahr, celsius);15
         fahr = fahr + step;
     }
   }
This ismuch thesame asbefore, except thatfahr andcelsius aredeclared tobefloat and
theformula forconversion iswritten inamore natural way. Wewere unable touse5/9inthe
previous version because integer division would truncate ittozero. Adecimal point ina
constant indicates thatitisfloating point, however, so5.0/9.0 isnottruncated because itis
the ratio of two floating-point values. 
Ifanarithmetic operator hasinteger operands, aninteger operation isperformed. Ifan
arithmetic operator hasone floating-point operand and one integer operand, however, the
integer will beconverted tofloating point before theoperation isdone. Ifwehadwritten
(fahr-32) ,the32would beautomatically converted tofloating point. Nevertheless, writing
floating-point constants with explicit decimal points even when they have integral values
emphasizes their floating-point nature for human readers. 
Thedetailed rules forwhen integers areconverted tofloating point areinChapter 2 .Fornow,
notice that the assignment 
   fahr = lower;
and the test 
   while (fahr <= upper)
also work in the natural way - the int is converted to float  before the operation is done. 
Theprintf conversion specification %3.0f says thatafloating-point number (herefahr )isto
beprinted atleast three characters wide, with nodecimal point andnofraction digits.%6.1f
describes another number (celsius )thatistobeprinted atleast sixcharacters wide, with 1
digit after the decimal point. The output looks like this: 
     0   -17.8
    20    -6.7
    40     4.4
   ...
Width andprecision may beomitted from aspecification: %6fsays thatthenumber istobeat
least sixcharacters wide;%.2f specifies twocharacters after thedecimal point, butthewidth is
not constrained; and %f merely says to print the number as floating point. 
 %d  print as decimal integer
 %6d  print as decimal integer, at least 6 characters wide
 %f  print as floating point
 %6f  print as floating point, at least 6 characters wide
 %.2f   print as floating point, 2 characters after decimal point
 %6.2f    print as floating point, at least 6 wide and 2 after decimal point  
Among others,printf also recognizes %oforoctal,%xforhexadecimal, %cforcharacter, %s
for character string and %% for itself. 
Exercise 1-3.  Modify the temperature conversion program to print a heading above the table. 
Exercise 1-4.  Write a program to print the corresponding Celsius to Fahrenheit table. 
1.3 The for statement
There areplenty ofdifferent ways towrite aprogram foraparticular task. Let's tryavariation
on the temperature converter. 
   #include <stdio.h>16
   /* print Fahrenheit-Celsius table */
   main()
   {
       int fahr;
       for (fahr = 0; fahr <= 300; fahr = fahr + 20)
           printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
   }
This produces thesame answers, butitcertainly looks different. One major change isthe
elimination ofmost ofthevariables; onlyfahr remains, andwehave made itanint.The
lower andupper limits andthestep sizeappear only asconstants intheforstatement, itself a
new construction, andtheexpression that computes theCelsius temperature now appears as
the third argument of printf  instead of a separate assignment statement. 
This lastchange isaninstance ofageneral rule-inanycontext where itispermissible touse
the value of some type, you can use a more complicated expression of that type. Since the third
argument ofprintf must beafloating-point value tomatch the%6.1f ,anyfloating-point
expression can occur here. 
Thefor statement isaloop, ageneralization ofthewhile .Ifyoucompare ittotheearlier
while ,itsoperation should beclear. Within theparentheses, there arethree parts, separated by
semicolons. The first part, the initialization 
   fahr = 017
is done once, before the loop proper is entered. The second part is the
test or condition that controls the loop: 
   fahr <= 300
This condition isevaluated; ifitistrue, thebody oftheloop (here asingleptintf )is
executed. Then the increment step 
   fahr = fahr + 20
isexecuted, andthecondition re-evaluated. The loop terminates ifthecondition hasbecome
false. Aswith thewhile ,thebody oftheloop canbeasingle statement oragroup of
statements enclosed inbraces. The initialization, condition and increment can beany
expressions. 
The choice betweenwhile andfor isarbitrary, based onwhich seems clearer. Thefor is
usually appropriate forloops inwhich theinitialization andincrement aresingle statements and
logically related, since itismore compact thanwhile anditkeeps theloop control statements
together in one place. 
Exercise 1-5.  Modify the temperature conversion program to print the table in reverse order,
that is, from 300 degrees to 0. 
1.4 Symbolic Constants
Afinal observation before weleave temperature conversion forever. It'sbadpractice tobury
``magic numbers'' like300and20inaprogram; they convey little information tosomeone who
might have toread theprogram later, andthey arehard tochange inasystematic way. One
way todeal with magic numbers istogive them meaningful names. A#define linedefines a
symbolic name or symbolic constant  to be a particular string of characters: 
  #define  name replacement list  
Thereafter, anyoccurrence ofname (not inquotes and notpart ofanother name) will be
replaced bythecorresponding replacement text.The name hasthesame form asavariable
name: asequence ofletters anddigits that begins with aletter. The replacement textcanbe
any sequence of characters; it is not limited to numbers. 
   #include <stdio.h>
   #define LOWER  0     /* lower limit of table */
   #define UPPER  300   /* upper limit */
   #define STEP   20    /* step size */
   /* print Fahrenheit-Celsius table */
   main()
   {
       int fahr;
       for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
           printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
   }
The quantities LOWER ,UPPER andSTEP aresymbolic constants, notvariables, sothey donot
appear indeclarations. Symbolic constant names areconventionally written inupper case so
they canberreadily distinguished from lower case variable names. Notice that there isno
semicolon at the end of a #define  line. 
1.5 Character Input and Output
Wearegoing toconsider afamily ofrelated programs forprocessing character data. You will
find that many programs are just expanded versions of the prototypes that we discuss here. 18
Themodel ofinput andoutput supported bythestandard library isvery simple. Text input or
output, regardless ofwhere itoriginates orwhere itgoes to,isdealt with asstreams of
characters. Atextstream isasequence ofcharacters divided into lines; each lineconsists of
zero or more characters followed by a newline character. It is the responsibility of the library to
make each input oroutput stream confirm thismodel; theCprogrammer using thelibrary need
not worry about how lines are represented outside the program. 
Thestandard library provides several functions forreading orwriting onecharacter atatime,
ofwhichgetchar andputchar arethesimplest. Each time itiscalled,getchar reads thenext
input character  from a text stream and returns that as its value. That is, after 
   c = getchar();
thevariableccontains thenext character ofinput. The characters normally come from the
keyboard; input from files is discussed in Chapter 7 . 
The function putchar  prints a character each time it is called: 
   putchar(c);
prints thecontents oftheinteger variablecasacharacter, usually onthescreen. Calls to
putchar andprintf may beinterleaved; theoutput willappear intheorder inwhich thecalls
are made. 
1.5.1 File Copying
Givengetchar andputchar ,you canwrite asurprising amount ofuseful code without
knowing anything more about input andoutput. Thesimplest example isaprogram thatcopies
its input to its output one character at a time: 
read a character
    while ( charater is not end-of-file indicator )
        output the character just read
        read a character
Converting this into C gives: 
   #include <stdio.h>
   /* copy input to output; 1st version  */
   main()
   {
       int c;
       c = getchar();
       while (c != EOF) {
           putchar(c);
           c = getchar();
       }
   }
The relational operator != means ``not equal to''. 
What appears tobeacharacter onthekeyboard orscreen isofcourse, likeeverything else,
stored internally justasabitpattern. The typechar isspecifically meant forstoring such
character data, butanyinteger type canbeused. Weusedint forasubtle butimportant
reason. 
The problem isdistinguishing theendofinput from valid data. The solution isthatgetchar
returns adistinctive value when there isnomore input, avalue thatcannot beconfused with
anyrealcharacter. This value iscalledEOF,for``end offile''. Wemust declarectobeatype
bigenough tohold anyvalue thatgetchar returns. Wecan't usechar sincecmust bebig
enough to hold EOF in addition to any possible char . Therefore we use int. 19
EOFisaninteger defined in<stdio.h>, butthespecific numeric value doesn't matter aslong as
itisnotthesame asanychar value. Byusing thesymbolic constant, weareassured that
nothing in the program depends on the specific numeric value. 
Theprogram forcopying would bewritten more concisely byexperienced Cprogrammers. In
C, any assignment, such as 
   c = getchar();
isanexpression andhasavalue, which isthevalue ofthelefthand side after theassignment.
This means thataassignment canappear aspart ofalarger expression. Iftheassignment ofa
character tocisputinside thetestpart ofawhile loop, thecopy program canbewritten this
way: 
   #include <stdio.h>
   /* copy input to output; 2nd version  */
   main()
   {
       int c;
       while ((c = getchar()) != EOF)
           putchar(c);
   }
Thewhile gets acharacter, assigns ittoc,andthen tests whether thecharacter wastheend-
of-file signal. Ifitwas not, thebody ofthewhile isexecuted, printing thecharacter. The
while then repeats. When theendoftheinput isfinally reached, thewhile terminates andso
does main . 
This version centralizes theinput -there isnow only onereference togetchar -andshrinks
theprogram. Theresulting program ismore compact, and, once theidiom ismastered, easier
toread. You'll seethisstyle often. (It's possible togetcarried away andcreate impenetrable
code, however, a tendency that we will try to curb.) 
Theparentheses around theassignment, within thecondition arenecessary. Theprecedence of
!= is higher than that of =, which means that in the absence of parentheses the relational test !=
would be done before the assignment =. So the statement 
   c = getchar() != EOF
is equivalent to 
   c = (getchar() != EOF)
This hastheundesired effect ofsettingcto0or1,depending onwhether ornotthecallof
getchar  returned end of file. (More on this in Chapter 2 .) 
Exercsise 1-6.  Verify that the expression getchar() != EOF  is 0 or 1. 
Exercise 1-7.  Write a program to print the value of EOF. 
1.5.2 Character Counting
The next program counts characters; it is similar to the copy program. 
   #include <stdio.h>
   /* count characters in input; 1st version */
   main()
   {
       long nc;
       nc = 0;
       while (getchar() != EOF)20
           ++nc;
       printf("%ld\n", nc);
   }
The statement 
   ++nc;
presents anew operator, ++,which means increment byone.You could instead writenc=nc
+ 1 but ++nc  is more concise and often more efficient. There is a corresponding operator -- to
decrement by1.The operators ++and--canbeeither prefix operators (++nc )orpostfix
operators (nc++ );these two forms have different values inexpressions, aswillbeshown in
Chapter 2 ,but++nc andnc++ both increment nc.Forthemoment wewillwillstick tothe
prefix form. 
The character counting program accumulates itscount inalong variable instead ofanint.
long  integers are at least 32 bits. Although on some machines, int and long  are the same size,
onothers anintis16bits, with amaximum value of32767, anditwould take relatively little
input tooverflow anint counter. The conversion specification %ld tellsprintf that the
corresponding argument is a long  integer. 
Itmay bepossible tocope with even bigger numbers byusing adouble (double precision
float ).Wewillalsouseaforstatement instead ofawhile ,toillustrate another way towrite
the loop. 
    #include <stdio.h>
   /* count characters in input; 2nd version */
   main()
   {
       double nc;
       for (nc = 0; gechar() != EOF; ++nc)
           ;
       printf("%.0f\n", nc);
   }
printf uses%fforbothfloat anddouble ;%.0f suppresses theprinting ofthedecimal point
and the fraction part, which is zero. 
The body ofthisforloop isempty, because allthework isdone inthetestandincrement
parts. Butthegrammatical rules ofCrequire thataforstatement have abody. The isolated
semicolon, called anullstatement ,isthere tosatisfy thatrequirement. Weputitonaseparate
line to make it visible. 
Before weleave thecharacter counting program, observe that iftheinput contains no
characters, thewhile orfor testfails onthevery first calltogetchar ,andtheprogram
produces zero, theright answer. This isimportant. One ofthenicethings aboutwhile andfor
isthatthey testatthetopoftheloop, before proceeding with thebody. Ifthere isnothing to
do,nothing isdone, even ifthatmeans never going through theloop body. Programs should
actintelligently when given zero-length input. Thewhile andforstatements help ensure that
programs do reasonable things with boundary conditions. 
1.5.3 Line Counting
Thenext program counts input lines. Aswementioned above, thestandard library ensures that
aninput text stream appears asasequence oflines, each terminated byanewline. Hence,
counting lines is just counting newlines: 
   #include <stdio.h>
   /* count lines in input */
   main()21
   {
       int c, nl;
       nl = 0;
       while ((c = getchar()) != EOF)
           if (c == '\n')
               ++nl;
       printf("%d\n", nl);
   }
Thebody ofthewhile now consists ofanif,which inturn controls theincrement ++nl .The
ifstatement tests theparenthesized condition, and ifthecondition istrue, executes the
statement (orgroup ofstatements inbraces) that follows. Wehave again indented toshow
what is controlled by what. 
Thedouble equals sign==istheCnotation for``isequal to''(like Pascal's single=orFortran's
.EQ. ).This symbol isused todistinguish theequality testfrom thesingle=that Cuses for
assignment. Aword ofcaution: newcomers toCoccasionally write=when they mean==.As
we will see in Chapter 2 , the result is usually a legal expression, so you will get no warning. 
Acharacter written between single quotes represents aninteger value equal tothenumerical
value ofthecharacter inthemachine's character set.This iscalled acharacter constant ,
although itisjustanother way towrite asmall integer. So,forexample, 'A' isacharacter
constant; intheASCII character setitsvalue is65,theinternal representation ofthecharacter
A.Ofcourse,'A'istobepreferred over65:itsmeaning isobvious, anditisindependent ofa
particular character set. 
The escape sequences used instring constants arealso legal incharacter constants, so'\n'
stands forthevalue ofthenewline character, which is10inASCII. You should note carefully
that'\n' isasingle character, andinexpressions isjustaninteger; ontheother hand,'\n' is
astring constant that happens tocontain only one character. The topic ofstrings versus
characters is discussed further in Chapter 2 . 
Exercise 1-8.  Write a program to count blanks, tabs, and newlines. 
Exercise 1-9. Write aprogram tocopy itsinput toitsoutput, replacing each string ofoneor
more blanks by a single blank. 
Exercise 1-10. Write aprogram tocopy itsinput toitsoutput, replacing each tabby\t,each
backspace by\b,andeach backslash by\\.This makes tabs andbackspaces visible inan
unambiguous way. 
1.5.4 Word Counting
Thefourth inourseries ofuseful programs counts lines, words, andcharacters, with theloose
definition that aword isanysequence ofcharacters that does notcontain ablank, tabor
newline. This is a bare-bones version of the UNIX program wc. 
   #include <stdio.h>
   #define IN   1  /* inside a word */
   #define OUT  0  /* outside a word */
   /* count lines, words, and characters in input */
   main()
   {
       int c, nl, nw, nc, state;
       state = OUT;
       nl = nw = nc = 0;
       while ((c = getchar()) != EOF) {22
           ++nc;
           if (c == '\n')
               ++nl;
           if (c == ' ' || c == '\n' || c = '\t')
               state = OUT;
           else if (state == OUT) {
               state = IN;
               ++nw;
           }
       }
       printf("%d %d %d\n", nl, nw, nc);
   }
Every time theprogram encounters thefirstcharacter ofaword, itcounts onemore word. The
variablestate records whether theprogram iscurrently inaword ornot;initially itis``not in
aword'', which isassigned thevalueOUT.Weprefer thesymbolic constants INandOUTtothe
literal values 1and0because they make theprogram more readable. Inaprogram astinyas
this, itmakes little difference, butinlarger programs, theincrease inclarity iswell worth the
modest extra effort towrite itthisway from thebeginning. You'll also findthatit'seasier to
make extensive changes in programs where magic numbers appear only as symbolic constants. 23
The line 
   nl = nw = nc = 0;
setsallthree variables tozero. This isnotaspecial case, butaconsequence ofthefactthatan
assignment isanexpression with thevalue andassignments associated from right toleft.It'sas
if we had written 
   nl = (nw = (nc = 0));
The operator || means OR, so the line 
   if (c == ' ' || c == '\n' || c = '\t')
says ``ifcisablank orcisanewline orcisatab''. (Recall thattheescape sequence \tisa
visible representation ofthetabcharacter.) There isacorresponding operator&&forAND; its
precedence isjusthigher than||.Expressions connected by&&or||areevaluated leftto
right, anditisguaranteed thatevaluation willstop assoon asthetruth orfalsehood isknown.
Ifcisablank, there isnoneed totestwhether itisanewline ortab,sothese tests arenot
made. This isn'tparticularly important here, butissignificant inmore complicated situations, as
we will soon see. 
Theexample also shows anelse ,which specifies analternative action ifthecondition part of
an if statement is false. The general form is 
   if (expression )
       statement 1
   else
       statement 2
One andonly one ofthetwo statements associated with anif-else isperformed. Ifthe
expression istrue, statement 1isexecuted; ifnot,statement 2isexecuted. Each statement canbe
asingle statement orseveral inbraces. Intheword count program, theoneafter theelse isan
if that controls two statements in braces. 
Exercise 1-11. How would youtesttheword count program? What kinds ofinput aremost
likely to uncover bugs if there are any? 
Exercise 1-12.  Write a program that prints its input one word per line. 
1.6 Arrays
Letiswrite aprogram tocount thenumber ofoccurrences ofeach digit, ofwhite space
characters (blank, tab,newline), andofallother characters. This isartificial, butitpermits us
to illustrate several aspects of C in one program. 
There aretwelve categories ofinput, soitisconvenient touseanarray tohold thenumber of
occurrences ofeach digit, rather than tenindividual variables. Here isone version ofthe
program: 24
   #include <stdio.h>
   /* count digits, white space, others */
   main()
   {
       int c, i, nwhite, nother;
       int ndigit[10];
       nwhite = nother = 0;
       for (i = 0; i < 10; ++i)
           ndigit[i] = 0;
       while ((c = getchar()) != EOF)
           if (c >= '0' && c <= '9')
               ++ndigit[c-'0'];
           else if (c == ' ' || c == '\n' || c == '\t')
               ++nwhite;
           else
               ++nother;
       printf("digits =");
       for (i = 0; i < 10; ++i)
           printf(" %d", ndigit[i]);
       printf(", white space = %d, other = %d\n",
           nwhite, nother);
   }
The output of this program on itself is 
   digits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345
The declaration 
   int ndigit[10];
declaresndigit tobeanarray of10integers. Array subscripts always start atzero inC,sothe
elements arendigit[0], ndigit[1], ...,ndigit[9] .This isreflected intheforloops
that initialize and print the array. 
A subscript can be any integer expression, which includes integer variables like i, and integer
constants. 
This particular program relies ontheproperties ofthecharacter representation ofthedigits.
For example, the test 
   if (c >= '0' && c <= '9')
determines whether the character in c is a digit. If it is, the numeric value of that digit is 
   c - '0'
This works only if'0','1',...,'9'have consecutive increasing values. Fortunately, this
is true for all character sets. 
Bydefinition, char sarejustsmall integers, sochar variables andconstants areidentical to
intsinarithmetic expressions. This isnatural andconvenient; forexamplec-'0' isaninteger
expression with a value between 0 and 9 corresponding to the character '0' to '9' stored in c,
and thus a valid subscript for the array ndigit . 
Thedecision astowhether acharacter isadigit, white space, orsomething elseismade with
the sequence 
   if (c >= '0' && c <= '9')
       ++ndigit[c-'0'];
   else if (c == ' ' || c == '\n' || c == '\t')
       ++nwhite;25
   else
       ++nother;
The pattern 
   if (condition 1)
       statement 1
   else if ( condition 2)
       statement 2
       ...
       ...
   else
       statement n
occurs frequently inprograms asaway toexpress amulti-way decision. The conditions are
evaluated inorder from the top until some condition issatisfied; atthat point the
corresponding statement part isexecuted, and theentire construction isfinished. (Any
statement canbeseveral statements enclosed inbraces.) Ifnone oftheconditions issatisfied,
thestatement after thefinalelse isexecuted ifitispresent. Ifthefinalelse andstatement are
omitted, as in the word count program, no action takes place. There can be any number of 
else if (condition )
  statement  
groups between the initial if and the final else . 
Asamatter ofstyle, itisadvisable toformat thisconstruction aswehave shown; ifeachif
were indented past thepreviouselse ,along sequence ofdecisions would march offtheright
side of the page. 
Theswitch statement, tobediscussed inChapter 4 ,provides another way towrite amulti-
way branch thatisparticulary suitable when thecondition iswhether some integer orcharacter
expression matches oneofasetofconstants. Forcontrast, wewillpresent aswitch version of
this program in Section 3.4 . 
Exercise 1-13. Write aprogram toprint ahistogram ofthelengths ofwords initsinput. Itis
easy to draw the histogram with the bars horizontal; a vertical orientation is more challenging. 
Exercise 1-14. Write aprogram toprint ahistogram ofthefrequencies ofdifferent characters
in its input. 
1.7 Functions
InC,afunction isequivalent toasubroutine orfunction inFortran, oraprocedure orfunction
inPascal. Afunction provides aconvenient way toencapsulate some computation, which can
then beused without worrying about itsimplementation. With properly designed functions, it
ispossible toignore how ajobisdone; knowing what isdone issufficient. Cmakes thesueof
functions easy, convinient andefficient; youwilloften seeashort function defined andcalled
only once, just because it clarifies some piece of code. 
Sofarwehave used only functions likeprintf ,getchar andputchar that have been
provided forus;now it'stime towrite afew ofourown. Since Chasnoexponentiation
operator likethe**ofFortran, letusillustrate themechanics offunction definition bywriting
afunctionpower(m,n) toraise anintegermtoapositive integer powern.That is,thevalue of
power(2,5) is32.This function isnotapractical exponentiation routine, since ithandles only
positive powers ofsmall integers, butit'sgood enough forillustration.(The standard library
contains a function pow(x,y)  that computes xy.) 
Here isthefunctionpower and amain program toexercise it,soyou canseethewhole
structure at once. 26
   #include <stdio.h>
   int power(int m, int n);
    /* test power function */
    main()
    {
        int i;
        for (i = 0; i < 10; ++i)
            printf("%d %d %d\n", i, power(2,i), power(-3,i));
        return 0;
    }
    /* power:  raise base to n-th power; n >= 0 */
    int power(int base, int n)
    {
        int i,  p;
        p = 1;
        for (i = 1; i <= n; ++i)
            p = p * base;
        return p;
    }
A function definition has this form: 
return-type function-name(parameter declarations, if any)
{
   declarations
   statements
}
Function definitions canappear inanyorder, andinonesource fileorseveral, although no
function canbesplit between files. Ifthesource program appears inseveral files, youmay have
tosaymore tocompile andload itthan ifitallappears inone, butthatisanoperating system
matter, notalanguage attribute. Forthemoment, wewillassume thatboth functions areinthe
same file, so whatever you have learned about running C programs will still work. 
The function power  is called twice by main , in the line 
   printf("%d %d %d\n", i, power(2,i), power(-3,i));
Each callpasses twoarguments topower ,which each time returns aninteger tobeformatted
andprinted. Inanexpression, power(2,i) isaninteger justas2andiare.(Not allfunctions
produce an integer value; we will take this up in Chapter 4 .) 
The first line of power  itself, 
    int power(int base, int n)
declares theparameter types andnames, andthetype oftheresult that thefunction returns.
The names used bypower foritsparameters arelocal topower ,andarenotvisible toany
other function: other routines canusethesame names without conflict. This isalso trueofthe
variables i and p: the i in power  is unrelated to the i in main . 
Wewillgenerally useparameter foravariable named intheparenthesized listinafunction.
The terms formal argument  and actual argument  are sometimes used for the same distinction. 
Thevalue thatpower computes isreturned tomain bythereturn :statement. Any expression
may follow return : 
   return expression ;
Afunction need notreturn avalue; areturn statement with noexpression causes control, but
nouseful value, tobereturned tothecaller, asdoes ``falling offtheend'' ofafunction by27
reaching theterminating right brace. And thecalling function canignore avalue returned bya
function. 
You may have noticed that there isareturn statement attheendofmain .Sincemain isa
function likeanyother, itmay return avalue toitscaller, which isineffect theenvironment in
which theprogram wasexecuted. Typically, areturn value ofzero implies normal termination;
non-zero values signal unusual orerroneous termination conditions. Intheinterests of
simplicity, wehave omittedreturn statements from ourmain functions uptothispoint, but
wewill include them hereafter, asareminder that programs should return status totheir
environment. 
The declaration 
    int power(int base, int n);
justbeforemain says thatpower isafunction thatexpects twointarguments andreturns an
int.This declaration, which iscalled afunction prototype ,hastoagree with thedefinition and
uses ofpower .Itisanerror ifthedefinition ofafunction oranyuses ofitdonotagree with its
prototype. 
parameter names need not agree. Indeed, parameter names areoptional inafunction
prototype, so for the prototype we could have written 
    int power(int, int);
Well-chosen names are good documentation however, so we will often use them. 
Anote ofhistory: thebiggest change between ANSI Candearlier versions ishow functions
aredeclared anddefined. Intheoriginal definition ofC,thepower function would have been
written like this: 28
   /* power:  raise base to n-th power; n >= 0 */
   /*         (old-style version) */
   power(base, n)
   int base, n;
   {
       int i, p;
       p = 1;
       for (i = 1; i <= n; ++i)
           p = p * base;
       return p;
   }
The parameters arenamed between theparentheses, and their types aredeclared before
opening theleftbrace; undeclared parameters aretaken asint.(The body ofthefunction is
the same as before.) 
The declaration of power  at the beginning of the program would have looked like this: 
    int power();
Noparameter listwaspermitted, sothecompiler could notreadily check thatpower wasbeing
called correctly. Indeed, since by default power  would have been assumed to return an int, the
entire declaration might well have been omitted. 
Thenew syntax offunction prototypes makes itmuch easier foracompiler todetect errors in
thenumber ofarguments ortheir types. Theoldstyle ofdeclaration anddefinition stillworks
inANSI C,atleast foratransition period, butwestrongly recommend thatyouusethenew
form when you have a compiler that supports it. 
Exercise 1.15. Rewrite thetemperature conversion program ofSection 1.2 touseafunction
for conversion. 
1.8 Arguments - Call by Value
One aspect ofCfunctions may beunfamiliar toprogrammers who areused tosome other
languages, particulary Fortran. InC,allfunction arguments arepassed ``byvalue.'' This means
thatthecalled function isgiven thevalues ofitsarguments intemporary variables rather than
theoriginals. This leads tosome different properties than areseen with ``call byreference''
languages likeFortran orwithvarparameters inPascal, inwhich thecalled routine hasaccess
to the original argument, not a local copy. 
Call byvalue isanasset, however, notaliability. Itusually leads tomore compact programs
with fewer extraneous variables, because parameters canbetreated asconveniently initialized
local variables inthecalled routine. Forexample, here isaversion ofpower thatmakes useof
this property. 
   /* power:  raise base to n-th power; n >= 0; version 2 */
   int power(int base, int n)
   {
       int p;
       for (p = 1; n > 0; --n)
           p = p * base;
       return p;
   }
The parameter nisused asatemporary variable, andiscounted down (aforloop that runs
backwards) until itbecomes zero; there isnolonger aneed forthevariablei.Whatever is
done to n inside power  has no effect on the argument that power  was originally called with. 
When necessary, it is possible to arrange for a function to modify a variable in a calling routine.
The caller must provide theaddress ofthevariable tobeset(technically apointer tothe29
variable), andthecalled function must declare theparameter tobeapointer andaccess the
variable indirectly through it. We will cover pointers in Chapter 5 . 
Thestory isdifferent forarrays. When thename ofanarray isused asanargument, thevalue
passed tothefunction isthelocation oraddress ofthebeginning ofthearray -there isno
copying ofarray elements. Bysubscripting thisvalue, thefunction canaccess andalter any
argument of the array. This is the topic of the next section. 
1.9 Character Arrays
The most common type ofarray inCisthearray ofcharacters. Toillustrate theuseof
character arrays andfunctions tomanipulate them, let'swrite aprogram thatreads asetoftext
lines and prints the longest. The outline is simple enough: 
   while ( there's another line )
       if ( it's longer than the previous longest )
           ( save it)
           ( save its length )
   print longest line
This outline makes itclear thattheprogram divides naturally intopieces. One piece gets anew
line, another saves it, and the rest controls the process. 
Since things divide sonicely, itwould bewell towrite them thatway too. Accordingly, letus
first write aseparate functiongetline tofetch thenext lineofinput. Wewilltrytomake the
function useful inother contexts. Attheminimum, getline hastoreturn asignal about
possible endoffile;amore useful design would betoreturn thelength oftheline, orzero if
endoffileisencountered. Zero isanacceptable end-of-file return because itisnever avalid
linelength. Every textlinehasatleast onecharacter; even alinecontaining only anewline has
length 1. 
When wefindalinethatislonger than theprevious longest line, itmust besaved somewhere.
This suggests a second function, copy , to copy the new line to a safe place. 
Finally, we need a main program to control getline  and copy . Here is the result. 30
   #include <stdio.h>
   #define MAXLINE 1000   /* maximum input line length */
   int getline(char line[], int maxline);
   void copy(char to[], char from[]);
   /* print the longest input line */
   main()
   {
       int len;            /* current line length */
       int max;            /* maximum length seen so far */
       char line[MAXLINE];    /* current input line */
       char longest[MAXLINE]; /* longest line saved here */
       max = 0;
       while ((len = getline(line, MAXLINE)) > 0)
           if (len > max) {
               max = len;
               copy(longest, line);
           }
       if (max > 0)  /* there was a line */
           printf("%s", longest);
       return 0;
   }
   /* getline:  read a line into s, return length  */
   int getline(char s[],int lim)
   {
       int c, i;
       for (i=0; i < lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)
           s[i] = c;
       if (c == '\n') {
           s[i] = c;
           ++i;
       }
       s[i] = '\0';
       return i;
   }
   /* copy:  copy 'from' into 'to'; assume to is big enough */
   void copy(char to[], char from[])
   {
       int i;
       i = 0;
       while ((to[i] = from[i]) != '\0')
           ++i;
   }
The functions getline andcopy aredeclared atthebeginning oftheprogram, which we
assume is contained in one file. 
main andgetline communicate through apair ofarguments and areturned value. In
getline , the arguments are declared by the line 
   int getline(char s[], int lim);
which specifies thatthefirst argument, s,isanarray, andthesecond,lim,isaninteger. The
purpose ofsupplying thesizeofanarray inadeclaration istosetaside storage. Thelength of
anarraysisnotnecessary ingetline since itssizeissetinmain .getline usesreturn to
send avalue back tothecaller, justasthefunctionpower did. This linealso declares that
getline  returns an int; since int is the default return type, it could be omitted. 
Some functions return a useful value; others, like copy , are used only for their effect and return
no value. The return type of copy  is void , which states explicitly that no value is returned. 31
getline puts thecharacter '\0' (the null character ,whose value iszero) attheendofthe
array itiscreating, tomark theendofthestring ofcharacters. This conversion isalso used by
the C language: when a string constant like 
   "hello\n"
appears inaCprogram, itisstored asanarray ofcharacters containing thecharacters inthe
string and terminated with a '\0'  to mark the end. 
 
The%sformat specification inprintf expects thecorresponding argument tobeastring
represented inthisform.copy also relies onthefactthatitsinput argument isterminated with
a '\0' , and copies this character into the output. 
Itisworth mentioning inpassing thateven aprogram assmall asthisonepresents some sticky
design problems. Forexample, what shouldmain doifitencounters alinewhich isbigger than
itslimit?getline works safely, inthat itstops collecting when thearray isfull, even ifno
newline hasbeen seen. Bytesting thelength and thelast character returned, main can
determine whether thelinewastoolong, andthen cope asitwishes. Intheinterests ofbrevity,
we have ignored this issue. 
There isnoway forauser ofgetline toknow inadvance how long aninput linemight be,so
getline checks foroverflow. Ontheother hand, theuser ofcopy already knows (orcanfind
out) how big the strings are, so we have chosen not to add error checking to it. 
Exercise 1-16. Revise themain routine ofthelongest-line program soitwillcorrectly print the
length of arbitrary long input lines, and as much as possible of the text. 
Exercise 1-17.  Write a program to print all input lines that are longer than 80 characters. 
Exercise 1-18. Write aprogram toremove trailing blanks andtabsfrom each lineofinput, and
to delete entirely blank lines. 
Exercise 1-19. Write afunctionreverse(s) that reverses thecharacter strings.Use itto
write a program that reverses its input a line at a time. 
1.10 External Variables and Scope
Thevariables inmain ,such asline ,longest ,etc., areprivate orlocal tomain .Because they
aredeclared withinmain ,noother function canhave direct access tothem. Thesame istrueof
thevariables inother functions; forexample, thevariableiingetline isunrelated totheiin
copy. Each local variable inafunction comes into existence only when thefunction iscalled,
anddisappears when thefunction isexited. This iswhy such variables areusually known as
automatic variables, following terminology inother languages. Wewillusetheterm automatic
henceforth torefer tothese local variables. (Chapter 4 discusses thestatic storage class, in
which local variables do retain their values between calls.) 
Because automatic variables come andgowith function invocation, they donotretain their
values from onecalltothenext, andmust beexplicitly setupon each entry. Ifthey arenotset,
they will contain garbage. 
Asanalternative toautomatic variables, itispossible todefine variables thatareexternal toall
functions, thatis,variables thatcanbeaccessed byname byanyfunction. (This mechanism is
rather likeFortran COMMON orPascal variables declared intheoutermost block.) Because32
external variables areglobally accessible, they can beused instead ofargument lists to
communicate data between functions. Furthermore, because external variables remain in
existence permanently, rather than appearing and disappearing asfunctions arecalled and
exited, they retain their values even after the functions that set them have returned. 
Anexternal variable must bedefined ,exactly once, outside ofanyfunction; thissets aside
storage forit.Thevariable must also bedeclared ineach function thatwants toaccess it;this
states thetype ofthevariable. Thedeclaration may beanexplicitextern statement ormay be
implicit from context. Tomake thediscussion concrete, letusrewrite thelongest-line program
withline ,longest ,andmax asexternal variables. This requires changing thecalls,
declarations, and bodies of all three functions. 
   #include <stdio.h>
   #define MAXLINE 1000    /* maximum input line size */
   int max;                /* maximum length seen so far */
   char line[MAXLINE];     /* current input line */
   char longest[MAXLINE];  /* longest line saved here */
   int getline(void);
   void copy(void);
   /* print longest input line; specialized version */
   main()
   {
       int len;
       extern int max;
       extern char longest[];
       max = 0;
       while ((len = getline()) > 0)
           if (len > max) {
               max = len;
               copy();
           }
       if (max > 0)  /* there was a line */
           printf("%s", longest);
       return 0;
   }33
   /* getline:  specialized version */
   int getline(void)
   {
       int c, i;
       extern char line[];
       for (i = 0; i < MAXLINE - 1
            && (c=getchar)) != EOF && c != '\n'; ++i)
                line[i] = c;
       if (c == '\n') {
           line[i] = c;
           ++i;
       }
       line[i] = '\0';
       return i;
   }
   /* copy: specialized version */
   void copy(void)
   {
       int i;
       extern char line[], longest[];
       i = 0;
       while ((longest[i] = line[i]) != '\0')
           ++i;
   }
Theexternal variables inmain ,getline andcopy aredefined bythefirstlines oftheexample
above, which state their type andcause storage tobeallocated forthem. Syntactically, external
definitions arejustlikedefinitions oflocal variables, butsince they occur outside offunctions,
thevariables areexternal. Before afunction canuseanexternal variable, thename ofthe
variable must bemade known tothefunction; thedeclaration isthesame asbefore except for
the added keyword extern . 
Incertain circumstances, theextern declaration can beomitted. Ifthedefinition ofthe
external variable occurs inthesource filebefore itsuseinaparticular function, then there isno
need foranextern declaration inthefunction. Theextern declarations inmain ,getline and
copy arethus redundant. Infact, common practice istoplace definitions ofallexternal
variables at the beginning of the source file, and then omit all extern declarations. 
Iftheprogram isinseveral source files, andavariable isdefined infile1 andused infile2 and
file3,thenextern declarations areneeded infile2 andfile3 toconnect theoccurrences ofthe
variable. The usual practice istocollectextern declarations ofvariables andfunctions ina
separate file, historically called aheader ,that isincluded by#include atthefront ofeach
source file. The suffix.hisconventional forheader names. The functions ofthestandard
library, forexample, aredeclared inheaders like<stdio.h> .This topic isdiscussed atlength
in Chapter 4 , and the library itself in Chapter 7  and Appendix B . 
Since thespecialized versions ofgetline andcopy have noarguments, logic would suggest
that their prototypes atthebeginning ofthefileshould begetline() andcopy() .Butfor
compatibility with older Cprograms thestandard takes anempty listasanold-style
declaration, and turns offallargument listchecking; thewordvoid must beused foran
explicitly empty list. We will discuss this further in Chapter 4 . 
You should note that weareusing thewords definition anddeclaration carefully when we
refer toexternal variables inthissection.``Definition'' refers totheplace where thevariable is
created orassigned storage; ``declaration'' refers toplaces where thenature ofthevariable is
stated but no storage is allocated. 34
Bytheway, there isatendency tomake everything insight anextern variable because it
appears tosimplify communications -argument lists areshort andvariables arealways there
when youwant them. Butexternal variables arealways there even when youdon't want them.
Relying tooheavily onexternal variables isfraught with peril since itleads toprograms whose
data connections arenotallobvious -variables canbechanged inunexpected and even
inadvertent ways, andtheprogram ishard tomodify. The second version ofthelongest-line
program isinferior tothefirst, partly forthese reasons, andpartly because itdestroys the
generality oftwo useful functions bywriting into them thenames ofthevariables they
manipulate. 
Atthispoint wehave covered what might becalled theconventional core ofC.With this
handful ofbuilding blocks, it'spossible towrite useful programs ofconsiderable size, andit
would probably beagood idea ifyoupaused long enough todoso.These exercises suggest
programs of somewhat greater complexity than the ones earlier in this chapter. 
Exercise 1-20. Write aprogramdetab thatreplaces tabs intheinput with theproper number
ofblanks tospace tothenext tabstop. Assume afixed setoftabstops, sayevery ncolumns.
Should n be a variable or a symbolic parameter? 
Exercise 1-21. Write aprogramentab thatreplaces strings ofblanks bytheminimum number
oftabs andblanks toachieve thesame spacing. Use thesame tabstops asfordetab .When
either ataborasingle blank would suffice toreach atabstop, which should begiven
preference? 
Exercise 1-22. Write aprogram to``fold'' long input lines intotwoormore shorter lines after
thelastnon-blank character that occurs before then-thcolumn ofinput. Make sure your
program does something intelligent with very long lines, andifthere arenoblanks ortabs
before the specified column. 
Exercise 1-23. Write aprogram toremove allcomments from aCprogram. Don't forget to
handle quoted strings and character constants properly. C comments don't nest. 
Exercise 1-24. Write aprogram tocheck aCprogram forrudimentary syntax errors like
unmatched parentheses, brackets and braces. Don't forget about quotes, both single and
double, escape sequences, and comments. (This program is hard if you do it in full generality.) 35
Chapter 2 - Types, Operators and
Expressions
Variables andconstants arethebasic data objects manipulated inaprogram. Declarations list
the variables to be used, and state what type they have and perhaps what their initial values are.
Operators specify what istobedone tothem. Expressions combine variables andconstants to
produce new values. Thetype ofanobject determines thesetofvalues itcanhave andwhat
operations can be performed on it. These building blocks are the topics of this chapter. 
The ANSI standard has made many small changes and additions to basic types and expressions.
There arenowsigned andunsigned forms ofallinteger types, andnotations forunsigned
constants and hexadecimal character constants. Floating-point operations may bedone in
single precision; there isalso along double type forextended precision. String constants may
beconcatenated atcompile time. Enumerations have become partofthelanguage, formalizing
afeature oflong standing. Objects may bedeclaredconst ,which prevents them from being
changed. The rules forautomatic coercions among arithmetic types have been augmented to
handle the richer set of types. 
2.1 Variable Names
Although wedidn't saysoinChapter 1 ,there aresome restrictions onthenames ofvariables
andsymbolic constants. Names aremade upofletters anddigits; thefirst character must bea
letter. The underscore ``_''counts asaletter; itissometimes useful forimproving the
readability oflong variable names. Don't begin variable names with underscore, however, since
library routines often usesuch names. Upper andlower case letters aredistinct, soxandXare
two different names. Traditional Cpractice istouselower case forvariable names, andall
upper case for symbolic constants. 
Atleast thefirst 31characters ofaninternal name aresignificant. Forfunction names and
external variables, thenumber may belessthan 31,because external names may beused by
assemblers and loaders over which thelanguage hasnocontrol. For external names, the
standard guarantees uniqueness only for6characters andasingle case. Keywords likeif,
else ,int,float ,etc., arereserved: youcan't usethem asvariable names. They must bein
lower case. 
It'swise tochoose variable names thatarerelated tothepurpose ofthevariable, andthatare
unlikely togetmixed uptypographically. Wetend touseshort names forlocal variables,
especially loop indices, and longer names for external variables. 
2.2 Data Types and Sizes
There are only a few basic data types in C: 
char a single byte, capable of holding one character in the local character set
int an integer, typically reflecting the natural size of integers on the host machine
float single-precision floating point
double double-precision floating point
Inaddition, there areanumber ofqualifiers thatcanbeapplied tothese basic types.short and
long  apply to integers: 
   short int sh;
   long int counter;
The word int can be omitted in such declarations, and typically it is. 36
Theintent isthatshort andlong should provide different lengths ofintegers where practical;
intwillnormally bethenatural sizeforaparticular machine. short isoften 16bitslong, and
int either 16or32bits. Each compiler isfree tochoose appropriate sizes foritsown
hardware, subject only tothetherestriction thatshort sandintsareatleast 16bits,long sare
at least 32 bits, and short  is no longer than int, which is no longer than long . 
Thequalifiersigned orunsigned may beapplied tochar oranyinteger.unsigned numbers
arealways positive orzero, andobey thelaws ofarithmetic modulo 2n,where nisthenumber
ofbitsinthetype. So,forinstance, ifchar sare8bits,unsigned char variables have values
between 0and 255, whilesignedchar shave values between -128 and 127 (inatwo's
complement machine.) Whether plainchar saresigned orunsigned ismachine-dependent, but
printable characters are always positive. 
Thetypelongdouble specifies extended-precision floating point. Aswith integers, thesizes
offloating-point objects areimplementation-defined; float ,double andlongdouble could
represent one, two or three distinct sizes. 
The standard headers<limits.h> and<float.h> contain symbolic constants forallofthese
sizes, along with other properties ofthemachine and compiler. These arediscussed in
Appendix B . 
Exercise 2-1. Write aprogram todetermine theranges ofchar ,short ,int,andlong
variables, bothsigned andunsigned ,byprinting appropriate values from standard headers
andbydirect computation. Harder ifyoucompute them: determine theranges ofthevarious
floating-point types. 
2.3 Constants
Aninteger constant like1234 isanint.Along constant iswritten with aterminall(ell) orL,
asin123456789L ;aninteger constant toobigtofitinto anintwillalso betaken asalong.
Unsigned constants arewritten with aterminaluorU,and thesuffixulorULindicates
unsigned long . 
Floating-point constants contain adecimal point (123.4 )oranexponent (1e-2 )orboth; their
type isdouble ,unless suffixed. ThesuffixesforFindicate afloat constant; lorLindicate a
long double . 
Thevalue ofaninteger canbespecified inoctal orhexadecimal instead ofdecimal. Aleading0
(zero) onaninteger constant means octal; aleading0xor0Xmeans hexadecimal. Forexample,
decimal 31canbewritten as037 inoctal and0x1f or0x1F inhex. Octal andhexadecimal
constants may alsobefollowed byLtomake themlong andUtomake themunsigned :0XFUL
is an unsigned long  constant with value 15 decimal. 
Acharacter constant isaninteger, written asonecharacter within single quotes, such as
'x'.The value ofacharacter constant isthenumeric value ofthecharacter inthemachine's
character set.Forexample, intheASCII character setthecharacter constant'0'hasthevalue
48,which isunrelated tothenumeric value 0.Ifwewrite'0'instead ofanumeric value like
48that depends onthecharacter set,theprogram isindependent oftheparticular value and
easier toread. Character constants participate innumeric operations justasanyother integers,
although they are most often used in comparisons with other characters. 
Certain characters canberepresented incharacter andstring constants byescape sequences
like \n (newline); these sequences look like two characters, but represent only one. In addition,
an arbitrary byte-sized bit pattern can be specified by 
   '\ooo'37
where ooo is one to three octal digits (0...7) or by 
   '\xhh'
where hh is one or more hexadecimal digits ( 0...9, a...f, A...F ). So we might write 
   #define VTAB '\013'   /* ASCII vertical tab */
   #define BELL '\007'   /* ASCII bell character */
or, in hexadecimal, 
   #define VTAB '\xb'   /* ASCII vertical tab */
   #define BELL '\x7'   /* ASCII bell character */
The complete set of escape sequences is 
 \a  alert (bell) character   \\   backslash
 \b  backspace  \?  question mark
 \f  formfeed   \'  single quote
 \n  newline  \"  double quote
 \r  carriage return  \ooo  octal number
 \t  horizontal tab  \xhh  hexadecimal number  
 \v  vertical tab
Thecharacter constant'\0' represents thecharacter with value zero, thenullcharacter. '\0'
isoften written instead of0toemphasize thecharacter nature ofsome expression, butthe
numeric value is just 0. 
Aconstant expression isanexpression thatinvolves only constants. Such expressions may be
evaluated atduring compilation rather than run-time, andaccordingly may beused inanyplace
that a constant can occur, as in 
   #define MAXLINE 1000
   char line[MAXLINE+1];
or 
   #define LEAP 1 /* in leap years */
   int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
Astring constant ,orstring literal ,isasequence ofzero ormore characters surrounded by
double quotes, as in 
   "I am a string"
or 
   "" /* the empty string */
Thequotes arenotpart ofthestring, butserve only todelimit it.Thesame escape sequences
used incharacter constants apply instrings;\"represents thedouble-quote character. String
constants can be concatenated at compile time: 
   "hello, " "world"
is equivalent to 
   "hello, world"
This is useful for splitting up long strings across several source lines. 
Technically, astring constant isanarray ofcharacters. The internal representation ofastring
hasanullcharacter '\0' attheend, sothephysical storage required isonemore than the
number ofcharacters written between thequotes. This representation means that there isno
limit tohow long astring canbe,butprograms must scan astring completely todetermine its
length. The standard library functionstrlen(s) returns thelength ofitscharacter string
argument s, excluding the terminal '\0' . Here is our version: 38
   /* strlen:  return length of s */
   int strlen(char s[])
   {
       int i;
       while (s[i] != '\0')
           ++i;
       return i;
   }
strlen  and other string functions are declared in the standard header <string.h> . 
Becareful todistinguish between acharacter constant and astring that contains asingle
character: 'x'isnotthesame as"x".The former isaninteger, used toproduce thenumeric
value oftheletter xinthemachine's character set.The latter isanarray ofcharacters that
contains one character (the letter x) and a '\0' . 
There isoneother kind ofconstant, theenumeration constant .Anenumeration isalistof
constant integer values, as in 
   enum boolean { NO, YES };
The first name inanenum hasvalue 0,thenext 1,and soon,unless explicit values are
specified. Ifnotallvalues arespecified, unspecified values continue theprogression from the
last specified value, as the second of these examples: 
   enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',
                  NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };
   enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
                 JUL, AUG, SEP, OCT, NOV, DEC };
                       /* FEB = 2, MAR = 3, etc. */
Names indifferent enumerations must bedistinct. Values need notbedistinct inthesame
enumeration. 
Enumerations provide aconvenient way toassociate constant values with names, analternative
to#define with theadvantage thatthevalues canbegenerated foryou. Although variables of
enum types may bedeclared, compilers need notcheck thatwhat youstore insuch avariable is
avalid value fortheenumeration. Nevertheless, enumeration variables offer thechance of
checking andsoareoften better than#define s.Inaddition, adebugger may beable toprint
values of enumeration variables in their symbolic form. 
2.4 Declarations
Allvariables must bedeclared before use,although certain declarations canbemade implicitly
bycontent. Adeclaration specifies atype, andcontains alistofoneormore variables ofthat
type, as in 
   int  lower, upper, step;
   char c, line[1000];
Variables canbedistributed among declarations inanyfashion; thelists above could well be
written as 
   int  lower;
   int  upper;
   int  step;
   char c;
   char line[1000];
Thelatter form takes more space, butisconvenient foradding acomment toeach declaration
for subsequent modifications. 39
Avariable may also beinitialized initsdeclaration. Ifthename isfollowed byanequals sign
and an expression, the expression serves as an initializer, as in 
   char  esc = '\\';
   int   i = 0;
   int   limit = MAXLINE+1;
   float eps = 1.0e-5;
Ifthevariable inquestion isnotautomatic, theinitialization isdone once only, conceptionally
before theprogram starts executing, and theinitializer must beaconstant expression. An
explicitly initialized automatic variable isinitialized each time thefunction orblock itisinis
entered; theinitializer may beanyexpression. External andstatic variables areinitialized to
zero bydefault. Automatic variables forwhich isnoexplicit initializer have undefined (i.e.,
garbage) values. 
The qualifierconst canbeapplied tothedeclaration ofanyvariable tospecify thatitsvalue
will not be changed. For an array, the const  qualifier says that the elements will not be altered.
   const double e = 2.71828182845905;
   const char msg[] = "warning: ";
Theconst declaration canalso beused with array arguments, toindicate that thefunction
does not change that array: 
   int strlen(const char[]);
The result is implementation-defined if an attempt is made to change a const . 
2.5 Arithmetic Operators
The binary arithmetic operators are+,-,*,/,andthemodulus operator%.Integer division
truncates any fractional part. The expression 
   x % y
produces theremainder whenxisdivided byy,andthus iszero whenydividesxexactly. For
example, ayear isaleap year ifitisdivisible by4butnotby100, except thatyears divisible by
400 are leap years. Therefore 
   if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
       printf("%d is a leap year\n", year);
   else
       printf("%d is not a leap year\n", year);
The%operator cannot beapplied toafloat ordouble .Thedirection oftruncation for/and
thesign oftheresult for%aremachine-dependent fornegative operands, asistheaction taken
on overflow or underflow. 
Thebinary+and-operators have thesame precedence, which islower than theprecedence of
*,/and%,which isinturn lower than unary+and-.Arithmetic operators associate leftto
right. 
Table 2.1 at the end of this chapter summarizes precedence and associativity for all operators. 
2.6 Relational and Logical Operators
The relational operators are 
   >   >=   <   <=
They all have the same precedence. Just below them in precedence are the equality operators: 
   ==   !=
Relational operators have lower precedence than arithmetic operators, soanexpression likei
< lim-1  is taken as i < (lim-1) , as would be expected. 40
More interesting arethelogical operators &&and||.Expressions connected by&&or||are
evaluated lefttoright, andevaluation stops assoon asthetruth orfalsehood oftheresult is
known. Most Cprograms relyonthese properties. Forexample, here isaloop from theinput
function getline  that we wrote in Chapter 1 : 
   for (i=0; i < lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
       s[i] = c;
Before reading anew character itisnecessary tocheck that there isroom tostore itinthe
arrays,sothetesti<lim-1 must bemade first. Moreover, ifthistestfails, wemust notgo
on and read another character. 
Similarly, itwould beunfortunate ifcwere tested againstEOF beforegetchar iscalled;
therefore the call and assignment must occur before the character in c is tested. 
Theprecedence of&&ishigher than thatof||,andboth arelower than relational andequality
operators, so expressions like 
   i < lim-1 && (c=getchar()) != '\n' && c != EOF
need noextra parentheses. But since theprecedence of!=ishigher than assignment,
parentheses are needed in 
   (c=getchar()) != '\n'
to achieve the desired result of assignment to c and then comparison with '\n' . 
Bydefinition, thenumeric value ofarelational orlogical expression is1iftherelation istrue,
and 0 if the relation is false. 
Theunary negation operator!converts anon-zero operand into0,andazero operand in1.A
common use of ! is in constructions like 
   if (!valid)
rather than 
   if (valid == 0)
It'shard togeneralize about which form isbetter. Constructions like!valid read nicely (``if
not valid''), but more complicated ones can be hard to understand. 
Exercise 2-2.  Write a loop equivalent to the for loop above without using && or ||. 
2.7 Type Conversions
When anoperator hasoperands ofdifferent types, they areconverted toacommon type
according toasmall number ofrules. Ingeneral, theonly automatic conversions arethose that
convert a``narrower'' operand into a``wider'' one without losing information, such as
converting aninteger into floating point inanexpression likef+i.Expressions that don't
make sense, likeusing afloat asasubscript, aredisallowed. Expressions that might lose
information, likeassigning alonger integer type toashorter, orafloating-point type toan
integer, may draw a warning, but they are not illegal. 
Achar isjustasmall integer, sochar smay befreely used inarithmetic expressions. This
permits considerable flexibility incertain kinds ofcharacter transformations. One isexemplified
bythisnaive implementation ofthefunctionatoi ,which converts astring ofdigits into its
numeric equivalent. 
   /* atoi:  convert s to integer */
   int atoi(char s[])
   {
       int i, n;41
       n = 0;
       for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
           n = 10 * n + (s[i] - '0');
       return n;
   }
As we discussed in Chapter 1 , the expression 
    s[i] - '0'
gives thenumeric value ofthecharacter stored ins[i] ,because thevalues of'0','1',etc.,
form a contiguous increasing sequence. 
Another example ofchar toint conversion isthefunctionlower ,which maps asingle
character tolower case fortheASCII character set.Ifthecharacter isnotanupper case letter,
lower  returns it unchanged. 
   /* lower:  convert c to lower case; ASCII only */
   int lower(int c)
   {
       if (c >= 'A' && c <= 'Z')
           return c + 'a' - 'A';
       else
           return c;
   }
This works forASCII because corresponding upper case andlower case letters areafixed
distance apart asnumeric values andeach alphabet iscontiguous --there isnothing butletters
betweenAandZ.This latter observation isnottrueoftheEBCDIC character set,however, so
this code would convert more than just letters in EBCDIC. 
The standard header<ctype.h> ,described inAppendix B ,defines afamily offunctions that
provide tests andconversions thatareindependent ofcharacter set.Forexample, thefunction
tolower  is a portable replacement for the function lower  shown above. Similarly, the test 
   c >= '0' && c <= '9'
can be replaced by 
   isdigit(c)
We will use the <ctype.h>  functions from now on. 
There isonesubtle point about theconversion ofcharacters tointegers. Thelanguage does not
specify whether variables oftypechar aresigned orunsigned quantities. When achar is
converted toanint,canitever produce anegative integer? Theanswer varies from machine
tomachine, reflecting differences inarchitecture. Onsome machines achar whose leftmost bit
is1willbeconverted toanegative integer (``sign extension''). Onothers, achar ispromoted
to an int by adding zeros at the left end, and thus is always positive. 
The definition ofCguarantees thatanycharacter inthemachine's standard printing character
setwillnever benegative, sothese characters willalways bepositive quantities inexpressions.
But arbitrary bitpatterns stored incharacter variables may appear tobenegative onsome
machines, yetpositive onothers. Forportability, specifysigned orunsigned ifnon-character
data is to be stored in char  variables. 
Relational expressions likei>jandlogical expressions connected by&&and||aredefined
to have value 1 if true, and 0 if false. Thus the assignment 
   d = c >= '0' && c <= '9'
setsdto1ifcisadigit, and0ifnot. However, functions likeisdigit may return anynon-
zero value fortrue. Inthetestpart ofif,while ,for,etc., ``true'' justmeans ``non-zero'', so
this makes no difference. 42
Implicit arithmetic conversions work much asexpected. Ingeneral, ifanoperator like+or*
that takes two operands (a binary operator) has operands of different types, the ``lower'' type is
promoted tothe``higher'' type before theoperation proceeds. Theresult isoftheinteger type.
Section 6of   Appendix A   states theconversion rules precisely. Ifthere areno   unsigned  
operands, however, the following informal set of rules will suffice: 
•If either operand is long double , convert the other to long double . 
•Otherwise, if either operand is double , convert the other to double . 
•Otherwise, if either operand is float , convert the other to float . 
•Otherwise, convert char  and short  to int. 
•Then, if either operand is long , convert the other to long . 
Notice thatfloat sinanexpression arenotautomatically converted todouble ;thisisa
change from theoriginal definition. Ingeneral, mathematical functions likethose in<math.h>
willusedouble precision. Themain reason forusingfloat istosave storage inlarge arrays,
or,less often, tosave time onmachines where double-precision arithmetic isparticularly
expensive. 
Conversion rules aremore complicated whenunsigned operands areinvolved. Theproblem is
that comparisons between signed andunsigned values aremachine-dependent, because they
depend onthesizes ofthevarious integer types. Forexample, suppose thatintis16bitsand
long is32bits. Then-1L<1U,because1U,which isanunsigned int,ispromoted toa
signedlong .But-1L>1ULbecause-1Lispromoted tounsigned long andthus appears
to be a large positive number. 
Conversions take place across assignments; thevalue oftheright sideisconverted tothetype
of the left, which is the type of the result. 
A character is converted to an integer, either by sign extension or not, as described above. 
Longer integers areconverted toshorter ones ortochar sbydropping theexcess high-order
bits. Thus in 
   int  i;
   char c;
   i = c;
   c = i;
thevalue ofcisunchanged. This istrue whether ornotsign extension isinvolved. Reversing
the order of assignments might lose information, however. 
If x is float  and i is int, then x = i  and i = x  both cause conversions; float  to int causes
truncation ofanyfractional part. When adouble isconverted tofloat ,whether thevalue is
rounded or truncated is implementation dependent. 
Since anargument ofafunction callisanexpression, type conversion also takes place when
arguments arepassed tofunctions. Intheabsence ofafunction prototype, char andshort
become int,andfloat becomesdouble .This iswhy wehave declared function arguments to
be int and double  even when the function is called with char  and float . 
Finally, explicit type conversions canbeforced (``coerced'') inanyexpression, with aunary
operator called a cast . In the construction 
  (type name ) expression  43
theexpression isconverted tothenamed type bytheconversion rules above. The precise
meaning of a cast is as if the expression  were assigned to a variable of the specified type, which
isthen used inplace ofthewhole construction. Forexample, thelibrary routinesqrt expects a
double argument, andwillproduce nonsense ifinadvertently handled something else. (sqrt is
declared in <math.h> .) So if n is an integer, we can use 
   sqrt((double) n)
toconvert thevalue ofntodouble before passing ittosqrt .Note thatthecastproduces the
value ofnintheproper type;nitself isnotaltered. The cast operator hasthesame high
precedence as other unary operators, as summarized in the table at the end of this chapter. 
Ifarguments aredeclared byafunction prototype, asthenormally should be,thedeclaration
causes automatic coercion of any arguments when the function is called. Thus, given a function
prototype for sqrt : 
   double sqrt(double)
the call 
   root2 = sqrt(2)
coerces the integer 2 into the double  value 2.0 without any need for a cast. 
Thestandard library includes aportable implementation ofapseudo-random number generator
and a function for initializing the seed; the former illustrates a cast: 
   unsigned long int next = 1;
   /* rand:  return pseudo-random integer on 0..32767 */
   int rand(void)
   {
       next = next * 1103515245 + 12345;
       return (unsigned int)(next/65536) % 32768;
   }
   /* srand:  set seed for rand() */
   void srand(unsigned int seed)
   {
       next = seed;
   }
Exercise 2-3. Write afunction htoi(s) ,which converts astring ofhexadecimal digits
(including anoptional0xor0X)into itsequivalent integer value. The allowable digits are0
through 9, a through f, and A through F. 
2.8 Increment and Decrement Operators
Cprovides twounusual operators forincrementing anddecrementing variables. Theincrement
operator ++adds 1toitsoperand, while thedecrement operator --subtracts 1.Wehave
frequently used ++ to increment variables, as in 
   if (c == '\n')
       ++nl;
The unusual aspect isthat++and--may beused either asprefix operators (before the
variable, asin++n),orpostfix operators (after thevariable:n++).Inboth cases, theeffect isto
increment n.But theexpression ++n increments nbefore itsvalue isused, whilen++
increments nafter itsvalue hasbeen used. This means that inacontext where thevalue is
being used, not just the effect, ++n and n++ are different. If n is 5, then 
   x = n++;
sets x to 5, but 
   x = ++n;44
setsxto6.Inboth cases,nbecomes 6.The increment anddecrement operators canonly be
applied to variables; an expression like (i+j)++  is illegal. 
In a context where no value is wanted, just the incrementing effect, as in 
   if (c == '\n')
       nl++;
prefix andpostfix arethesame. Butthere aresituations where oneortheother isspecifically
called for.Forinstance, consider thefunctionsqueeze(s,c) ,which removes alloccurrences
of the character c from the string s. 
   /* squeeze:  delete all c from s */
   void squeeze(char s[], int c)
   {
      int i, j;
      for (i = j = 0; s[i] != '\0'; i++)
          if (s[i] != c)
              s[j++] = s[i];
      s[j] = '\0';
   }
Each time anon-coccurs, itiscopied into thecurrentjposition, and only then isj
incremented to be ready for the next character. This is exactly equivalent to 
   if (s[i] != c) {
       s[j] = s[i];
       j++;
   }
Another example ofasimilar construction comes from thegetline function thatwewrote in
Chapter 1 , where we can replace 
   if (c == '\n') {
       s[i] = c;
       ++i;
   }
by the more compact 
   if (c == '\n')
      s[i++] = c;
Asathird example, consider thestandard functionstrcat(s,t) ,which concatenates the
stringttotheendofstrings.strcat assumes that there isenough space instohold the
combination. Aswehave written it,strcat returns novalue; thestandard library version
returns a pointer to the resulting string. 
   /* strcat:  concatenate t to end of s; s must be big enough */
   void strcat(char s[], char t[])
   {
       int i, j;
       i = j = 0;
       while (s[i] != '\0') /* find end of s */
           i++;
       while ((s[i++] = t[j++]) != '\0') /* copy t */
           ;
   }
Aseach member iscopied fromttos,thepostfix++isapplied tobothiandjtomake sure
that they are in position for the next pass through the loop. 
Exercise 2-4. Write analternative version ofsqueeze(s1,s2) that deletes each character in
s1 that matches any character in the string  s2. 45
Exercise 2-5. Write thefunctionany(s1,s2) ,which returns thefirst location inastrings1
where anycharacter from thestrings2occurs, or-1ifs1contains nocharacters froms2.
(The standard library function strpbrk does thesame jobbutreturns apointer tothe
location.) 
2.9 Bitwise Operators
Cprovides sixoperators forbitmanipulation; these may only beapplied tointegral operands,
that is, char , short , int, and long , whether signed or unsigned. 
& bitwise AND
| bitwise inclusive OR
^ bitwise exclusive OR
<<  left shift
>> right shift
~ one's complement (unary)
The bitwise AND operator & is often used to mask off some set of bits, for example 
   n = n & 0177;
sets to zero all but the low-order 7 bits of n. 
The bitwise OR operator | is used to turn bits on: 
   x = x | SET_ON;
sets to one in x the bits that are set to one in SET_ON . 
The bitwise exclusive ORoperator^setsaoneineach bitposition where itsoperands have
different bits, and zero where they are the same. 
One must distinguish the bitwise operators & and | from the logical operators && and ||, which
imply left-to-right evaluation ofatruth value. Forexample, ifxis1andyis2,thenx&yis
zero while x && y  is one. 
Theshift operators <<and>>perform leftandright shifts oftheir leftoperand bythenumber
ofbitpositions given bytheright operand, which must benon-negative. Thusx<<2shifts
thevalue ofxbytwo positions, filling vacated bits with zero; this isequivalent to
multiplication by4.Right shifting anunsigned quantity always fitsthevacated bitswith zero.
Right shifting asigned quantity willfillwith bitsigns (``arithmetic shift'') onsome machines
and with 0-bits (``logical shift'') on others. 
Theunary operator~yields theone's complement ofaninteger; thatis,itconverts each 1-bit
into a 0-bit and vice versa. For example 
   x = x & ~077
setsthelastsixbitsofxtozero. Note thatx&~077 isindependent ofword length, andis
thus preferable to,forexample, x&0177700 ,which assumes thatxisa16-bit quantity. The
portable form involves noextra cost, since~077 isaconstant expression thatcanbeevaluated
at compile time. 
Asanillustration ofsome ofthebitoperators, consider thefunctiongetbits(x,p,n) that
returns the(right adjusted) n-bitfield ofxthat begins atpositionp.Weassume that bit
position 0isattheright end and thatnandparesensible positive values. Forexample,
getbits(x,4,3)  returns the three bits in positions 4, 3 and 2, right-adjusted. 
   /* getbits:  get n bits from position p */
   unsigned getbits(unsigned x, int p, int n)
   {46
       return (x >> (p+1-n)) & ~(~0 << n);
   }
Theexpression x>>(p+1-n) moves thedesired field totheright endoftheword.~0isall1-
bits; shifting itleftnpositions with~0<<n places zeros intherightmost nbits; complementing
that with ~ makes a mask with ones in the rightmost n bits. 
Exercise 2-6. Write afunctionsetbits(x,p,n,y) thatreturnsxwith thenbitsthatbegin at
position p set to the rightmost n bits of y, leaving the other bits unchanged. 
Exercise 2-7. Write afunctioninvert(x,p,n) that returnsxwith thenbitsthat begin at
position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. 
Exercise 2-8. Write afunctionrightrot(x,n) thatreturns thevalue oftheintegerxrotated
to the right by n positions. 
2.10 Assignment Operators and Expressions
An expression such as 
   i = i + 2
inwhich thevariable ontheleftsideisrepeated immediately ontheright, canbewritten inthe
compressed form 
   i += 2
The operator += is called an assignment operator . 
Most binary operators (operators like+that have aleft and right operand) have a
corresponding assignment operator op=, where op is one of 
   +   -   *   /   %   <<   >>   &   ^   |
If expr 1 and expr 2 are expressions, then 
   expr1 op= expr 2
is equivalent to 
   expr1 = (expr1) op (expr2)
except that expr 1 is computed only once. Notice the parentheses around expr 2: 
   x *= y + 1
means 
   x = x * (y + 1)
rather than 
   x = x * y + 1
As an example, the function bitcount  counts the number of 1-bits in its integer argument. 
   /* bitcount:  count 1 bits in x */
   int bitcount(unsigned x)
   {
       int b;
       for (b = 0; x != 0; x >>= 1)
           if (x & 01)
               b++;
       return b;
   }
Declaring theargument xtobeanunsigned ensures thatwhen itisright-shifted, vacated bits
will be filled with zeros, not sign bits, regardless of the machine the program is run on. 47
Quite apart from conciseness, assignment operators have theadvantage thatthey correspond
better totheway people think. Wesay``add 2toi''or``increment iby2'',not``takei,add2,
then puttheresult back ini''.Thus theexpression i+=2ispreferable toi=i+2.In
addition, for a complicated expression like 
   yyval[yypv[p3+p4] + yypv[p1]] += 2
theassignment operator makes thecode easier tounderstand, since thereader doesn't have to
check painstakingly thattwo long expressions areindeed thesame, ortowonder why they're
not. And an assignment operator may even help a compiler to produce efficient code. 
Wehave already seen thattheassignment statement hasavalue andcanoccur inexpressions;
the most common example is 
   while ((c = getchar()) != EOF)
       ...
The other assignment operators (+=,-=,etc.) canalso occur inexpressions, although thisis
less frequent. 
Inallsuch expressions, thetype ofanassignment expression isthetype ofitsleftoperand, and
the value is the value after the assignment. 
Exercise 2-9. Inatwo's complement number system,x&=(x-1) deletes therightmost 1-bit
in x. Explain why. Use this observation to write a faster version of bitcount . 
2.11 Conditional Expressions
The statements 
   if (a > b)
       z = a;
   else
       z = b;
compute inzthemaximum ofaandb.The conditional expression ,written with theternary
operator ``?:'',provides analternate way towrite this and similar constructions. Inthe
expression 
   expr1 ? expr2 : expr3
theexpression expr 1isevaluated first. Ifitisnon-zero (true), then theexpression expr 2is
evaluated, andthatisthevalue oftheconditional expression. Otherwise expr 3isevaluated, and
thatisthevalue. Only oneofexpr 2andexpr 3isevaluated. Thus tosetztothemaximum ofa
and b, 
   z = (a > b) ? a : b;    /* z = max(a, b) */
Itshould benoted thattheconditional expression isindeed anexpression, anditcanbeused
wherever anyother expression canbe.Ifexpr 2andexpr 3areofdifferent types, thetype ofthe
result isdetermined bytheconversion rules discussed earlier inthischapter. Forexample, iff
is a float  and n an int, then the expression 
   (n > 0) ? f : n
is of type float  regardless of whether n is positive. 
Parentheses arenotnecessary around thefirstexpression ofaconditional expression, since the
precedence of?:isvery low, justabove assignment. They areadvisable anyway, however,
since they make the condition part of the expression easier to see. 
The conditional expression often leads tosuccinct code. For example, this loop printsn
elements ofanarray, 10perline, with each column separated byoneblank, andwith each line
(including the last) terminated by a newline. 48
   for (i = 0; i < n; i++)
       printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ');
Anewline isprinted after every tenth element, and after then-th.Allother elements are
followed byoneblank. This might look tricky, butit'smore compact than theequivalent if-
else . Another good example is 
   printf("You have %d items%s.\n", n, n==1 ? "" : "s");
Exercise 2-10. Rewrite thefunctionlower ,which converts upper case letters tolower case,
with a conditional expression instead of if-else . 
2.12 Precedence and Order of Evaluation
Table 2.1summarizes therules forprecedence andassociativity ofalloperators, including
those thatwehave notyetdiscussed. Operators onthesame linehave thesame precedence;
rows areinorder ofdecreasing precedence, so,forexample, *,/,and%allhave thesame
precedence, which ishigher than thatofbinary+and-.The ``operator'' ()refers tofunction
call. Theoperators ->and.areused toaccess members ofstructures; they willbecovered in
Chapter 6 ,along withsizeof (size ofanobject). Chapter 5 discusses *(indirection through a
pointer) and & (address of an object), and Chapter 3  discusses the comma operator. 
Operators Associativity
() [] -> .  left to right
! ~ ++ -- + - *  (type) sizeof  right to left
* / %  left to right
+ -  left to right
<<  >>  left to right
< <= > >=  left to right
== !=  left to right
&  left to right
^  left to right
|  left to right
&&  left to right
||  left to right
?:  right to left
= += -= *= /= %= &= ^= |= <<= >>=  right to left
,  left to right
Unary & +, -, and * have higher precedence than the binary forms. 
Table 2.1:  Precedence and Associativity of Operators  
Note that theprecedence ofthebitwise operators &,^,and|falls below==and!=.This
implies that bit-testing expressions like 
   if ((x & MASK) == 0) ...
must be fully parenthesized to give proper results. 
C,likemost languages, does notspecify theorder inwhich theoperands ofanoperator are
evaluated. (The exceptions are &&, ||, ?:, and `,'.) For example, in a statement like 
   x = f() + g();49
fmay beevaluated beforegorvice versa; thus ifeitherforgalters avariable onwhich the
other depends, xcandepend ontheorder ofevaluation. Intermediate results canbestored in
temporary variables to ensure a particular sequence. 
Similarly, theorder inwhich function arguments areevaluated isnotspecified, sothe
statement 
   printf("%d %d\n", ++n, power(2, n));   /* WRONG */
canproduce different results with different compilers, depending onwhethernisincremented
before power  is called. The solution, of course, is to write 
   ++n;
   printf("%d %d\n", n, power(2, n));
Function calls, nested assignment statements, andincrement anddecrement operators cause
``side effects'' -some variable ischanged asaby-product oftheevaluation ofanexpression. In
anyexpression involving side effects, there canbesubtle dependencies ontheorder inwhich
variables taking part intheexpression areupdated. One unhappy situation istypified bythe
statement 
   a[i] = i++;
Thequestion iswhether thesubscript istheoldvalue ofiorthenew. Compilers caninterpret
thisindifferent ways, andgenerate different answers depending ontheir interpretation. The
standard intentionally leaves most such matters unspecified. When side effects (assignment to
variables) take place within anexpression islefttothediscretion ofthecompiler, since thebest
order depends strongly onmachine architecture. (The standard does specify thatallsideeffects
onarguments take effect before afunction iscalled, butthat would nothelp inthecallto
printf  above.) 
The moral isthat writing code that depends onorder ofevaluation isabadprogramming
practice inanylanguage. Naturally, itisnecessary toknow what things toavoid, butifyou
don't know how they are done on various machines, you won't be tempted to take advantage of
a particular implementation. 50
Chapter 3 - Control Flow
The control-flow ofalanguage specify theorder inwhich computations areperformed. We
have already metthemost common control-flow constructions inearlier examples; here we
will complete the set, and be more precise about the ones discussed before. 
3.1 Statements and Blocks
Anexpression such asx=0ori++orprintf(...) becomes astatement when itisfollowed
by a semicolon, as in 
   x = 0;
   i++;
   printf(...);
InC,thesemicolon isastatement terminator, rather than aseparator asitisinlanguages like
Pascal. 
Braces{and}areused togroup declarations and statements together into acompound
statement ,orblock ,sothatthey aresyntactically equivalent toasingle statement. Thebraces
that surround thestatements ofafunction areoneobvious example; braces around multiple
statements after anif,else ,while ,orforareanother. (Variables canbedeclared inside any
block; wewilltalkabout thisinChapter 4 .)There isnosemicolon after theright brace that
ends a block. 
3.2 If-Else
The if-else  statement is used to express decisions. Formally the syntax is 
   if (expression )
       statement 1
   else
       statement 2
where theelse part isoptional. Theexpression isevaluated; ifitistrue (that is,ifexpression
hasanon-zero value), statement 1isexecuted. Ifitisfalse (expression iszero) andifthere isan
else  part, statement 2 is executed instead. 
Since aniftests thenumeric value ofanexpression, certain coding shortcuts arepossible. The
most obvious is writing 
   if (expression )
instead of 
   if (expression  != 0)
Sometimes this is natural and clear; at other times it can be cryptic. 
Because theelse part ofanif-else isoptional,there isanambiguity when anelseifomitted
from anestedifsequence. This isresolved byassociating theelse with theclosest previous
else -less if. For example, in 
   if (n > 0)
       if (a > b)
           z = a;
       else
           z = b;
theelse goes totheinnerif,aswehave shown byindentation. Ifthatisn't what youwant,
braces must be used to force the proper association: 51
   if (n > 0) {
       if (a > b)
            z = a;
   }
   else
       z = b;
The ambiguity is especially pernicious in situations like this: 
   if (n > 0)
       for (i = 0; i < n; i++)
           if (s[i] > 0) {
               printf("...");
               return i;
           }
   else        /* WRONG */
       printf("error -- n is negative\n");
Theindentation shows unequivocally what youwant, butthecompiler doesn't getthemessage,
andassociates theelse with theinnerif.This kind ofbugcanbehard tofind; it'sagood idea
to use braces when there are nested ifs. 
By the way, notice that there is a semicolon after z = a  in 
   if (a > b)
       z = a;
   else
       z = b;
This isbecause grammatically, astatement follows theif,andanexpression statement like``z
= a; '' is always terminated by a semicolon. 
3.3 Else-If
The construction 
   if (expression )
       statement
   else if ( expression )
       statement
   else if ( expression )
       statement
   else if ( expression )
       statement
   else
       statement
occurs sooften thatitisworth abrief separate discussion. This sequence ofifstatements is
themost general way ofwriting amulti-way decision. Theexpressions areevaluated inorder;
ifanexpression istrue, thestatement associated with itisexecuted, andthisterminates the
whole chain. Asalways, thecode foreach statement iseither asingle statement, oragroup of
them in braces. 
The lastelse part handles the``none oftheabove'' ordefault case where none oftheother
conditions issatisfied. Sometimes there isnoexplicit action forthedefault; inthat case the
trailing 
   else
       statement
can be omitted, or it may be used for error checking to catch an ``impossible'' condition. 
Toillustrate athree-way decision, here isabinary search function thatdecides ifaparticular
valuexoccurs inthesorted arrayv.The elements ofvmust beinincreasing order. The
function returns the position (a number between 0 and n-1) if x occurs in v, and -1 if not. 52
Binary search firstcompares theinput valuextothemiddle element ofthearrayv.Ifxisless
than themiddle value, searching focuses onthelower halfofthetable, otherwise ontheupper
half. Ineither case, thenext step istocompare xtothemiddle element oftheselected half.
This process ofdividing therange intwo continues until thevalue isfound ortherange is
empty. 
   /* binsearch:  find x in v[0] <= v[1] <= ... <= v[n-1] */
   int binsearch(int x, int v[], int n)
   {
       int low, high, mid;
       low = 0;
       high = n - 1;
       while (low <= high) {
           mid = (low+high)/2;
           if (x < v[mid])
               high = mid + 1;
           else if (x  > v[mid])
               low = mid + 1;
           else    /* found match */
               return mid;
       }
       return -1;   /* no match */
   }
Thefundamental decision iswhetherxislessthan, greater than, orequal tothemiddle element
v[mid]  at each step; this is a natural for else-if . 
Exercise 3-1. Our binary search makes two tests inside theloop, when onewould suffice (at
theprice ofmore tests outside.) Write aversion with only onetestinside theloop andmeasure
the difference in run-time. 
3.4 Switch
Theswitch statement isamulti-way decision thattests whether anexpression matches oneof
a number of constant  integer values, and branches accordingly. 
   switch ( expression ) {
       case const-expr : statements
       case const-expr : statements
       default: statements
   }
Each case islabeled byoneormore integer-valued constants orconstant expressions. Ifacase
matches theexpression value, execution starts atthat case. Allcase expressions must be
different. The case labeleddefault isexecuted ifnone oftheother cases aresatisfied. A
default isoptional; ifitisn'tthere andifnone ofthecases match, noaction atalltakes place.
Cases and the default clause can occur in any order. 
InChapter 1 wewrote aprogram tocount theoccurrences ofeach digit, white space, andall
other characters, using asequence ofif...elseif...else .Here isthesame program
with a switch : 
   #include <stdio.h>
   main()  /* count digits, white space, others */
   {
       int c, i, nwhite, nother, ndigit[10];
       nwhite = nother = 0;
       for (i = 0; i < 10; i++)
           ndigit[i] = 0;
       while ((c = getchar()) != EOF) {53
           switch (c) {
           case '0': case '1': case '2': case '3': case '4':
           case '5': case '6': case '7': case '8': case '9':
               ndigit[c-'0']++;
               break;
           case ' ':
           case '\n':
           case '\t':
               nwhite++;
               break;
           default:
               nother++;
               break;
           }
       }
       printf("digits =");
       for (i = 0; i < 10; i++)
           printf(" %d", ndigit[i]);
       printf(", white space = %d, other = %d\n",
           nwhite, nother);
       return 0;
   }
Thebreak statement causes animmediate exitfrom theswitch .Because cases serve justas
labels, after thecode foronecase isdone, execution falls through tothenext unless youtake
explicit action toescape.break andreturn arethemost common ways toleave aswitch .A
break statement canalso beused toforce animmediate exitfromwhile ,for,anddoloops,
as will be discussed later in this chapter. 
Falling through cases isamixed blessing. Onthepositive side, itallows several cases tobe
attached toasingle action, aswith thedigits inthisexample. Butitalso implies thatnormally
each case must endwith abreak toprevent falling through tothenext. Falling through from
onecase toanother isnotrobust, being prone todisintegration when theprogram ismodified.
With theexception ofmultiple labels forasingle computation, fall-throughs should beused
sparingly, and commented. 
Asamatter ofgood form, putabreak after thelastcase (thedefault here) even though it's
logically unnecessary. Some daywhen another case gets added attheend, thisbitofdefensive
programming will save you. 
Exercise 3-2. Write afunctionescape(s,t) thatconverts characters likenewline andtabinto
visible escape sequences like\nand\tasitcopies thestringttos.Use aswitch .Write a
function for the other direction as well, converting escape sequences into the real characters. 
3.5 Loops - While and For
We have already encountered the while  and for loops. In 
   while ( expression )
       statement
theexpression isevaluated. Ifitisnon-zero, statement isexecuted and expression isre-
evaluated. This cycle continues until expression becomes zero, atwhich point execution
resumes after statement . 
The for statement 
   for ( expr1; expr2; expr3)
       statement
is equivalent to 
   expr1;
   while ( expr2) {54
       statement
       expr3;
   }
except for the behaviour of continue , which is described in Section 3.7 . 
Grammatically, thethree components ofafor loop areexpressions. Most commonly, expr 1
andexpr 3areassignments orfunction calls andexpr 2isarelational expression. Any ofthe
three parts canbeomitted, although thesemicolons must remain. Ifexpr 1orexpr 3isomitted, it
issimply dropped from theexpansion. Ifthetest, expr 2,isnotpresent, itistaken as
permanently true, so 
   for (;;) {
       ...
   }
is an ``infinite'' loop, presumably to be broken by other means, such as a break  or return . 
Whether to use while  or for is largely a matter of personal preference. For example, in 
   while ((c = getchar()) == ' ' || c == '\n' || c = '\t')
       ;   /* skip white space characters */
there is no initialization or re-initialization, so the while  is most natural. 
Theforispreferable when there isasimple initialization andincrement since itkeeps theloop
control statements close together and visible at the top of the loop. This is most obvious in 
   for (i = 0; i < n; i++)
       ...
which istheCidiom forprocessing thefirstnelements ofanarray, theanalog oftheFortran
DOloop orthePascalfor.The analogy isnotperfect, however, since theindex variablei
retains itsvalue when theloop terminates foranyreason. Because thecomponents ofthefor
arearbitrary expressions, forloops arenotrestricted toarithmetic progressions. Nonetheless,
itisbadstyle toforce unrelated computations into theinitialization andincrement ofafor,
which are better reserved for loop control operations. 
Asalarger example, here isanother version ofatoi forconverting astring toitsnumeric
equivalent. This oneisslightly more general than theoneinChapter 2 ;itcopes with optional
leading white space andanoptional+or-sign. (Chapter 4 showsatof ,which does thesame
conversion for floating-point numbers.) 
The structure of the program reflects the form of the input: 
  skip white space, if any
  get sign, if any
  get integer part and convert it 
Each step does itspart, andleaves things inaclean state forthenext. The whole process
terminates on the first character that could not be part of a number. 
   #include <ctype.h>
   /* atoi:  convert s to integer; version 2 */
   int atoi(char s[])
   {
       int i, n, sign;
       for (i = 0; isspace(s[i]); i++)  /* skip white space */
           ;
       sign = (s[i] == '-') ? -1 : 1;
       if (s[i] == '+' || s[i] == '-')  /* skip sign */
           i++;55
       for (n = 0; isdigit(s[i]); i++)
           n = 10 * n + (s[i] - '0');
       return sign * n;
   }
The standard library provides amore elaborate functionstrtol forconversion ofstrings to
long integers; see Section 5 of Appendix B . 
The advantages ofkeeping loop control centralized areeven more obvious when there are
several nested loops. Thefollowing function isaShell sortforsorting anarray ofintegers. The
basic idea ofthissorting algorithm, which wasinvented in1959 byD.L.Shell, isthatinearly
stages, far-apart elements arecompared, rather than adjacent ones asinsimpler interchange
sorts. This tends toeliminate large amounts ofdisorder quickly, solater stages have lesswork
todo.Theinterval between compared elements isgradually decreased toone, atwhich point
the sort effectively becomes an adjacent interchange method. 
   /* shellsort:  sort v[0]...v[n-1] into increasing order */
   void shellsort(int v[], int n)
   {
       int gap, i, j, temp;
       for (gap = n/2; gap > 0; gap /= 2)
           for (i = gap; i < n; i++)
               for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {
                   temp = v[j];
                   v[j] = v[j+gap];
                   v[j+gap] = temp;
               }
   }
There arethree nested loops. The outermost controls thegapbetween compared elements,
shrinking itfromn/2byafactor oftwoeach pass until itbecomes zero. Themiddle loop steps
along theelements. The innermost loop compares each pair ofelements that isseparated by
gapandreverses anythatareoutoforder. Sincegapiseventually reduced toone, allelements
areeventually ordered correctly. Notice how thegenerality oftheformakes theouter loop fit
in the same form as the others, even though it is not an arithmetic progression. 
One final Coperator isthecomma ``,'',which most often finds useintheforstatement. A
pairofexpressions separated byacomma isevaluated lefttoright, andthetype andvalue of
theresult arethetype andvalue oftheright operand. Thus inaforstatement, itispossible to
place multiple expressions inthevarious parts, forexample toprocess twoindices inparallel.
This is illustrated in the function reverse(s) , which reverses the string s in place. 
   #include <string.h>
   /* reverse:  reverse string s in place */
   void reverse(char s[])
   {
       int c, i, j;
       for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
           c = s[i];
           s[i] = s[j];
           s[j] = c;
       }
   }
The commas thatseparate function arguments, variables indeclarations, etc., arenotcomma
operators, and do not guarantee left to right evaluation. 
Comma operators should beused sparingly. Themost suitable uses areforconstructs strongly
related toeach other, asinthefor loop inreverse ,and inmacros where amultistep
computation hastobeasingle expression. Acomma expression might also beappropriate for56
theexchange ofelements inreverse ,where theexchange can bethought ofasingle
operation: 
    for (i = 0, j = strlen(s)-1; i < j; i++, j--)
           c = s[i], s[i] = s[j], s[j] = c;
Exercise 3-3. Write afunctionexpand(s1,s2) that expands shorthand notations likea-zin
thestrings1intotheequivalent complete listabc...xyz ins2.Allow forletters ofeither case
anddigits, andbeprepared tohandle cases likea-b-c anda-z0-9 and-a-z .Arrange thata
leading or trailing - is taken literally. 
3.6 Loops - Do-While
Aswediscussed inChapter 1 ,thewhile andforloops testthetermination condition atthe
top.Bycontrast, thethird loop inC,thedo-while ,tests atthebottom after making each pass
through the loop body; the body is always executed at least once. 
The syntax of the do is 
   do
       statement
   while ( expression );
The statement isexecuted, then expression isevaluated. Ifitistrue, statement isevaluated
again, andsoon.When theexpression becomes false, theloop terminates. Except forthesense
of the test, do-while  is equivalent to the Pascal repeat-until  statement. 
Experience shows thatdo-while ismuch lessused thanwhile andfor.Nonetheless, from
time totime itisvaluable, asinthefollowing functionitoa ,which converts anumber toa
character string (the inverse ofatoi ).The jobisslightly more complicated than might be
thought atfirst, because theeasy methods ofgenerating thedigits generate them inthewrong
order. We have chosen to generate the string backwards, then reverse it. 
   /* itoa:  convert n to characters in s */
   void itoa(int n, char s[])
   {
       int i, sign;
       if ((sign = n) < 0)  /* record sign */
           n = -n;          /* make n positive */
       i = 0;
       do {      /* generate digits in reverse order */
           s[i++] = n % 10 + '0';  /* get next digit */
       } while ((n /= 10) > 0);    /* delete it */
       if (sign < 0)
           s[i++] = '-';
       s[i] = '\0';
       reverse(s);
   }
Thedo-while isnecessary, oratleast convenient, since atleast one character must be
installed inthearrays,even ifniszero. Wealso used braces around thesingle statement that
makes upthebody ofthedo-while ,even though they areunnecessary, sothehasty reader
will not mistake the while  part for the beginning  of a while  loop. 
Exercise 3-4. Inatwo's complement number representation, ourversion ofitoa does not
handle thelargest negative number, thatis,thevalue ofnequal to-(2wordsize-1).Explain why not.
Modify it to print that value correctly, regardless of the machine on which it runs. 
Exercise 3-5. Write thefunctionitob(n,s,b) that converts theintegerninto abaseb
character representation inthe strings.Inparticular, itob(n,s,16) formatssasa
hexadecimal integer in s. 57
Exercise 3-6. Write aversion ofitoa thataccepts three arguments instead oftwo. Thethird
argument isaminimum field width; theconverted number must bepadded with blanks onthe
left if necessary to make it wide enough. 
3.7 Break and Continue
Itissometimes convenient tobeable toexitfrom aloop other than bytesting atthetopor
bottom. Thebreak statement provides anearly exitfromfor,while ,anddo,justasfrom
switch . A break  causes the innermost enclosing loop or switch  to be exited immediately. 
The following function, trim ,removes trailing blanks, tabs andnewlines from theendofa
string, using abreak toexitfrom aloop when therightmost non-blank, non-tab, non-newline
is found. 
   /* trim:  remove trailing blanks, tabs, newlines */
   int trim(char s[])
   {
       int n;
       for (n = strlen(s)-1; n >= 0; n--)
           if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
               break;
       s[n+1] = '\0';
       return n;
   }
strlen returns thelength ofthestring. Theforloop starts attheendandscans backwards
looking forthefirst character thatisnotablank ortabornewline. The loop isbroken when
oneisfound, orwhennbecomes negative (that is,when theentire string hasbeen scanned).
You should verify thatthisiscorrect behavior even when thestring isempty orcontains only
white space characters. 
Thecontinue statement isrelated tobreak ,butlessoften used; itcauses thenext iteration of
theenclosing for,while ,ordoloop tobegin. Inthewhile anddo,thismeans thatthetest
part isexecuted immediately; inthefor,control passes totheincrement step. Thecontinue
statement applies only toloops, nottoswitch .Acontinue inside aswitch inside aloop
causes the next loop iteration. 
Asanexample, thisfragment processes only thenon-negative elements inthearraya;negative
values are skipped. 
   for (i = 0; i < n; i++)
       if (a[i] < 0)   /* skip negative elements */
           continue;
       ... /* do positive elements */
The continue  statement is often used when the part of the loop that follows is complicated, so
that reversing a test and indenting another level would nest the program too deeply. 
3.8 Goto and labels
Cprovides theinfinitely-abusable goto statement, andlabels tobranch to.Formally, thegoto
statement isnever necessary, andinpractice itisalmost always easy towrite code without it.
We have not used goto  in this book. 
Nevertheless, there areafewsituations wheregoto smay findaplace. Themost common isto
abandon processing insome deeply nested structure, such asbreaking outoftwo ormore
loops atonce. Thebreak statement cannot beused directly since itonly exits from the
innermost loop. Thus: 
       for ( ... )58
           for ( ... ) {
               ...
               if (disaster)
                   goto error;
           }
       ...
   error:
       /* clean up the mess */
This organization ishandy iftheerror-handling code isnon-trivial, andiferrors canoccur in
several places. 
Alabel hasthesame form asavariable name, andisfollowed byacolon. Itcanbeattached to
any statement in the same function as the goto . The scope of a label is the entire function. 
Asanother example, consider theproblem ofdetermining whether twoarraysaandbhave an
element in common. One possibility is 
       for (i = 0; i < n; i++)
           for (j = 0; j < m; j++)
               if (a[i] == b[j])
                   goto found;
       /* didn't find any common element */
       ...
   found:
       /* got one: a[i] == b[j] */
       ...
Code involving agoto canalways bewritten without one, though perhaps attheprice ofsome
repeated tests or an extra variable. For example, the array search becomes 
   found = 0;
   for (i = 0; i < n && !found; i++)
       for (j = 0; j < m && !found; j++)
           if (a[i] == b[j])
               found = 1;
   if (found)
       /* got one: a[i-1] == b[j-1] */
       ...
   else
       /* didn't find any common element */
       ...
With afewexceptions likethose cited here, code that relies ongoto statements isgenerally
harder tounderstand andtomaintain than code withoutgoto s.Although wearenotdogmatic
about the matter, it does seem that goto  statements should be used rarely, if at all. 59
Chapter 4 - Functions and Program
Structure
Functions break large computing tasks into smaller ones, andenable people tobuild onwhat
others have done instead ofstarting over from scratch. Appropriate functions hide details of
operation from parts oftheprogram that don't need toknow about them, thus clarifying the
whole, and easing the pain of making changes. 
Chasbeen designed tomake functions efficient andeasy touse; Cprograms generally consist
ofmany small functions rather than afewbigones. Aprogram may reside inoneormore
source files. Source files may becompiled separately and loaded together, along with
previously compiled functions from libraries. Wewillnotgointo thatprocess here, however,
since the details vary from system to system. 
Function declaration anddefinition isthearea where theANSI standard hasmade themost
changes toC.AswesawfirstinChapter 1 ,itisnow possible todeclare thetype ofarguments
when afunction isdeclared. The syntax offunction declaration also changes, sothat
declarations anddefinitions match. This makes itpossible foracompiler todetect many more
errors than itcould before. Furthermore, when arguments areproperly declared, appropriate
type coercions are performed automatically. 
The standard clarifies therules onthescope ofnames; inparticular, itrequires that there be
only onedefinition ofeach external object. Initialization ismore general: automatic arrays and
structures may now be initialized. 
The Cpreprocessor hasalso been enhanced. New preprocessor facilities include amore
complete setofconditional compilation directives, away tocreate quoted strings from macro
arguments, and better control over the macro expansion process. 
4.1 Basics of Functions
Tobegin with, letusdesign andwrite aprogram toprint each lineofitsinput thatcontains a
particular ``pattern'' orstring ofcharacters. (This isaspecial case oftheUNIX programgrep .)
For example, searching for the pattern of letters `` ould '' in the set of lines 
   Ah Love! could you and I with Fate conspire
   To grasp this sorry Scheme of Things entire,
   Would not we shatter it to bits -- and then
   Re-mould it nearer to the Heart's Desire!
will produce the output 
   Ah Love! could you and I with Fate conspire
   Would not we shatter it to bits -- and then
   Re-mould it nearer to the Heart's Desire!
The job falls neatly into three pieces: 
while (there's another line )
    if ( the line contains the pattern )
        print it
Although it'scertainly possible toputthecode forallofthisinmain ,abetter way istousethe
structure toadvantage bymaking each part aseparate function. Three small pieces arebetter
todeal with than onebigone, because irrelevant details canbeburied inthefunctions, andthe
chance ofunwanted interactions isminimized. And thepieces may even beuseful inother
programs. 60
``While there's another line'' is getline , a function that we wrote in Chapter 1 , and ``print it'' is
printf ,which someone hasalready provided forus.This means weneed only write aroutine
to decide whether the line contains an occurrence of the pattern. 
Wecansolve thatproblem bywriting afunctionstrindex(s,t) thatreturns theposition or
index inthestringswhere thestringtbegins, or-1ifsdoes notcontaint.Because Carrays
begin atposition zero, indexes willbezero orpositive, andsoanegative value like-1is
convenient forsignaling failure. When welater need more sophisticated pattern matching, we
only have toreplacestrindex ;therestofthecode canremain thesame. (The standard library
provides afunctionstrstr thatissimilar tostrindex ,except thatitreturns apointer instead
of an index.) 
Given thismuch design, filling inthedetails oftheprogram isstraightforward. Here isthe
whole thing, soyoucanseehow thepieces fittogether. Fornow, thepattern tobesearched
forisaliteral string, which isnotthemost general ofmechanisms. Wewillreturn shortly toa
discussion ofhow toinitialize character arrays, andinChapter 5 willshow how tomake the
pattern aparameter that issetwhen theprogram isrun. There isalso aslightly different
version of getline ; you might find it instructive to compare it to the one in Chapter 1 . 
   #include <stdio.h>
   #define MAXLINE 1000 /* maximum input line length */
   int getline(char line[], int max)
   int strindex(char source[], char searchfor[]);
   char pattern[] = "ould";   /* pattern to search for */
   /* find all lines matching pattern */
   main()
   {
       char line[MAXLINE];
       int found = 0;
       while (getline(line, MAXLINE) > 0)
           if (strindex(line, pattern) >= 0) {
               printf("%s", line);
               found++;
           }
       return found;
   }
   /* getline:  get line into s, return length */
   int getline(char s[], int lim)
   {
       int c, i;
       i = 0;
       while (--lim > 0 && (c=getchar()) != EOF && c != '\n')
           s[i++] = c;
       if (c == '\n')
           s[i++] = c;
       s[i] = '\0';
       return i;
   }
   /* strindex:  return index of t in s, -1 if none */
   int strindex(char s[], char t[])
   {
       int i, j, k;
       for (i = 0; s[i] != '\0'; i++) {
           for (j=i, k=0; t[k]!='\0' && s[j]==t[k]; j++, k++)61
               ;
           if (k > 0 && t[k] == '\0')
               return i;
       }
       return -1;
   }
Each function definition has the form 
return-type function-name (argument declarations )
{
    declarations and statements
}
Various parts may be absent; a minimal function is 
   dummy() {}
which does nothing andreturns nothing. Ado-nothing function likethisissometimes useful as
a place holder during program development. If the return type is omitted, int is assumed. 
Aprogram isjustasetofdefinitions ofvariables andfunctions. Communication between the
functions isbyarguments andvalues returned bythefunctions, andthrough external variables.
The functions canoccur inanyorder inthesource file,andthesource program canbesplit
into multiple files, so long as no function is split. 
Thereturn statement isthemechanism forreturning avalue from thecalled function toits
caller. Any expression can follow return : 
   return expression ;
The expression willbeconverted tothereturn type ofthefunction ifnecessary. Parentheses
are often used around the expression , but they are optional. 
The calling function isfree toignore thereturned value. Furthermore, there need tobeno
expression afterreturn ;inthatcase, novalue isreturned tothecaller. Control alsoreturns to
thecaller with novalue when execution ``falls offtheend'' ofthefunction byreaching the
closing right brace. Itisnotillegal, butprobably asign oftrouble, ifafunction returns avalue
from oneplace andnovalue from another. Inanycase, ifafunction fails toreturn avalue, its
``value'' is certain to be garbage. 
Thepattern-searching program returns astatus frommain ,thenumber ofmatches found. This
value is available for use by the environment that called the program 
The mechanics ofhow tocompile andload aCprogram thatresides onmultiple source files
vary from one system tothenext. OntheUNIX system, forexample, thecccommand
mentioned inChapter 1 does thejob.Suppose thatthethree functions arestored inthree files
called main.c , getline.c , and strindex.c . Then the command 
   cc main.c getline.c strindex.c
compiles thethree files, placing theresulting object code infilesmain.o ,getline.o ,and
strindex.o ,then loads them allintoanexecutable filecalleda.out .Ifthere isanerror, sayin
main.c ,thefilecanberecompiled byitself andtheresult loaded with theprevious object files,
with the command 
   cc main.c getline.o strindex.o
Thecccommand uses the``.c''versus ``.o''naming convention todistinguish source files
from object files. 
Exercise 4-1. Write thefunctionstrindex(s,t) which returns theposition oftherightmost
occurrence of t in s, or -1 if there is none. 62
4.2 Functions Returning Non-integers
Sofarourexamples offunctions have returned either novalue (void )oranint.What ifa
function must return some other type? many numerical functions likesqrt ,sin,andcos
returndouble ;other specialized functions return other types. Toillustrate how todeal with
this, letuswrite andusethefunctionatof(s) ,which converts thestringstoitsdouble-
precision floating-point equivalent. atof ifanextension ofatoi ,which weshowed versions of
inChapters 2 and3.Ithandles anoptional sign anddecimal point, andthepresence orabsence
ofeither partorfractional part. Ourversion isnotahigh-quality input conversion routine; that
would take more space than wecare touse.Thestandard library includes anatof ;theheader
<stdlib.h>  declares it. 
First,atof itself must declare thetype ofvalue itreturns, since itisnotint.The type name
precedes the function name: 
   #include <ctype.h>
   /* atof:  convert string s to double */
   double atof(char s[])
   {
       double val, power;
       int i, sign;
       for (i = 0; isspace(s[i]); i++)  /* skip white space */
           ;
       sign = (s[i] == '-') ? -1 : 1;
       if (s[i] == '+' || s[i] == '-')
           i++;
       for (val = 0.0; isdigit(s[i]); i++)
           val = 10.0 * val + (s[i] - '0');
       if (s[i] == '.')
           i++;
       for (power = 1.0; isdigit(s[i]); i++) {
           val = 10.0 * val + (s[i] - '0');
           power *= 10;
       }
       return sign * val / power;
   }
Second, andjustasimportant, thecalling routine must know thatatof returns anon-int value.
One way toensure thisistodeclareatof explicitly inthecalling routine. The declaration is
shown inthisprimitive calculator (barely adequate forcheck-book balancing), which reads one
number perline, optionally preceded with asign, andadds them up,printing therunning sum
after each input: 
   #include <stdio.h>
   #define MAXLINE 100
   /* rudimentary calculator */
   main()
   {
       double sum, atof(char []);
       char line[MAXLINE];
       int getline(char line[], int max);
       sum = 0;
       while (getline(line, MAXLINE) > 0)
           printf("\t%g\n", sum += atof(line));
       return 0;
   }
The declaration 63
   double sum, atof(char []);
says thatsumisadouble variable, andthatatof isafunction thattakes onechar[] argument
and returns a double . 
Thefunctionatof must bedeclared anddefined consistently. Ifatof itself andthecalltoitin
main have inconsistent types inthesame source file,theerror willbedetected bythecompiler.
Butif(asismore likely)atof were compiled separately, themismatch would notbedetected,
atof would return adouble thatmain would treat asanint,andmeaningless answers would
result. 
Inthelight ofwhat wehave said about how declarations must match definitions, thismight
seem surprising. Thereason amismatch canhappen isthatifthere isnofunction prototype, a
function is implicitly declared by its first appearance in an expression, such as 
   sum += atof(line)
Ifaname thathasnotbeen previously declared occurs inanexpression andisfollowed bya
leftparentheses, itisdeclared bycontext tobeafunction name, thefunction isassumed to
return anint,and nothing isassumed about itsarguments. Furthermore, ifafunction
declaration does not include arguments, as in 
   double atof();
that tooistaken tomean that nothing istobeassumed about thearguments ofatof ;all
parameter checking isturned off.This special meaning oftheempty argument listisintended
topermit older Cprograms tocompile with new compilers. Butit'sabadidea touseitwith
new Cprograms. Ifthefunction takes arguments, declare them; ifittakes noarguments, use
void . 
Given atof , properly declared, we could write atoi  (convert a string to int) in terms of it: 
   /* atoi:  convert string s to integer using atof */
   int atoi(char s[])
   {
       double atof(char s[]);
       return (int) atof(s);
   }
Notice thestructure ofthedeclarations andthereturn statement. Thevalue oftheexpression
in 
   return expression ;
is converted to the type of the function before the return is taken. Therefore, the value of atof ,
adouble ,isconverted automatically tointwhen itappears inthisreturn ,since thefunction
atoi returns anint.This operation does potentionally discard information, however, sosome
compilers warn ofit.The cast states explicitly that theoperation isintended, andsuppresses
any warning. 
Exercise 4-2.  Extend atof  to handle scientific notation of the form 
   123.45e-6
where a floating-point number may be followed by e or E and an optionally signed exponent. 
4.3 External Variables
ACprogram consists ofasetofexternal objects, which areeither variables orfunctions. The
adjective ``external'' isused incontrast to``internal'', which describes thearguments and
variables defined inside functions. External variables aredefined outside ofanyfunction, and
arethus potentionally available tomany functions. Functions themselves arealways external,
because Cdoes notallow functions tobedefined inside other functions. Bydefault, external64
variables andfunctions have theproperty that allreferences tothem bythesame name, even
from functions compiled separately, arereferences tothesame thing. (The standard calls this
property external linkage .)Inthis sense, external variables are analogous toFortran
COMMON blocks orvariables intheoutermost block inPascal. Wewillseelater how to
define external variables andfunctions thatarevisible only within asingle source file.Because
external variables areglobally accessible, they provide analternative tofunction arguments and
return values forcommunicating data between functions. Any function may access anexternal
variable by referring to it by name, if the name has been declared somehow. 
Ifalarge number ofvariables must beshared among functions, external variables aremore
convenient andefficient than long argument lists. Aspointed outinChapter 1 ,however, this
reasoning should beapplied with some caution, foritcanhave abad effect onprogram
structure, and lead to programs with too many data connections between functions. 
External variables arealso useful because oftheir greater scope and lifetime. Automatic
variables areinternal toafunction; they come intoexistence when thefunction isentered, and
disappear when itisleft. External variables, ontheother hand, arepermanent, sothey can
retain values from onefunction invocation tothenext. Thus iftwofunctions must share some
data, yetneither calls theother, itisoften most convenient iftheshared data iskept inexternal
variables rather than being passed in and out via arguments. 
Letusexamine thisissue with alarger example. Theproblem istowrite acalculator program
thatprovides theoperators +,-,*and/.Because itiseasier toimplement, thecalculator will
usereverse Polish notation instead ofinfix. (Reverse Polish notation isused bysome pocket
calculators, and in languages like Forth and Postscript.) 
In reverse Polish notation, each operator follows its operands; an infix expression like 
   (1 - 2) * (4 + 5)
is entered as 
   1 2 - 4 5 + *
Parentheses arenotneeded; thenotation isunambiguous aslong asweknow how many
operands each operator expects. 
Theimplementation issimple. Each operand ispushed onto astack; when anoperator arrives,
theproper number ofoperands (two forbinary operators) ispopped, theoperator isapplied to
them, andtheresult ispushed back onto thestack. Intheexample above, forinstance, 1and2
arepushed, then replaced bytheir difference, -1.Next, 4and5arepushed andthen replaced
bytheir sum, 9.Theproduct of-1and9,which is-9,replaces them onthestack. Thevalue on
the top of the stack is popped and printed when the end of the input line is encountered. 
The structure oftheprogram isthus aloop that performs theproper operation oneach
operator and operand as it appears: 
   while ( next operator or operand is not end-of-file indicator )
       if ( number)
           push it
       else if ( operator )
           pop operands
           do operation
           push result
       else if ( newline)
           pop and print top of stack
       else
           error65
The operation ofpushing andpopping astack aretrivial, butbythetime error detection and
recovery areadded, they arelong enough that itisbetter toputeach inaseparate function
than torepeat thecode throughout thewhole program. And there should beaseparate
function for fetching the next input operator or operand. 
The main design decision thathasnotyetbeen discussed iswhere thestack is,thatis,which
routines access itdirectly. Onpossibility istokeep itinmain ,andpass thestack andthe
current stack position totheroutines that push andpop it.Butmain doesn't need toknow
about thevariables thatcontrol thestack; itonly does push andpopoperations. Sowehave
decided tostore thestack anditsassociated information inexternal variables accessible tothe
push  and pop functions but not to main . 
Translating thisoutline into code iseasy enough. Iffornow wethink oftheprogram as
existing in one source file, it will look like this: 
    #include s
    #define s 
    function declarations for  main  
    main() { ... }  
    external variables for  push  and pop 
   void push( double f) { ... }
   double pop(void) { ... }
   int getop(char s[]) { ... }
    routines called by  getop  
Later we will discuss how this might be split into two or more source files. 
Thefunctionmain isaloop containing abigswitch onthetype ofoperator oroperand; thisis
a more typical use of switch  than the one shown in Section 3.4 . 
   #include <stdio.h>
   #include <stdlib.h>  /* for  atof() */
   #define MAXOP   100  /* max size of operand or operator */
   #define NUMBER  '0'  /* signal that a number was found */
   int getop(char []);
   void push(double);
   double pop(void);
   /* reverse Polish calculator */
   main()
   {
       int type;
       double op2;
       char s[MAXOP];
       while ((type = getop(s)) != EOF) {
           switch (type) {
           case NUMBER:
               push(atof(s));
               break;
           case '+':
               push(pop() + pop());
               break;
           case '*':
               push(pop() * pop());66
               break;
           case '-':
               op2 = pop();
               push(pop() - op2);
               break;
           case '/':
               op2 = pop();
               if (op2 != 0.0)
                   push(pop() / op2);
               else
                   printf("error: zero divisor\n");
               break;
           case '\n':
               printf("\t%.8g\n", pop());
               break;
           default:
               printf("error: unknown command %s\n", s);
               break;
           }
       }
       return 0;
   }
Because+and*arecommutative operators, theorder inwhich thepopped operands are
combined is irrelevant, but for - and / the left and right operand must be distinguished. In 
   push(pop() - pop());   /* WRONG */
theorder inwhich thetwo calls ofpopareevaluated isnotdefined. Toguarantee theright
order, it is necessary to pop the first value into a temporary variable as we did in main . 
   #define MAXVAL  100  /* maximum depth of val stack */
   int sp = 0;          /* next free stack position */
   double val[MAXVAL];  /* value stack */
   /* push:  push f onto value stack */
   void push(double f)
   {
       if (sp < MAXVAL)
           val[sp++] = f;
       else
           printf("error: stack full, can't push %g\n", f);
   }
   /* pop:  pop and return top value from stack */
   double pop(void)
   {
       if (sp > 0)
           return val[--sp];
       else {
           printf("error: stack empty\n");
           return 0.0;
       }
   }
Avariable isexternal ifitisdefined outside ofanyfunction. Thus thestack andstack index
thatmust beshared bypush andpoparedefined outside these functions. Butmain itself does
not refer to the stack or stack position - the representation can be hidden. 
Letusnow turn totheimplementation ofgetop ,thefunction thatfetches thenext operator or
operand. The task iseasy. Skip blanks and tabs. Ifthenext character isnotadigit ora
hexadecimal point, return it.Otherwise, collect astring ofdigits (which might include a
decimal point), and return NUMBER , the signal that a number has been collected. 
   #include <ctype.h>67
   int getch(void);
   void ungetch(int);
   /* getop:  get next character or numeric operand */
   int getop(char s[])
   {
       int i, c;
       while ((s[0] = c = getch()) == ' ' || c == '\t')
           ;
       s[1] = '\0';
       if (!isdigit(c) && c != '.')
           return c;      /* not a number */
       i = 0;
       if (isdigit(c))    /* collect integer part */
           while (isdigit(s[++i] = c = getch()))
              ;
       if (c == '.')      /* collect fraction part */
           while (isdigit(s[++i] = c = getch()))
              ;
       s[i] = '\0';
       if (c != EOF)
           ungetch(c);
       return NUMBER;
   }
What aregetch andungetch ?Itisoften thecase thataprogram cannot determine thatithas
read enough input until ithasread toomuch. One instance iscollecting characters thatmake
upanumber: until thefirstnon-digit isseen, thenumber isnotcomplete. Butthen theprogram
has read one character too far, a character that it is not prepared for. 
The problem would besolved ifitwere possible to``un-read'' theunwanted character. Then,
every time theprogram reads onecharacter toomany, itcould push itback ontheinput, sothe
restofthecode could behave asifithadnever been read. Fortunately, it'seasy tosimulate un-
getting acharacter, bywriting apair ofcooperating functions. getch delivers thenext input
character to be considered; ungetch  will return them before reading new input. 
How they work together issimple.ungetch puts thepushed-back characters into ashared
buffer --acharacter array.getch reads from thebuffer ifthere isanything else, andcalls
getchar ifthebuffer isempty. There must also beanindex variable thatrecords theposition
of the current character in the buffer. 
Since thebuffer andtheindex areshared bygetch andungetch andmust retain their values
between calls, they must beexternal toboth routines. Thus wecanwritegetch ,ungetch ,and
their shared variables as: 
   #define BUFSIZE 100
   char buf[BUFSIZE];    /* buffer for ungetch */
   int bufp = 0;         /* next free position in buf */
   int getch(void)  /* get a (possibly pushed-back) character */
   {
       return (bufp > 0) ? buf[--bufp] : getchar();
   }
   void ungetch(int c)   /* push character back on input */
   {
       if (bufp >= BUFSIZE)
           printf("ungetch: too many characters\n");
       else
           buf[bufp++] = c;
   }68
Thestandard library includes afunctionungetch thatprovides onecharacter ofpushback; we
will discuss itinChapter 7 .Wehave used anarray forthepushback, rather than asingle
character, to illustrate a more general approach. 
Exercise 4-3.Given thebasic framework, it'sstraightforward toextend thecalculator. Add the
modulus (%) operator and provisions for negative numbers. 
Exercise 4-4. Add thecommands toprint thetopelements ofthestack without popping, to
duplicate it, and to swap the top two elements. Add a command to clear the stack. 
Exercise 4-5. Add access tolibrary functions likesin,exp,andpow.See <math.h> in
Appendix B, Section 4 . 
Exercise 4-6. Add commands forhandling variables. (It'seasy toprovide twenty-six variables
with single-letter names.) Add a variable for the most recently printed value. 
Exercise 4-7. Write aroutineungets(s) thatwillpush back anentire string onto theinput.
Should ungets  know about buf and bufp , or should it just use ungetch ? 
Exercise 4-8. Suppose thatthere willnever bemore than onecharacter ofpushback. Modify
getch  and ungetch  accordingly. 
Exercise 4-9. Ourgetch andungetch donothandle apushed-back EOF correctly. Decide
what their properties ought to be if an EOF is pushed back, then implement your design. 
Exercise 4-10. Analternate organization usesgetline toread anentire input line; thismakes
getch  and ungetch  unnecessary. Revise the calculator to use this approach. 
4.4 Scope Rules
Thefunctions andexternal variables thatmake upaCprogram need notallbecompiled atthe
same time; thesource textoftheprogram may bekept inseveral files, andpreviously compiled
routines may be loaded from libraries. Among the questions of interest are 
•How are declarations written sothat variables are properly declared during
compilation? 
•How aredeclarations arranged sothatallthepieces willbeproperly connected when
the program is loaded? 
•How are declarations organized so there is only one copy? 
•How are external variables initialized? 
Letusdiscuss these topics byreorganizing thecalculator program into several files. Asa
practical matter, thecalculator istoosmall tobeworth splitting, butitisafineillustration of
the issues that arise in larger programs. 
The scope ofaname isthepart oftheprogram within which thename canbeused. Foran
automatic variable declared atthebeginning ofafunction, thescope isthefunction inwhich
thename isdeclared. Local variables ofthesame name indifferent functions areunrelated. The
same is true of the parameters of the function, which are in effect local variables. 
The scope ofanexternal variable orafunction lasts from thepoint atwhich itisdeclared to
theendofthefilebeing compiled. Forexample, ifmain ,sp,val,push ,andpoparedefined in
one file, in the order shown above, that is, 
   main() { ... }69
   int sp = 0;
   double val[MAXVAL];
   void push(double f) { ... }
   double pop(void) { ... }
then thevariablesspandvalmay beused inpush andpopsimply bynaming them; nofurther
declarations areneeded. But these names arenotvisible inmain ,norarepush andpop
themselves. 
Ontheother hand, ifanexternal variable istobereferred tobefore itisdefined, orifitis
defined inadifferent source filefrom theone where itisbeing used, then anextern
declaration is mandatory. 
Itisimportant todistinguish between thedeclaration ofanexternal variable anditsdefinition .
Adeclaration announces theproperties ofavariable (primarily itstype); adefinition also
causes storage to be set aside. If the lines 
   int sp;
   double val[MAXVAL];
appear outside ofanyfunction, they define theexternal variablesspandval,cause storage to
besetaside, andalso serve asthedeclarations fortherestofthat source file.Ontheother
hand, the lines 
   extern int sp;
   extern double val[];
declare fortherestofthesource filethatspisanintandthatvalisadouble array (whose
size is determined elsewhere), but they do not create the variables or reserve storage for them. 
There must beonly onedefinition ofanexternal variable among allthefiles thatmake upthe
source program; other files may containextern declarations toaccess it.(There may also be
extern declarations inthefilecontaining thedefinition.) Array sizes must bespecified with the
definition, but are optional with an extern  declaration. 
Initialization of an external variable goes only with the definition. 
Although itisnotalikely organization forthisprogram, thefunctions push andpopcould be
defined inonefile,andthevariablesvalandspdefined andinitialized inanother. Then these
definitions and declarations would be necessary to tie them together: 
  in file1 : 
      extern int sp;
      extern double val[];
      void push(double f) { ... }
      double pop(void) { ... }
  in file2 : 
      int sp = 0;
      double val[MAXVAL];
Because theextern declarations infile1 lieahead ofandoutside thefunction definitions, they
apply toallfunctions; onesetofdeclarations suffices foralloffile1.This same organization
would also bee needed if the definition of sp and val followed their use in one file. 
4.5 Header Files
Letisnow consider dividing thecalculator program intoseveral source files, asitmight beis
each ofthecomponents were substantially bigger. Themain function would goinonefile,70
which wewillcallmain.c ;push ,pop,andtheir variables gointo asecond file,stack.c ;
getop goes intoathird,getop.c .Finally,getch andungetch gointoafourth file,getch.c ;
weseparate them from theothers because they would come from aseparately-compiled library
in a realistic program. 
There isonemore thing toworry about -thedefinitions anddeclarations shared among files.
Asmuch aspossible, wewant tocentralize this, sothatthere isonly onecopy togetandkeep
right astheprogram evolves. Accordingly, wewillplace thiscommon material inaheader file,
calc.h ,which willbeincluded asnecessary. (The#include lineisdescribed inSection 4.11 .)
The resulting program then looks like this: 
There isatradeoff between thedesire that each filehave access only totheinformation it
needs foritsjobandthepractical reality thatitisharder tomaintain more header files. Upto
some moderate program size, itisprobably best tohave one header filethat contains
everything thatistobeshared between anytwoparts oftheprogram; thatisthedecision we
made here. For a much larger program, more organization and more headers would be needed.
4.6 Static Variables71
Thevariablesspandvalinstack.c ,andbufandbufp ingetch.c ,arefortheprivate useof
thefunctions intheir respective source files, andarenotmeant tobeaccessed byanything else.
Thestatic declaration, applied toanexternal variable orfunction, limits thescope ofthat
object totherestofthesource filebeing compiled. Externalstatic thus provides away to
hide names likebufandbufp inthegetch-ungetch combination, which must beexternal so
they can be shared, yet which should not be visible to users of getch  and ungetch . 
Static storage isspecified byprefixing thenormal declaration with thewordstatic .Ifthetwo
routines and the two variables are compiled in one file, as in 
   static char buf[BUFSIZE];  /* buffer for ungetch */
   static int bufp = 0;       /* next free position in buf */
   int getch(void) { ... }
   void ungetch(int c) { ... }
then noother routine willbeable toaccessbufandbufp ,andthose names willnotconflict
with thesame names inother files ofthesame program. Inthesame way, thevariables that
push  and pop use for stack manipulation can be hidden, by declaring sp and val to be static .
The externalstatic declaration ismost often used forvariables, butitcanbeapplied to
functions aswell. Normally, function names areglobal, visible toany part oftheentire
program. Ifafunction isdeclaredstatic ,however, itsname isinvisible outside ofthefilein
which it is declared. 
Thestatic declaration canalso beapplied tointernal variables. Internalstatic variables are
local toaparticular function justasautomatic variables are,butunlike automatics, they remain
inexistence rather than coming andgoing each time thefunction isactivated. This means that
internal static  variables provide private, permanent storage within a single function. 
Exercise 4-11. Modifygetop sothat itdoesn't need touseungetch .Hint: useaninternal
static  variable. 
4.7 Register Variables
Aregister declaration advises thecompiler thatthevariable inquestion willbeheavily used.
Theidea isthatregister variables aretobeplaced inmachine registers, which may result in
smaller and faster programs. But compilers are free to ignore the advice. 
The register  declaration looks like 
   register int  x;
   register char c;
andsoon.Theregister declaration canonly beapplied toautomatic variables andtothe
formal parameters of a function. In this later case, it looks like 
   f(register unsigned m, register long n)
   {
       register int i;
       ...
   }
Inpractice, there arerestrictions onregister variables, reflecting therealities ofunderlying
hardware. Only afewvariables ineach function may bekept inregisters, andonly certain types
areallowed. Excess register declarations areharmless, however, since thewordregister is
ignored forexcess ordisallowed declarations. And itisnotpossible totake theaddress ofa
register variable (atopic covered inChapter 5 ),regardless ofwhether thevariable isactually
placed inaregister. The specific restrictions onnumber andtypes ofregister variables vary
from machine to machine. 72
4.8 Block Structure
Cisnotablock-structured language inthesense ofPascal orsimilar languages, because
functions may notbedefined within other functions. Ontheother hand, variables canbe
defined inablock-structured fashion within afunction. Declarations ofvariables (including
initializations) may follow theleftbrace thatintroduces anycompound statement, notjustthe
onethatbegins afunction. Variables declared inthisway hide anyidentically named variables
in outer blocks, and remain in existence until the matching right brace. For example, in 
   if (n > 0) {
       int i;  /* declare a new i */
       for (i = 0; i < n; i++)
           ...
   }
thescope ofthevariableiisthe``true'' branch oftheif;thisiisunrelated toanyioutside
theblock. Anautomatic variable declared andinitialized inablock isinitialized each time the
block is entered. 
Automatic variables, including formal parameters, also hide external variables andfunctions of
the same name. Given the declarations 
   int x;
   int y;
   f(double x)
   {
       double y;
   }
then within thefunctionf,occurrences ofxrefer totheparameter, which isadouble ;outside
f, they refer to the external int. The same is true of the variable y. 
Asamatter ofstyle, it'sbest toavoid variable names thatconceal names inanouter scope; the
potential for confusion and error is too great. 
4.9 Initialization
Initialization hasbeen mentioned inpassing many times sofar,butalways peripherally tosome
other topic. This section summarizes some oftherules, now that wehave discussed the
various storage classes. 
Intheabsence ofexplicit initialization, external and static variables areguaranteed tobe
initialized to zero; automatic and register variables have undefined (i.e., garbage) initial values. 
Scalar variables may beinitialized when they aredefined, byfollowing thename with anequals
sign and an expression: 
   int x = 1;
   char squota = '\'';
   long day = 1000L * 60L * 60L * 24L; /* milliseconds/day */
Forexternal andstatic variables, theinitializer must beaconstant expression; theinitialization
isdone once, conceptionally before theprogram begins execution. Forautomatic andregister
variables, theinitializer isnotrestricted tobeing aconstant: itmay beanyexpression involving
previously defined values, even function calls. Forexample, theinitialization ofthebinary
search program in Section 3.3  could be written as 
   int binsearch(int x, int v[], int n)
   {
       int low = 0;
       int high = n - 1;73
       int mid;
       ...
   }
instead of 
       int low, high, mid;
       low = 0;
       high = n - 1;
Ineffect, initialization ofautomatic variables arejustshorthand forassignment statements.
Which form toprefer islargely amatter oftaste. Wehave generally used explicit assignments,
because initializers in declarations are harder to see and further away from the point of use. 
Anarray may beinitialized byfollowing itsdeclaration with alistofinitializers enclosed in
braces andseparated bycommas. Forexample, toinitialize anarraydays with thenumber of
days in each month: 
   int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
When thesize ofthearray isomitted, thecompiler willcompute thelength bycounting the
initializers, of which there are 12 in this case. 
Ifthere arefewer initializers foranarray than thespecified size, theothers willbezero for
external, static andautomatic variables. Itisanerror tohave toomany initializers. There isno
way tospecify repetition ofaninitializer, nortoinitialize anelement inthemiddle ofanarray
without supplying all the preceding values as well. 
Character arrays areaspecial case ofinitialization; astring may beused instead ofthebraces
and commas notation: 
   char pattern = "ould";
is a shorthand for the longer but equivalent 
   char pattern[] = { 'o', 'u', 'l', 'd', '\0' };
In this case, the array size is five (four characters plus the terminating '\0' ). 
4.10 Recursion
Cfunctions may beused recursively; that is,afunction may callitself either directly or
indirectly. Consider printing anumber asacharacter string. Aswementioned before, thedigits
aregenerated inthewrong order: low-order digits areavailable before high-order digits, but
they have to be printed the other way around. 
There aretwo solutions tothisproblem. Onistostore thedigits inanarray asthey are
generated, then print them inthereverse order, aswedidwithitoa insection 3.6 .The
alternative isarecursive solution, inwhichprintd first calls itself tocope with anyleading
digits, then prints the trailing digit. Again, this version can fail on the largest negative number. 
   #include <stdio.h>
   /* printd:  print n in decimal */
   void printd(int n)
   {
       if (n < 0) {
           putchar('-');
           n = -n;
       }
       if (n / 10)
           printd(n / 10);
       putchar(n % 10 + '0');
   }74
When afunction calls itself recursively, each invocation gets afresh setofalltheautomatic
variables, independent oftheprevious set.This inprintd(123) thefirstprintd receives the
argument n=123.Itpasses12toasecondprintd ,which inturn passes1toathird. The
third-level printd prints1,then returns tothesecond level. Thatprintd prints2,then returns
to the first level. That one prints 3 and terminates. 
Another good example ofrecursion isquicksort, asorting algorithm developed byC.A.R.
Hoare in1962. Given anarray, oneelement ischosen andtheothers partitioned intwosubsets
- those less than the partition element and those greater than or equal to it. The same process is
then applied recursively tothetwo subsets. When asubset hasfewer than two elements, it
doesn't need any sorting; this stops the recursion. 
Our version ofquicksort isnotthefastest possible, butit'soneofthesimplest. Weusethe
middle element of each subarray for partitioning. 
   /* qsort:  sort v[left]...v[right] into increasing order */
   void qsort(int v[], int left, int right)
   {
       int i, last;
       void swap(int v[], int i, int j);
       if (left >= right) /* do nothing if array contains */
           return;        /* fewer than two elements */
       swap(v, left, (left + right)/2); /* move partition elem */
       last = left;                     /* to v[0] */
       for (i = left + 1; i <= right; i++)  /* partition */
           if (v[i] < v[left])
               swap(v, ++last, i);
       swap(v, left, last);            /* restore partition  elem */
       qsort(v, left, last-1);
       qsort(v, last+1, right);
   }
Wemoved theswapping operation intoaseparate functionswap because itoccurs three times
in qsort . 
   /* swap:  interchange v[i] and v[j] */
   void swap(int v[], int i, int j)
   {
       int temp;
       temp = v[i];
       v[i] = v[j];
       v[j] = temp;
   }
The standard library includes a version of qsort  that can sort objects of any type. 
Recursion may provide nosaving instorage, since somewhere astack ofthevalues being
processed must bemaintained. Nor willitbefaster. Butrecursive code ismore compact, and
often much easier towrite and understand than thenon-recursive equivalent. Recursion is
especially convenient forrecursively defined data structures like trees, wewill seeanice
example in Section 6.6 . 
Exercise 4-12. Adapt theideas ofprintd towrite arecursive version ofitoa ;thatis,convert
an integer into a string by calling a recursive routine. 
Exercise 4-13. Write arecursive version ofthefunctionreverse(s) ,which reverses the
string s in place. 
4.11 The C Preprocessor75
Cprovides certain language facilities bymeans ofapreprocessor, which isconceptionally a
separate first step incompilation. The two most frequently used features are#include ,to
include thecontents ofafileduring compilation, and#define ,toreplace atoken byan
arbitrary sequence ofcharacters. Other features described inthissection include conditional
compilation and macros with arguments. 
4.11.1 File Inclusion
Fileinclusion makes iteasy tohandle collections of#define sanddeclarations (among other
things). Any source line of the form 
   #include " filename "
or 
   #include < filename >
isreplaced bythecontents ofthefilefilename .Ifthefilename isquoted, searching forthefile
typically begins where thesource program wasfound; ifitisnotfound there, orifthename is
enclosed in<and>,searching follows animplementation-defined rule tofind thefile. An
included file may itself contain #include  lines. 
There areoften several#include lines atthebeginning ofasource file,toinclude common
#define statements andextern declarations, ortoaccess thefunction prototype declarations
forlibrary functions from headers like<stdio.h> .(Strictly speaking, these need notbefiles;
the details of how headers are accessed are implementation-dependent.) 
#include isthepreferred way totiethedeclarations together foralarge program. It
guarantees that allthesource files will besupplied with thesame definitions and variable
declarations, andthus eliminates aparticularly nasty kind ofbug. Naturally, when anincluded
file is changed, all files that depend on it must be recompiled. 
4.11.2 Macro Substitution
A definition has the form 
   #define name replacement text
Itcalls foramacro substitution ofthesimplest kind -subsequent occurrences ofthetoken
name willbereplaced bythereplacement text.Thename ina#define hasthesame form asa
variable name; the replacement text is arbitrary. Normally the replacement text is the rest of the
line, butalong definition may becontinued onto several lines byplacing a\attheendofeach
linetobecontinued. Thescope ofaname defined with#define isfrom itspoint ofdefinition
totheend ofthesource filebeing compiled. Adefinition may useprevious definitions.
Substitutions aremade only fortokens, and donottake place within quoted strings. For
example, ifYES isadefined name, there would benosubstitution inprintf("YES") orin
YESMAN . 
Any name may be defined with any replacement text. For example 
   #define  forever  for (;;)    /* infinite loop */
defines a new word, forever , for an infinite loop. 
Itisalsopossible todefine macros with arguments, sothereplacement textcanbedifferent for
different calls of the macro. As an example, define a macro called max: 
   #define  max(A, B)  ((A) > (B) ? (A) : (B))
Although itlooks likeafunction call, auseofmaxexpands intoin-line code. Each occurrence
ofaformal parameter (hereAorB)willbereplaced bythecorresponding actual argument.
Thus the line 76
   x = max(p+q, r+s);
will be replaced by the line 
   x = ((p+q) > (r+s) ? (p+q) : (r+s));
Solong asthearguments aretreated consistently, thismacro willserve foranydata type; there
is no need for different kinds of max for different data types, as there would be with functions. 
Ifyou examine theexpansion ofmax,you will notice some pitfalls. The expressions are
evaluated twice; thisisbadifthey involve side effects likeincrement operators orinput and
output. For instance 
   max(i++, j++)  /* WRONG */
willincrement thelarger twice. Some care also hastobetaken with parentheses tomake sure
the order of evaluation is preserved; consider what happens when the macro 
   #define square(x)  x * x  /* WRONG */
is invoked as square(z+1) . 
Nonetheless, macros arevaluable. One practical example comes from<stdio.h> ,inwhich
getchar andputchar areoften defined asmacros toavoid therun-time overhead ofa
function call per character processed. The functions in<ctype.h> are also usually
implemented as macros. 
Names may beundefined with#undef ,usually toensure thataroutine isreally afunction, not
a macro: 
   #undef getchar
   int getchar(void) { ... }
Formal parameters arenotreplaced within quoted strings. If,however, aparameter name is
preceded bya#inthereplacement text, thecombination willbeexpanded intoaquoted string
with theparameter replaced bytheactual argument. This can becombined with string
concatenation to make, for example, a debugging print macro: 
   #define  dprint(expr)   printf(#expr " = %g\n", expr)
When this is invoked, as in 
   dprint(x/y)
the macro is expanded into 
   printf("x/y" " = &g\n", x/y);
and the strings are concatenated, so the effect is 
   printf("x/y = &g\n", x/y);
Within theactual argument, each"isreplaced by\"andeach\by\\,sotheresult isalegal
string constant. 
The preprocessor operator##provides away toconcatenate actual arguments during macro
expansion. Ifaparameter inthereplacement textisadjacent toa##,theparameter isreplaced
bytheactual argument, the##andsurrounding white space areremoved, andtheresult isre-
scanned. For example, the macro paste  concatenates its two arguments: 
   #define  paste(front, back)  front ## back
so paste(name, 1)  creates the token name1 . 
The rules for nested uses of ## are arcane; further details may be found in Appendix A . 
Exercise 4-14. Define amacroswap(t,x,y) that interchanges two arguments oftypet.
(Block structure will help.) 77
4.11.3 Conditional Inclusion
Itispossible tocontrol preprocessing itself with conditional statements that areevaluated
during preprocessing. This provides away toinclude code selectively, depending onthevalue
of conditions evaluated during compilation. 
The#iflineevaluates aconstant integer expression (which may notincludesizeof ,casts, or
enum constants). Iftheexpression isnon-zero, subsequent lines until an#endif or#elif or
#else areincluded. (The preprocessor statement #elif islikeelse-if .)The expression
defined (name ) in a #if is 1 if the name  has been defined, and 0 otherwise. 
For example, tomake sure that thecontents ofafilehdr.h areincluded only once, the
contents of the file are surrounded with a conditional like this: 
   #if !defined(HDR)
   #define HDR
   /* contents of hdr.h go here */
   #endif
The first inclusion ofhdr.h defines thenameHDR;subsequent inclusions willfind thename
defined andskip down tothe#endif .Asimilar style canbeused toavoid including files
multiple times. Ifthisstyle isused consistently, then each header canitself include anyother
headers onwhich itdepends, without theuser oftheheader having todeal with the
interdependence. 
This sequence tests the name SYSTEM  to decide which version of a header to include: 
   #if SYSTEM == SYSV
       #define HDR "sysv.h"
   #elif SYSTEM == BSD
       #define HDR "bsd.h"
   #elif SYSTEM == MSDOS
       #define HDR "msdos.h"
   #else
       #define HDR "default.h"
   #endif
   #include HDR
The#ifdef and#ifndef lines arespecialized forms thattestwhether aname isdefined. The
first example of #if above could have been written 
   #ifndef HDR
   #define HDR
   /* contents of hdr.h go here */
   #endif78
Chapter 5 - Pointers and Arrays
Apointer isavariable that contains theaddress ofavariable. Pointers aremuch used inC,
partly because they aresometimes theonly way toexpress acomputation, andpartly because
they usually lead tomore compact andefficient code than canbeobtained inother ways.
Pointers andarrays areclosely related; thischapter also explores thisrelationship andshows
how to exploit it. 
Pointers have been lumped with thegoto statement asamarvelous way tocreate impossible-
to-understand programs. This iscertainly true when they areused carelessly, anditiseasy to
create pointers thatpoint somewhere unexpected. With discipline, however, pointers canalso
be used to achieve clarity and simplicity. This is the aspect that we will try to illustrate. 
The main change inANSI Cistomake explicit therules about how pointers can be
manipulated, ineffect mandating what good programmers already practice andgood compilers
already enforce. Inaddition, thetypevoid*(pointer tovoid )replaceschar*astheproper
type for a generic pointer. 
5.1 Pointers and Addresses
Letusbegin with asimplified picture ofhow memory isorganized. Atypical machine hasan
array ofconsecutively numbered oraddressed memory cells that may bemanipulated
individually orincontiguous groups. One common situation isthatanybyte canbeachar ,a
pair of one-byte cells can be treated as a short  integer, and four adjacent bytes form a long . A
pointer isagroup ofcells (often twoorfour) thatcanhold anaddress. Soifcisachar andp
is a pointer that points to it, we could represent the situation this way: 
The unary operator & gives the address of an object, so the statement 
   p = &c;
assigns theaddress ofctothevariablep,andpissaid to``point to''c.The&operator only
applies toobjects inmemory: variables andarray elements. Itcannot beapplied toexpressions,
constants, or register  variables. 
Theunary operator*istheindirection ordereferencing operator; when applied toapointer, it
accesses theobject thepointer points to.Suppose thatxandyareintegers andipisapointer
to int. This artificial sequence shows how to declare a pointer and how to use & and *: 
   int x = 1, y = 2, z[10];
   int *ip;          /* ip is a pointer to int */
   ip = &x;          /* ip now points to x */
   y = *ip;          /* y is now 1 */
   *ip = 0;          /* x is now 0 */
   ip = &z[0];       /* ip now points to z[0] */
The declaration of x, y, and z are what we've seen all along. The declaration of the pointer ip, 
   int *ip;79
isintended asamnemonic; itsays that theexpression *ip isanint.The syntax ofthe
declaration foravariable mimics thesyntax ofexpressions inwhich thevariable might appear.
This reasoning applies to function declarations as well. For example, 
   double *dp, atof(char *);
says thatinanexpression *dpandatof(s) have values ofdouble ,andthattheargument of
atof  is a pointer to char . 
You should also note theimplication thatapointer isconstrained topoint toaparticular kind
ofobject: every pointer points toaspecific data type. (There isoneexception: a``pointer to
void ''isused tohold anytype ofpointer butcannot bedereferenced itself. We'll come back to
it in Section 5.11 .) 
If ip points to the integer x, then *ip can occur in any context where x could, so 
   *ip = *ip + 10;
increments *ip by 10. 
The unary operators * and & bind more tightly than arithmetic operators, so the assignment 
   y = *ip + 1
takes whatever ip points at, adds 1, and assigns the result to y, while 
   *ip += 1
increments what ip points to, as do 
   ++*ip
and 
   (*ip)++
The parentheses arenecessary inthis last example; without them, theexpression would
increment ipinstead ofwhat itpoints to,because unary operators like*and++associate right
to left. 
Finally, since pointers arevariables, they canbeused without dereferencing. Forexample, ifiq
is another pointer to int, 
   iq = ip
copies the contents of ip into iq, thus making iq point to whatever ip pointed to. 
5.2 Pointers and Function Arguments
Since Cpasses arguments tofunctions byvalue, there isnodirect way forthecalled function
toalter avariable inthecalling function. Forinstance, asorting routine might exchange two
out-of-order arguments with a function called swap . It is not enough to write 
   swap(a, b);
where the swap  function is defined as 
   void swap(int x, int y)  /* WRONG */
   {
       int temp;
       temp = x;
       x = y;
       y = temp;
   }
Because ofcallbyvalue,swap can't affect thearguments aandbintheroutine thatcalled it.
The function above swaps copies  of a and b. 80
Theway toobtain thedesired effect isforthecalling program topass pointers tothevalues to
be changed: 
   swap(&a, &b);
Since theoperator&produces theaddress ofavariable,&aisapointer toa.Inswap itself, the
parameters are declared as pointers, and the operands are accessed indirectly through them. 
   void swap(int *px, int *py)  /* interchange *px and *py */
   {
       int temp;
       temp = *px;
       *px = *py;
       *py = temp;
   }
Pictorially: 
Pointer arguments enable afunction toaccess andchange objects inthefunction thatcalled it.
Asanexample, consider afunctiongetint that performs free-format input conversion by
breaking astream ofcharacters intointeger values, oneinteger percall.getint hastoreturn
thevalue itfound andalsosignal endoffilewhen there isnomore input. These values have to
bepassed back byseparate paths, fornomatter what value isused forEOF,thatcould also be
the value of an input integer. 
One solution istohavegetint return theendoffilestatus asitsfunction value, while using a
pointer argument tostore theconverted integer back inthecalling function. This isthescheme
used by scanf  as well; see Section 7.4 . 
The following loop fills an array with integers by calls to getint : 81
   int n, array[SIZE], getint(int *);
   for (n = 0; n < SIZE && getint(&array[n]) != EOF; n++)
       ;
Each callsetsarray[n] tothenext integer found intheinput andincrements n.Notice thatit
isessential topass theaddress ofarray[n] togetint .Otherwise there isnoway forgetint
to communicate the converted integer back to the caller. 
Ourversion ofgetint returnsEOFforendoffile,zero ifthenext input isnotanumber, anda
positive value if the input contains a valid number. 
   #include <ctype.h>
   int getch(void);
   void ungetch(int);
   /* getint:  get next integer from input into *pn */
   int getint(int *pn)
   {
       int c, sign;
       while (isspace(c = getch()))   /* skip white space */
           ;
       if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
           ungetch(c);  /* it is not a number */
           return 0;
       }
       sign = (c == '-') ? -1 : 1;
       if (c == '+' || c == '-')
           c = getch();
       for (*pn = 0; isdigit(c), c = getch())
           *pn = 10 * *pn + (c - '0');
       *pn *= sign;
       if (c != EOF)
           ungetch(c);
       return c;
   }
Throughout getint ,*pnisused asanordinaryintvariable. Wehave also usedgetch and
ungetch (described inSection 4.3 )sotheoneextra character thatmust beread canbepushed
back onto the input. 
Exercise 5-1. Aswritten,getint treats a+or-not followed byadigit asavalid
representation of zero. Fix it to push such a character back on the input. 
Exercise 5-2.  Write getfloat , the floating-point analog of getint . What type does getfloat
return as its function value? 
5.3 Pointers and Arrays
InC,there isastrong relationship between pointers andarrays, strong enough that pointers
andarrays should bediscussed simultaneously. Any operation that canbeachieved byarray
subscripting canalsobedone with pointers. Thepointer version willingeneral befaster but,at
least to the uninitiated, somewhat harder to understand. 
The declaration 
   int a[10];
defines anarray ofsize 10,that is,ablock of10consecutive objects nameda[0] ,a[1] ,
...,a[9] . 82
The notationa[i] refers tothei-thelement ofthearray. Ifpaisapointer toaninteger,
declared as 
   int *pa;
then the assignment 
   pa = &a[0];
sets pa to point to element zero of a; that is, pa contains the address of a[0] . 
Now the assignment 
   x = *pa;
will copy the contents of a[0]  into x. 
Ifpapoints toaparticular element ofanarray, then bydefinition pa+1 points tothenext
element, pa+i  points i elements after pa, and pa-i  points i elements before. Thus, if pa points
to a[0] , 
   *(pa+1)
refers tothecontents ofa[1] ,pa+i istheaddress ofa[i] ,and*(pa+i) isthecontents of
a[i] . 83
These remarks aretrue regardless ofthetype orsize ofthevariables inthearraya.The
meaning of``adding 1toapointer,'' andbyextension, allpointer arithmetic, isthatpa+1 points
to the next object, and pa+i  points to the i-th object beyond pa. 
The correspondence between indexing andpointer arithmetic isvery close. Bydefinition, the
value ofavariable orexpression oftype array istheaddress ofelement zero ofthearray. Thus
after the assignment 
   pa = &a[0];
paandahave identical values. Since thename ofanarray isasynonym forthelocation ofthe
initial element, the assignment pa=&a[0]  can also be written as 
   pa = a;
Rather more surprising, atfirstsight, isthefactthatareference toa[i] canalso bewritten as
*(a+i) .Inevaluating a[i] ,Cconverts itto*(a+i) immediately; thetwo forms are
equivalent. Applying theoperator&toboth parts ofthisequivalence, itfollows that&a[i] and
a+iarealsoidentical: a+iistheaddress ofthei-thelement beyonda.Astheother sideofthis
coin, if pa is a pointer, expressions might use it with a subscript; pa[i]  is identical to *(pa+i) .
In short, an array-and-index expression is equivalent to one written as a pointer and offset. 
There isonedifference between anarray name andapointer that must bekept inmind. A
pointer isavariable, sopa=a andpa++ arelegal. But anarray name isnotavariable;
constructions like a=pa  and a++ are illegal. 
When anarray name ispassed toafunction, what ispassed isthelocation oftheinitial
element. Within thecalled function, thisargument isalocal variable, andsoanarray name
parameter isapointer, thatis,avariable containing anaddress. Wecanusethisfacttowrite
another version of strlen , which computes the length of a string. 
   /* strlen:  return length of string s */
   int strlen(char *s)
   {
       int n;
       for (n = 0; *s != '\0', s++)
           n++;
       return n;
   }
Sincesisapointer, incrementing itisperfectly legal;s++hasnoeffect onthecharacter string
inthefunction thatcalledstrlen ,butmerely increments strlen 'sprivate copy ofthepointer.
That means that calls like 
   strlen("hello, world");   /* string constant */
   strlen(array);            /* char array[100]; */
   strlen(ptr);              /* char *ptr; */
all work. 
As formal parameters in a function definition, 
   char s[];
and 
   char *s;
areequivalent; weprefer thelatter because itsays more explicitly thatthevariable isapointer.
When anarray name ispassed toafunction, thefunction canatitsconvenience believe thatit
hasbeen handed either anarray orapointer, andmanipulate itaccordingly. Itcaneven use
both notations if it seems appropriate and clear. 84
Itispossible topass partofanarray toafunction, bypassing apointer tothebeginning ofthe
subarray. For example, if a is an array, 
   f(&a[2])
and 
   f(a+2)
both pass tothefunctionftheaddress ofthesubarray that starts ata[2] .Withinf,the
parameter declaration can read 
   f(int arr[]) { ... }
or 
   f(int *arr) { ... }
Soasfarasfisconcerned, thefactthattheparameter refers topart ofalarger array isofno
consequence. 
Ifoneissure thattheelements exist, itisalso possible toindex backwards inanarray;p[-1] ,
p[-2] ,andsoonaresyntactically legal, andrefer totheelements that immediately precede
p[0] . Of course, it is illegal to refer to objects that are not within the array bounds. 
5.4 Address Arithmetic
Ifpisapointer tosome element ofanarray, thenp++ increments ptopoint tothenext
element, andp+=i increments ittopointielements beyond where itcurrently does. These and
similar constructions are the simples forms of pointer or address arithmetic. 
Cisconsistent andregular initsapproach toaddress arithmetic; itsintegration ofpointers,
arrays, andaddress arithmetic isone ofthestrengths ofthelanguage. Letusillustrate by
writing arudimentary storage allocator. There aretworoutines. Thefirst,alloc(n) ,returns a
pointer tonconsecutive character positions, which canbeused bythecaller ofalloc for
storing characters. The second,afree(p) ,releases thestorage thus acquired soitcanbere-
used later. The routines are``rudimentary'' because thecalls toafree must bemade inthe
opposite order tothecalls made onalloc .That is,thestorage managed byalloc andafree
isastack, orlast-in, first-out. Thestandard library provides analogous functions calledmalloc
andfree that have nosuch restrictions; inSection 8.7 wewill show how they canbe
implemented. 
Theeasiest implementation istohavealloc hand outpieces ofalarge character array thatwe
willcallallocbuf .This array isprivate toalloc andafree .Since they deal inpointers, not
array indices, no other routine need know the name of the array, which can be declared static
inthesource filecontaining alloc andafree ,andthus beinvisible outside it.Inpractical
implementations, thearray may well noteven have aname; itmight instead beobtained by
callingmalloc orbyasking theoperating system forapointer tosome unnamed block of
storage. 
The other information needed ishow much ofallocbuf hasbeen used. Weuseapointer,
calledallocp ,thatpoints tothenext freeelement. Whenalloc isasked forncharacters, it
checks toseeifthere isenough room leftinallocbuf .Ifso,alloc returns thecurrent value
ofallocp (i.e., thebeginning ofthefree block), then increments itbyntopoint tothenext
free area. Ifthere isnoroom,alloc returns zero.afree(p) merely setsallocp topifpis
inside allocbuf . 85
   #define ALLOCSIZE 10000 /* size of available space */
   static char allocbuf[ALLOCSIZE]; /* storage for alloc */
   static char *allocp = allocbuf;  /* next free position */
   char *alloc(int n)    /* return pointer to n characters */
   {
       if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */
           allocp += n;
           return allocp - n; /* old p */
       } else      /* not enough room */
           return 0;
   }
   void afree(char *p)  /* free storage pointed to by p */
   {
       if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
           allocp = p;
   }
Ingeneral apointer canbeinitialized justasanyother variable can, though normally theonly
meaningful values arezero oranexpression involving theaddress ofpreviously defined data of
appropriate type. The declaration 
   static char *allocp = allocbuf;
definesallocp tobeacharacter pointer and initializes ittopoint tothebeginning of
allocbuf ,which isthenext freeposition when theprogram starts. This could also have been
written 
   static char *allocp = &allocbuf[0];
since the array name is the address of the zeroth element. 
The test 
       if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */
checks ifthere's enough room tosatisfy arequest forncharacters. Ifthere is,thenew value of
allocp would beatmost onebeyond theendofallocbuf .Iftherequest canbesatisfied,
alloc returns apointer tothebeginning ofablock ofcharacters (notice thedeclaration ofthe
function itself). Ifnot,alloc must return some signal thatthere isnospace left.Cguarantees
thatzero isnever avalid address fordata, soareturn value ofzero canbeused tosignal an
abnormal event, in this case no space. 
Pointers and integers are not interchangeable. Zero is the sole exception: the constant zero may
beassigned toapointer, andapointer may becompared with theconstant zero. Thesymbolic86
constantNULL isoften used inplace ofzero, asamnemonic toindicate more clearly thatthisis
a special value for a pointer. NULL  is defined in <stdio.h> . We will use NULL  henceforth. 
Tests like 
       if (allocbuf + ALLOCSIZE - allocp >= n) {  /* it fits */
and 
       if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
show several important facets ofpointer arithmetic. First, pointers may becompared under
certain circumstances. If p and q point to members of the same array, then relations like ==, !=,
<, >=, etc., work properly. For example, 
   p < q
istrue ifppoints toanearlier element ofthearray thanqdoes. Any pointer can be
meaningfully compared forequality orinequality with zero. Butthebehavior isundefined for
arithmetic orcomparisons with pointers that donotpoint tomembers ofthesame array.
(There isoneexception: theaddress ofthefirstelement past theendofanarray canbeused in
pointer arithmetic.) 
Second, wehave already observed thatapointer andaninteger may beadded orsubtracted.
The construction 
   p + n
means theaddress ofthen-thobject beyond theonepcurrently points to.This istrue
regardless ofthekind ofobjectppoints to;nisscaled according tothesizeoftheobjectsp
points to,which isdetermined bythedeclaration ofp.Ifanintisfour bytes, forexample, the
int will be scaled by four. 
Pointer subtraction isalso valid: ifpandqpoint toelements ofthesame array, andp<q,then
q-p+1 isthenumber ofelements fromptoqinclusive. This fact canbeused towrite yet
another version of strlen : 
   /* strlen:  return length of string s */
   int strlen(char *s)
   {
       char *p = s;
       while (*p != '\0')
           p++;
       return p - s;
   }
Initsdeclaration, pisinitialized tos,thatis,topoint tothefirstcharacter ofthestring. Inthe
while loop, each character inturn isexamined until the'\0' attheendisseen. Becausep
points tocharacters, p++advances ptothenext character each time, andp-sgives thenumber
ofcharacters advanced over, thatis,thestring length. (The number ofcharacters inthestring
could be too large to store in an int. The header <stddef.h>  defines a type ptrdiff_t  that is
large enough tohold thesigned difference oftwo pointer values. Ifwewere being cautious,
however, wewould usesize_t forthereturn value ofstrlen ,tomatch thestandard library
version. size_t  is the unsigned integer type returned by the sizeof  operator. 
Pointer arithmetic isconsistent: ifwehad been dealing withfloat s,which occupy more
storage thatchar s,andifpwere apointer tofloat ,p++would advance tothenextfloat .
Thus wecould write another version ofalloc thatmaintains float sinstead ofchar s,merely
bychanging char tofloat throughout alloc andafree .Allthepointer manipulations
automatically take into account the size of the objects pointed to. 87
Thevalid pointer operations areassignment ofpointers ofthesame type, adding orsubtracting
apointer andaninteger, subtracting orcomparing twopointers tomembers ofthesame array,
andassigning orcomparing tozero. Allother pointer arithmetic isillegal. Itisnotlegal toadd
two pointers, ortomultiply ordivide orshift ormask them, ortoaddfloat ordouble to
them, oreven, except forvoid*,toassign apointer ofonetype toapointer ofanother type
without a cast. 
5.5 Character Pointers and Functions
A string constant , written as 
   "I am a string"
isanarray ofcharacters. Intheinternal representation, thearray isterminated with thenull
character '\0' sothatprograms canfindtheend. Thelength instorage isthus onemore than
the number of characters between the double quotes. 
Perhaps the most common occurrence of string constants is as arguments to functions, as in 
   printf("hello, world\n");
When acharacter string likethisappears inaprogram, access toitisthrough acharacter
pointer;printf receives apointer tothebeginning ofthecharacter array. That is,astring
constant is accessed by a pointer to its first element. 
String constants need not be function arguments. If pmessage  is declared as 
   char *pmessage;
then the statement 
   pmessage = "now is the time";
assigns topmessage apointer tothecharacter array. This isnotastring copy; only pointers
areinvolved. Cdoes notprovide anyoperators forprocessing anentire string ofcharacters as
a unit. 
There is an important difference between these definitions: 
   char amessage[] = "now is the time"; /* an array */
   char *pmessage = "now is the time"; /* a pointer */
amessage isanarray, just bigenough tohold thesequence ofcharacters and'\0' that
initializes it.Individual characters within thearray may bechanged butamessage willalways
refer tothesame storage. Ontheother hand,pmessage isapointer, initialized topoint toa
string constant; thepointer may subsequently bemodified topoint elsewhere, buttheresult is
undefined if you try to modify the string contents. 
Wewill illustrate more aspects ofpointers and arrays bystudying versions oftwo useful
functions adapted from thestandard library. The first function isstrcpy(s,t) ,which copies
thestringttothestrings.Itwould benice justtosays=tbutthiscopies thepointer, notthe
characters. To copy the characters, we need a loop. The array version first: 88
   /* strcpy:  copy t to s; array subscript version */
   void strcpy(char *s, char *t)
   {
       int i;
       i = 0;
       while ((s[i] = t[i]) != '\0')
           i++;
   }
For contrast, here is a version of strcpy  with pointers: 
   /* strcpy:  copy t to s; pointer version */
   void strcpy(char *s, char *t)
   {
       int i;
       i = 0;
       while ((*s = *t) != '\0') {
           s++;
           t++;
       }
   }
Because arguments arepassed byvalue,strcpy canusetheparameters sandtinanyway it
pleases. Here they areconveniently initialized pointers, which aremarched along thearrays a
character at a time, until the '\0'  that terminates t has been copied into s. 
Inpractice,strcpy would notbewritten asweshowed itabove. Experienced Cprogrammers
would prefer 
   /* strcpy:  copy t to s; pointer version 2 */
   void strcpy(char *s, char *t)
   {
       while ((*s++ = *t++) != '\0')
           ;
   }
This moves theincrement ofsandtinto thetestpart oftheloop. The value of*t++ isthe
character thattpointed tobeforetwas incremented; thepostfix++doesn't changetuntil
after thischaracter hasbeen fetched. Inthesame way, thecharacter isstored into theolds
position beforesisincremented. This character isalsothevalue thatiscompared against'\0'
tocontrol theloop. Theneteffect isthatcharacters arecopied fromttos,upandincluding
the terminating '\0' . 
Asthefinal abbreviation, observe that acomparison against'\0' isredundant, since the
question is merely whether the expression is zero. So the function would likely be written as 
   /* strcpy:  copy t to s; pointer version 3 */
   void strcpy(char *s, char *t)
   {
       while (*s++ = *t++)
           ;
   }
Although thismay seem cryptic atfirst sight, thenotational convenience isconsiderable, and
the idiom should be mastered, because you will see it frequently in C programs. 
The strcpy  in the standard library ( <string.h> ) returns the target string as its function value.
The second routine that wewill examine isstrcmp(s,t) ,which compares thecharacter
stringssandt,andreturns negative, zero orpositive ifsislexicographically lessthan, equal
to,orgreater thant.The value isobtained bysubtracting thecharacters atthefirst position
where s and t disagree. 
   /* strcmp:  return <0 if s<t, 0 if s==t, >0 if s>t */89
   int strcmp(char *s, char *t)
   {
       int i;
       for (i = 0; s[i] == t[i]; i++)
           if (s[i] == '\0')
               return 0;
       return s[i] - t[i];
   }
The pointer version of strcmp : 
   /* strcmp:  return <0 if s<t, 0 if s==t, >0 if s>t */
   int strcmp(char *s, char *t)
   {
       for ( ; *s == *t; s++, t++)
           if (*s == '\0')
               return 0;
       return *s - *t;
   }
Since++and--areeither prefix orpostfix operators, other combinations of*and++and--
occur, although less frequently. For example, 
   *--p
decrements p before fetching the character that p points to. In fact, the pair of expressions 
   *p++ = val;  /* push val onto stack */
   val = *--p;  /* pop top of stack into val */
are the standard idiom for pushing and popping a stack; see Section 4.3 . 
Theheader<string.h> contains declarations forthefunctions mentioned inthissection, plus
a variety of other string-handling functions from the standard library. 
Exercise 5-3. Write apointer version ofthefunctionstrcat that weshowed inChapter 2 :
strcat(s,t)  copies the string t to the end of s. 
Exercise 5-4. Write thefunctionstrend(s,t) ,which returns 1ifthestringtoccurs atthe
end of the string s, and zero otherwise. 
Exercise 5-5. Write versions ofthelibrary functions strncpy ,strncat ,andstrncmp ,which
operate onatmost the firstncharacters oftheir argument strings. For example,
strncpy(s,t,n)  copies at most n characters of t to s. Full descriptions are in Appendix B . 
Exercise 5-6. Rewrite appropriate programs from earlier chapters andexercises with pointers
instead ofarray indexing. Good possibilities includegetline (Chapters 1 and4),atoi ,itoa ,
andtheir variants (Chapters 2 ,3,and4),reverse (Chapter 3 ),andstrindex andgetop
(Chapter 4 ). 
5.6 Pointer Arrays; Pointers to Pointers
Since pointers arevariables themselves, they canbestored inarrays justasother variables can.
Letusillustrate bywriting aprogram thatwillsort asetoftextlines intoalphabetic order, a
stripped-down version of the UNIX program sort . 
InChapter 3 ,wepresented aShell sort function that would sort anarray ofintegers, andin
Chapter 4  we improved on it with a quicksort. The same algorithms will work, except that now
wehave todeal with lines oftext, which areofdifferent lengths, andwhich, unlike integers,
can't becompared ormoved inasingle operation. Weneed adata representation thatwillcope
efficiently and conveniently with variable-length text lines. 
This iswhere thearray ofpointers enters. Ifthelines tobesorted arestored end-to-end inone
long character array, then each linecanbeaccessed byapointer toitsfirst character. The90
pointers themselves canbeestored inanarray. Two lines canbecompared bypassing their
pointers tostrcmp .When two out-of-order lines have tobeexchanged, thepointers inthe
pointer array are exchanged, not the text lines themselves. 
This eliminates thetwin problems ofcomplicated storage management andhigh overhead that
would go with moving the lines themselves. 
The sorting process has three steps: 
  read all the lines of input
  sort them
  print them in order 
Asusual, it'sbesttodivide theprogram intofunctions thatmatch thisnatural division, with the
main routine controlling theother functions. Letusdefer thesorting step foramoment, and
concentrate on the data structure and the input and output. 
The input routine hastocollect andsave thecharacters ofeach line, andbuild anarray of
pointers tothelines. Itwillalsohave tocount thenumber ofinput lines, since thatinformation
isneeded forsorting andprinting. Since theinput function canonly cope with afinite number
of input lines, it can return some illegal count like -1 if too much input is presented. 
Theoutput routine only hastoprint thelines intheorder inwhich they appear inthearray of
pointers. 
   #include <stdio.h>
   #include <string.h>
   #define MAXLINES 5000     /* max #lines to be sorted */
   char *lineptr[MAXLINES];  /* pointers to text lines */
   int readlines(char *lineptr[], int nlines);
   void writelines(char *lineptr[], int nlines);
   void qsort(char *lineptr[], int left, int right);
   /* sort input lines */
   main()
   {
       int nlines;     /* number of input lines read */
       if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
           qsort(lineptr, 0, nlines-1);
           writelines(lineptr, nlines);
           return 0;
       } else {
           printf("error: input too big to sort\n");
           return 1;
       }
   }
   #define MAXLEN 1000  /* max length of any input line */
   int getline(char *, int);91
   char *alloc(int);
   /* readlines:  read input lines */
   int readlines(char *lineptr[], int maxlines)
   {
       int len, nlines;
       char *p, line[MAXLEN];
       nlines = 0;
       while ((len = getline(line, MAXLEN)) > 0)
           if (nlines >= maxlines || p = alloc(len) == NULL)
               return -1;
           else {
               line[len-1] = '\0';  /* delete newline */
               strcpy(p, line);
               lineptr[nlines++] = p;
           }
       return nlines;
   }
   /* writelines:  write output lines */
   void writelines(char *lineptr[], int nlines)
   {
       int i;
       for (i = 0; i < nlines; i++)
           printf("%s\n", lineptr[i]);
   }
The function getline  is from Section 1.9 . 
The main new thing is the declaration for lineptr : 
   char *lineptr[MAXLINES]
says thatlineptr isanarray ofMAXLINES elements, each element ofwhich isapointer toa
char .That is,lineptr[i] isacharacter pointer, and*lineptr[i] isthecharacter itpoints
to, the first character of the i-th saved text line. 
Sincelineptr isitself thename ofanarray, itcanbetreated asapointer inthesame manner
as in our earlier examples, and writelines  can be written instead as 
   /* writelines:  write output lines */
   void writelines(char *lineptr[], int nlines)
   {
       while (nlines-- > 0)
           printf("%s\n", *lineptr++);
   }
Initially,*lineptr points tothefirst line; each element advances ittothenext linepointer
while nlines  is counted down. 
With input andoutput under control, wecanproceed tosorting. Thequicksort from Chapter 4
needs minor changes: thedeclarations have tobemodified, andthecomparison operation must
bedone bycallingstrcmp .The algorithm remains thesame, which gives ussome confidence
that it will still work. 
   /* qsort:  sort v[left]...v[right] into increasing order */
   void qsort(char *v[], int left, int right)
   {
       int i, last;
       void swap(char *v[], int i, int j);
       if (left >= right)  /* do nothing if array contains */
           return;         /* fewer than two elements */
       swap(v, left, (left + right)/2);
       last = left;92
       for (i = left+1; i <= right; i++)
           if (strcmp(v[i], v[left]) < 0)
               swap(v, ++last, i);
       swap(v, left, last);
       qsort(v, left, last-1);
       qsort(v, last+1, right);
   }
Similarly, the swap routine needs only trivial changes: 
   /* swap:  interchange v[i] and v[j] */
   void swap(char *v[], int i, int j)
   {
       char *temp;
       temp = v[i];
       v[i] = v[j];
       v[j] = temp;
   }
Since anyindividual element ofv(aliaslineptr )isacharacter pointer,temp must bealso, so
one can be copied to the other. 
Exercise 5-7. Rewritereadlines tostore lines inanarray supplied bymain ,rather than
calling alloc  to maintain storage. How much faster is the program? 
5.7 Multi-dimensional Arrays
Cprovides rectangular multi-dimensional arrays, although inpractice they aremuch lessused
than arrays of pointers. In this section, we will show some of their properties. 
Consider theproblem ofdate conversion, from dayofthemonth todayoftheyear andvice
versa. For example, March 1 is the 60th day of a non-leap year, and the 61st day of a leap year.
Letusdefine twofunctions todotheconversions: day_of_year converts themonth andday
intothedayoftheyear, andmonth_day converts thedayoftheyear intothemonth andday.
Since this latter function computes two values, the month and day arguments will be pointers: 
   month_day(1988, 60, &m, &d)
sets m to 2 and d to 29 (February 29th). 
These functions both need thesame information, atable ofthenumber ofdays ineach month
(``thirty days hath September ...''). Since thenumber ofdays permonth differs forleap years
andnon-leap years, it'seasier toseparate them intotworows ofatwo-dimensional array than
to keep track of what happens to February during computation. The array and the functions for
performing the transformations are as follows: 
   static char daytab[2][13] = {
       {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
       {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
   };
   /* day_of_year:  set day of year from month & day */
   int day_of_year(int year, int month, int day)
   {
       int i, leap;
       leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
       for (i = 1; i < month; i++)
           day += daytab[leap][i];
       return day;
   }
   /* month_day:  set month, day from day of year */
   void month_day(int year, int yearday, int *pmonth, int *pday)
   {
       int i, leap;93
       leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
       for (i = 1; yearday > daytab[leap][i]; i++)
           yearday -= daytab[leap][i];
       *pmonth = i;
       *pday = yearday;
   }
Recall thatthearithmetic value ofalogical expression, such astheoneforleap ,iseither zero
(false) or one (true), so it can be used as a subscript of the array daytab . 
The arraydaytab hastobeexternal tobothday_of_year andmonth_day ,sothey canboth
useit.Wemade itchar toillustrate alegitimate useofchar forstoring small non-character
integers. 
daytab isthefirsttwo-dimensional array wehave dealt with. InC,atwo-dimensional array is
really aone-dimensional array, each ofwhose elements isanarray. Hence subscripts are
written as 
   daytab[i][j]    /* [row][col] */
rather than 
   daytab[i,j]    /* WRONG */
Other than thisnotational distinction, atwo-dimensional array canbetreated inmuch thesame
way asinother languages. Elements arestored byrows, sotherightmost subscript, orcolumn,
varies fastest as elements are accessed in storage order. 
Anarray isinitialized byalistofinitializers inbraces; each row ofatwo-dimensional array is
initialized byacorresponding sub-list. Westarted thearraydaytab with acolumn ofzero so
thatmonth numbers canrunfrom thenatural 1to12instead of0to11.Since space isnotata
premium here, this is clearer than adjusting the indices. 
Ifatwo-dimensional array istobepassed toafunction, theparameter declaration inthe
function must include thenumber ofcolumns; thenumber ofrows isirrelevant, since what is
passed is,asbefore, apointer toanarray ofrows, where each row isanarray of13ints.In
thisparticular case, itisapointer toobjects that arearrays of13ints.Thus ifthearray
daytab  is to be passed to a function f, the declaration of f would be: 
   f(int daytab[2][13]) { ... }
It could also be 
   f(int daytab[][13]) { ... }
since the number of rows is irrelevant, or it could be 
   f(int (*daytab)[13]) { ... }
which says that theparameter isapointer toanarray of13integers. The parentheses are
necessary since brackets []have higher precedence than*.Without parentheses, the
declaration 
   int *daytab[13]
isanarray of13pointers tointegers. More generally, only thefirstdimension (subscript) ofan
array is free; all the others have to be specified. 
Section 5.12  has a further discussion of complicated declarations. 
Exercise 5-8.  There is no error checking in day_of_year  or month_day . Remedy this defect. 
5.8 Initialization of Pointer Arrays94
Consider theproblem ofwriting afunctionmonth_name(n) ,which returns apointer toa
character string containing thename ofthen-thmonth. This isanideal application foran
internalstatic array.month_name contains aprivate array ofcharacter strings, andreturns a
pointer totheproper one when called. This section shows how that array ofnames is
initialized. 
The syntax is similar to previous initializations: 
   /* month_name:  return name of n-th month */
   char *month_name(int n)
   {
       static char *name[] = {
           "Illegal month",
           "January", "February", "March",
           "April", "May", "June",
           "July", "August", "September",
           "October", "November", "December"
       };
       return (n < 1 || n > 12) ? name[0] : name[n];
   }
Thedeclaration ofname ,which isanarray ofcharacter pointers, isthesame aslineptr inthe
sorting example. The initializer isalistofcharacter strings; each isassigned tothe
corresponding position inthearray. The characters ofthei-thstring areplaced somewhere,
andapointer tothem isstored inname[i] .Since thesizeofthearrayname isnotspecified,
the compiler counts the initializers and fills in the correct number. 
5.9 Pointers vs. Multi-dimensional Arrays
Newcomers toCaresometimes confused about thedifference between atwo-dimensional
array and an array of pointers, such as name  in the example above. Given the definitions 
   int a[10][20];
   int *b[10];
thena[3][4] andb[3][4] areboth syntactically legal references toasingleint.Butaisa
true two-dimensional array: 200int-sized locations have been setaside, andtheconventional
rectangular subscript calculation 20*row+colisused tofindtheelementa[row,col] .Forb,
however, thedefinition only allocates 10pointers anddoes notinitialize them; initialization
must bedone explicitly, either statically orwith code. Assuming that each element ofbdoes
point toatwenty-element array, then there willbe200intssetaside, plus tencells forthe
pointers. Theimportant advantage ofthepointer array isthattherows ofthearray may beof
different lengths. That is,each element ofbneed notpoint toatwenty-element vector; some
may point to two elements, some to fifty, and some to none at all. 
Although wehave phrased thisdiscussion interms ofintegers, byfarthemost frequent useof
arrays ofpointers istostore character strings ofdiverse lengths, asinthefunction
month_name . Compare the declaration and picture for an array of pointers: 
   char *name[] = { "Illegal month", "Jan", "Feb", "Mar" };95
with those for a two-dimensional array: 
   char aname[][15] = { "Illegal month", "Jan", "Feb", "Mar" };
Exercise 5-9. Rewrite theroutinesday_of_year andmonth_day with pointers instead of
indexing. 
5.10 Command-line Arguments
Inenvironments thatsupport C,there isaway topass command-line arguments orparameters
toaprogram when itbegins executing. Whenmain iscalled, itiscalled with two arguments.
The first (conventionally calledargc ,forargument count) isthenumber ofcommand-line
arguments theprogram wasinvoked with; thesecond (argv ,forargument vector) isapointer
toanarray ofcharacter strings thatcontain thearguments, oneperstring. Wecustomarily use
multiple levels of pointers to manipulate these character strings. 
The simplest illustration istheprogramecho ,which echoes itscommand-line arguments ona
single line, separated by blanks. That is, the command 
   echo hello, world
prints the output 
   hello, world
Byconvention, argv[0] isthename bywhich theprogram wasinvoked, soargc isatleast 1.
Ifargc is1,there arenocommand-line arguments after theprogram name. Intheexample
above,argc is3,andargv[0] ,argv[1] ,andargv[2] are"echo" ,"hello," ,and"world"
respectively. The first optional argument isargv[1] and the last isargv[argc-1] ;
additionally, the standard requires that argv[argc]  be a null pointer. 
The first version of echo  treats argv  as an array of character pointers: 
   #include <stdio.h>
   /* echo command-line arguments; 1st version */
   main(int argc, char *argv[])
   {
       int i;
       for (i = 1; i < argc; i++)
           printf("%s%s", argv[i], (i < argc-1) ? " " : "");
       printf("\n");
       return 0;96
   }
Sinceargv isapointer toanarray ofpointers, wecanmanipulate thepointer rather than index
thearray. This next variant isbased onincrementing argv ,which isapointer topointer to
char , while argc  is counted down: 
   #include <stdio.h>
   /* echo command-line arguments; 2nd version */
   main(int argc, char *argv[])
   {
       while (--argc > 0)
           printf("%s%s", *++argv, (argc > 1) ? " " : "");
       printf("\n");
       return 0;
   }
Sinceargv isapointer tothebeginning ofthearray ofargument strings, incrementing itby1
(++argv )makes itpoint attheoriginalargv[1] instead ofargv[0] .Each successive
increment moves italong tothenext argument; *argv isthen thepointer tothatargument. At
thesame time,argc isdecremented; when itbecomes zero, there arenoarguments leftto
print. 
Alternatively, we could write the printf  statement as 
   printf((argc > 1) ? "%s " : "%s", *++argv);
This shows that the format argument of printf  can be an expression too. 
Asasecond example, letusmake some enhancements tothepattern-finding program from
Section 4.1 .Ifyourecall, wewired thesearch pattern deep into theprogram, anobviously
unsatisfactory arrangement. Following thelead oftheUNIX programgrep ,letusenhance the
program so the pattern to be matched is specified by the first argument on the command line. 
   #include <stdio.h>
   #include <string.h>
   #define MAXLINE 1000
   int getline(char *line, int max);
   /* find:  print lines that match pattern from 1st arg */
   main(int argc, char *argv[])
   {
       char line[MAXLINE];
       int found = 0;
       if (argc != 2)
           printf("Usage: find pattern\n");
       else
           while (getline(line, MAXLINE) > 0)
               if (strstr(line, argv[1]) != NULL) {
                   printf("%s", line);
                   found++;
               }
       return found;
   }
The standard library functionstrstr(s,t) returns apointer tothefirst occurrence ofthe
string t in the string s, or NULL  if there is none. It is declared in <string.h> . 
Themodel cannow beelaborated toillustrate further pointer constructions. Suppose wewant
toallow two optional arguments. One says ``print allthelines except those that match the
pattern;'' the second says ``precede each printed line by its line number.'' 97
Acommon convention forCprograms onUNIX systems isthatanargument thatbegins with
aminus sign introduces anoptional flagorparameter. Ifwechoose-x(for``except'') tosignal
the inversion, and -n (``number'') to request line numbering, then the command 
   find -x -n pattern
will print each line that doesn't match the pattern, preceded by its line number. 
Optional arguments should bepermitted inanyorder, andtherestoftheprogram should be
independent ofthenumber ofarguments that wepresent. Furthermore, itisconvenient for
users if option arguments can be combined, as in 
   find -nx pattern
Here is the program: 
   #include <stdio.h>
   #include <string.h>
   #define MAXLINE 1000
   int getline(char *line, int max);
   /* find: print lines that match pattern from 1st arg */
   main(int argc, char *argv[])
   {
       char line[MAXLINE];
       long lineno = 0;
       int c, except = 0, number = 0, found = 0;
       while (--argc > 0 && (*++argv)[0] == '-')
           while (c = *++argv[0])
               switch (c) {
               case 'x':
                   except = 1;
                   break;
               case 'n':
                   number = 1;
                   break;
               default:
                   printf("find: illegal option %c\n", c);
                   argc = 0;
                   found = -1;
                   break;
               }
       if (argc != 1)
           printf("Usage: find -x -n pattern\n");
       else
           while (getline(line, MAXLINE) > 0) {
               lineno++;
               if ((strstr(line, *argv) != NULL) != except) {
                   if (number)
                       printf("%ld:", lineno);
                   printf("%s", line);
                   found++;
               }
           }
       return found;
   }
argc isdecremented andargv isincremented before each optional argument. Attheendofthe
loop, ifthere arenoerrors,argc tells how many arguments remain unprocessed andargv
points tothefirst ofthese. Thusargc should be1and*argv should point atthepattern.
Notice that*++argv isapointer toanargument string, so(*++argv)[0] isitsfirstcharacter.
(An alternate valid form would be**++argv .)Because[]binds tighter than*and++,the
parentheses arenecessary; without them theexpression would betaken as*++(argv[0]) .In98
fact, that iswhat wehave used intheinner loop, where thetask istowalk along aspecific
argument string. Intheinner loop, theexpression *++argv[0] increments thepointer
argv[0] ! 
Itisrare that one uses pointer expressions more complicated than these; insuch cases,
breaking them into two or three steps will be more intuitive. 
Exercise 5-10. Write theprogramexpr ,which evaluates areverse Polish expression from the
command line, where each operator or operand is a separate argument. For example, 
   expr 2 3 4 + *
evaluates 2 * (3+4). 
Exercise 5-11. Modify theprogramentab anddetab (written asexercises inChapter 1 )to
accept a list of tab stops as arguments. Use the default tab settings if there are no arguments. 
Exercise 5-12.  Extend entab  and detab  to accept the shorthand 
   entab -m +n
tomean tabstops every ncolumns, starting atcolumn m.Choose convenient (for theuser)
default behavior. 
Exercise 5-13. Write theprogramtail ,which prints thelastnlines ofitsinput. Bydefault, n
is set to 10, let us say, but it can be changed by an optional argument so that 
   tail -n
prints thelastnlines. The program should behave rationally nomatter how unreasonable the
input orthevalue ofn.Write theprogram soitmakes thebest useofavailable storage; lines
should bestored asinthesorting program ofSection 5.6 ,notinatwo-dimensional array of
fixed size. 
5.11 Pointers to Functions
InC,afunction itself isnotavariable, butitispossible todefine pointers tofunctions, which
canbeassigned, placed inarrays, passed tofunctions, returned byfunctions, andsoon.We
willillustrate thisbymodifying thesorting procedure written earlier inthischapter sothatif
theoptional argument -nisgiven, itwill sort theinput lines numerically instead of
lexicographically. 
Asortoften consists ofthree parts -acomparison thatdetermines theordering ofanypairof
objects, anexchange thatreverses their order, andasorting algorithm thatmakes comparisons
and exchanges until theobjects areinorder. The sorting algorithm isindependent ofthe
comparison and exchange operations, sobypassing different comparison and exchange
functions toit,wecanarrange tosort bydifferent criteria. This istheapproach taken inour
new sort. 
Lexicographic comparison oftwo lines isdone bystrcmp ,asbefore; wewill also need a
routinenumcmp that compares two lines onthebasis ofnumeric value andreturns thesame
kind ofcondition indication asstrcmp does. These functions aredeclared ahead ofmain anda
pointer totheappropriate oneispassed toqsort .Wehave skimped onerror processing for
arguments, so as to concentrate on the main issues. 
   #include <stdio.h>
   #include <string.h>
   #define MAXLINES 5000     /* max #lines to be sorted */
   char *lineptr[MAXLINES];  /* pointers to text lines */99
   int readlines(char *lineptr[], int nlines);
   void writelines(char *lineptr[], int nlines);
   void qsort(void *lineptr[], int left, int right,
              int (*comp)(void *, void *));
   int numcmp(char *, char *);
   /* sort input lines */
   main(int argc, char *argv[])
   {
       int nlines;        /* number of input lines read */
       int numeric = 0;   /* 1 if numeric sort */
       if (argc > 1 && strcmp(argv[1], "-n") == 0)
           numeric = 1;
       if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
           qsort((void**) lineptr, 0, nlines-1,
             (int (*)(void*,void*))(numeric ? numcmp : strcmp));
           writelines(lineptr, nlines);
           return 0;
       } else {
           printf("input too big to sort\n");
           return 1;
       }
   }
Inthecalltoqsort ,strcmp andnumcmp areaddresses offunctions. Since they areknown to
be functions, the & is not necessary, in the same way that it is not needed before an array name.
Wehave writtenqsort soitcanprocess anydata type, notjustcharacter strings. Asindicated
bythefunction prototype, qsort expects anarray ofpointers, two integers, andafunction
with two pointer arguments. The generic pointer typevoid*isused forthepointer
arguments. Any pointer canbecast tovoid*andback again without lossofinformation, so
wecan callqsort bycasting arguments tovoid*.The elaborate cast ofthefunction
argument casts thearguments ofthecomparison function. These willgenerally have noeffect
on actual representation, but assure the compiler that all is well. 
   /* qsort:  sort v[left]...v[right] into increasing order */
   void qsort(void *v[], int left, int right,
              int (*comp)(void *, void *))
   {
       int i, last;
       void swap(void *v[], int, int);
       if (left >= right)    /* do  nothing if array contains */
           return;           /* fewer than two elements */
       swap(v, left, (left + right)/2);
       last = left;
       for (i = left+1; i <= right;  i++)
           if ((*comp)(v[i], v[left]) < 0)
               swap(v, ++last, i);
       swap(v, left, last);
       qsort(v, left, last-1, comp);
       qsort(v, last+1, right, comp);
   }
The declarations should be studied with some care. The fourth parameter of qsort  is 
   int (*comp)(void *, void *)
which says thatcomp isapointer toafunction thathastwovoid*arguments andreturns an
int. 
The use of comp  in the line 
   if ((*comp)(v[i], v[left]) < 0)100
is consistent with the declaration: comp  is a pointer to a function, *comp  is the function, and 
   (*comp)(v[i], v[left])
isthecalltoit.The parentheses areneeded sothecomponents arecorrectly associated;
without them, 
   int *comp(void *, void *)    /* WRONG */
says that comp  is a function returning a pointer to an int, which is very different. 
We have already shownstrcmp ,which compares two strings. Here isnumcmp ,which
compares two strings on a leading numeric value, computed by calling atof : 
   #include <stdlib.h>
   /* numcmp:  compare s1 and s2 numerically */
   int numcmp(char *s1, char *s2)
   {
       double v1, v2;
       v1 = atof(s1);
       v2 = atof(s2);
       if (v1 < v2)
           return -1;
       else if (v1 > v2)
           return 1;
       else
           return 0;
   }
Theswap function, which exchanges twopointers, isidentical towhat wepresented earlier in
the chapter, except that the declarations are changed to void * . 
   void swap(void *v[],  int i, int j;)
   {
       void *temp;
       temp = v[i];
       v[i] = v[j];
       v[j] = temp;
   }
Avariety ofother options canbeadded tothesorting program; some make challenging
exercises. 
Exercise 5-14. Modify thesortprogram tohandle a-rflag, which indicates sorting inreverse
(decreasing) order. Be sure that -r works with -n. 
Exercise 5-15. Add theoption-ftofold upper and lower case together, sothat case
distinctions are not made during sorting; for example, a and A compare equal. 
Exercise 5-16. Add the-d(``directory order'') option, which makes comparisons only on
letters, numbers and blanks. Make sure it works in conjunction with -f. 
Exercise 5-17. Add afield-searching capability, sosorting may beedone onfields within lines,
each field sorted according toanindependent setofoptions. (The index forthisbook was
sorted with -df for the index category and -n for the page numbers.) 
5.12 Complicated Declarations
Cissometimes castigated forthesyntax ofitsdeclarations, particularly ones that involve
pointers tofunctions. The syntax isanattempt tomake thedeclaration andtheuseagree; it
works well forsimple cases, butitcanbeconfusing fortheharder ones, because declarations
cannot be read left to right, and because parentheses are over-used. The difference between 101
   int *f();       /* f: function returning pointer to int */
and 
   int (*pf)();    /* pf: pointer to function returning int */ 
illustrates theproblem: *isaprefix operator and ithaslower precedence than(),so
parentheses are necessary to force the proper association. 
Although truly complicated declarations rarely arise inpractice, itisimportant toknow how to
understand them, and, ifnecessary, how tocreate them. One good way tosynthesize
declarations isinsmall steps withtypedef ,which isdiscussed inSection 6.7 .Asan
alternative, inthissection wewillpresent apair ofprograms that convert from valid Ctoa
word description and back again. The word description reads left to right. 
Thefirst,dcl,isthemore complex. Itconverts aCdeclaration intoaword description, asin
these examples: 
char **argv
    argv:  pointer to char
int (*daytab)[13]
    daytab:  pointer to array[13] of int
int *daytab[13]
    daytab:  array[13] of pointer to int
void *comp()
    comp: function returning pointer to void
void (*comp)()
    comp: pointer to function returning void
char (*(*x())[])()
    x: function returning pointer to array[] of
    pointer to function returning char
char (*(*x[3])())[5]
    x: array[3] of pointer to function returning
    pointer to array[5] of char
dcl isbased onthegrammar that specifies adeclarator, which isspelled outprecisely in
Appendix A, Section 8.5 ; this is a simplified form: 
dcl:       optional *'s direct-dcl
direct-dcl name
                 (dcl)
                 direct-dcl()
                 direct-dcl[optional size]
Inwords, adclisadirect-dcl ,perhaps preceded by*'s.Adirect-dcl isaname, ora
parenthesized dcl,oradirect-dcl followed byparentheses, oradirect-dcl followed bybrackets
with an optional size. 
This grammar can be used to parse functions. For instance, consider this declarator: 
   (*pfa[])()
pfawillbeidentified asaname andthus asadirect-dcl .Thenpfa[] isalsoadirect-dcl .Then
*pfa[] isrecognized asadcl,so(*pfa[]) isadirect-dcl .Then(*pfa[])() isadirect-dcl
andthus adcl.Wecanalso illustrate theparse with atreelikethis(where direct-dcl hasbeen
abbreviated to dir-dcl ): 102
Theheart ofthedclprogram isapairoffunctions, dclanddirdcl ,thatparse adeclaration
according tothisgrammar. Because thegrammar isrecursively defined, thefunctions calleach
other recursively asthey recognize pieces ofadeclaration; theprogram iscalled arecursive-
descent parser. 
   /* dcl:  parse a declarator */
   void dcl(void)
   {
       int ns;
       for (ns = 0; gettoken() == '*'; ) /* count *'s */
           ns++;
       dirdcl();
       while (ns-- > 0)
           strcat(out, " pointer to");
   }
   /* dirdcl:  parse a direct declarator */
   void dirdcl(void)
   {
       int type;
       if (tokentype == '(') {         /* ( dcl ) */
           dcl();
           if (tokentype != ')')
               printf("error: missing )\n");
       } else if (tokentype == NAME)  /* variable name */
           strcpy(name, token);
       else
           printf("error: expected name or (dcl)\n");
       while ((type=gettoken()) == PARENS || type == BRACKETS)103
           if (type == PARENS)
               strcat(out, " function returning");
           else {
               strcat(out, " array");
               strcat(out, token);
               strcat(out, " of");
           }
   }
Since theprograms areintended tobeillustrative, notbullet-proof, there aresignificant
restrictions ondcl.Itcanonly handle asimple data type linechar orint.Itdoes nothandle
argument types infunctions, orqualifiers likeconst .Spurious blanks confuse it.Itdoesn't do
much error recovery, soinvalid declarations willalso confuse it.These improvements areleft
as exercises. 
Here are the global variables and the main routine: 
   #include <stdio.h>
   #include <string.h>
   #include <ctype.h>
   #define MAXTOKEN  100
   enum { NAME, PARENS, BRACKETS };
   void dcl(void);
   void dirdcl(void);
   int gettoken(void);
   int tokentype;           /* type of last token */
   char token[MAXTOKEN];    /* last token string */
   char name[MAXTOKEN];     /* identifier name */
   char datatype[MAXTOKEN]; /* data type = char, int, etc. */
   char out[1000];
   main()  /* convert declaration to words */
   {
       while (gettoken() != EOF) {   /* 1st token on line */
           strcpy(datatype, token);  /* is the datatype */
           out[0] = '\0';
           dcl();       /* parse rest of line */
           if (tokentype != '\n')
               printf("syntax error\n");
           printf("%s: %s %s\n", name, out, datatype);
       }
       return 0;
   }
Thefunctiongettoken skips blanks andtabs, then finds thenext token intheinput; a``token''
isaname, apairofparentheses, apair ofbrackets perhaps including anumber, oranyother
single character. 
   int gettoken(void)  /* return next token */
   {
       int c, getch(void);
       void ungetch(int);
       char *p = token;
       while ((c = getch()) == ' ' || c == '\t')
           ;
       if (c == '(') {
           if ((c = getch()) == ')') {
               strcpy(token, "()");
               return tokentype = PARENS;
           } else {
               ungetch(c);
               return tokentype = '(';104
           }
       } else if (c == '[') {
           for (*p++ = c; (*p++ = getch()) != ']'; )
               ;
           *p = '\0';
           return tokentype = BRACKETS;
       } else if (isalpha(c)) {
           for (*p++ = c; isalnum(c = getch()); )
               *p++ = c;
           *p = '\0';
           ungetch(c);
           return tokentype = NAME;
       } else
           return tokentype = c;
   }
getch  and ungetch  are discussed in Chapter 4 . 
Going intheother direction iseasier, especially ifwedonotworry about generating redundant
parentheses. Theprogramundcl converts aword description like``xisafunction returning a
pointer to an array of pointers to functions returning char ,'' which we will express as 
    x () * [] * () char
to 
   char (*(*x())[])()
The abbreviated input syntax letsusreuse thegettoken function. undcl also uses thesame
external variables as dcl does. 
   /* undcl:  convert word descriptions to declarations */
   main()
   {
       int type;
       char temp[MAXTOKEN];
       while (gettoken() != EOF) {
           strcpy(out, token);
           while ((type = gettoken()) != '\n')
               if (type == PARENS || type == BRACKETS)
                   strcat(out, token);
               else if (type == '*') {
                   sprintf(temp, "(*%s)", out);
                   strcpy(out, temp);
               } else if (type == NAME) {
                   sprintf(temp, "%s %s", token, out);
                   strcpy(out, temp);
               } else
                   printf("invalid input at %s\n", token);
       }
       return 0;
   }
Exercise 5-18.  Make dcl recover from input errors. 
Exercise 5-19.  Modify undcl  so that it does not add redundant parentheses to declarations. 
Exercise 5-20. Expanddcltohandle declarations with function argument types, qualifiers like
const , and so on. 105
Chapter 6 - Structures
Astructure isacollection ofone ormore variables, possibly ofdifferent types, grouped
together under asingle name forconvenient handling. (Structures arecalled ``records'' insome
languages, notably Pascal.) Structures help toorganize complicated data, particularly inlarge
programs, because they permit agroup ofrelated variables tobetreated asaunitinstead ofas
separate entities. 
One traditional example ofastructure isthepayroll record: anemployee isdescribed byaset
ofattributes such asname, address, social security number, salary, etc.Some ofthese inturn
could bestructures: aname hasseveral components, asdoes anaddress andeven asalary.
Another example, more typical forC,comes from graphics: apoint isapairofcoordinate, a
rectangle is a pair of points, and so on. 
The main change made by the ANSI standard is to define structure assignment - structures may
becopied and assigned to,passed tofunctions, and returned byfunctions. This hasbeen
supported bymost compilers formany years, buttheproperties arenow precisely defined.
Automatic structures and arrays may now also be initialized. 
6.1 Basics of Structures
Letuscreate afewstructures suitable forgraphics. Thebasic object isapoint, which wewill
assume has an x coordinate and a y coordinate, both integers. 
The two components can be placed in a structure declared like this: 
   struct point {
       int x;
       int y;
   };
The keyword struct  introduces a structure declaration, which is a list of declarations enclosed
inbraces. Anoptional name called astructure tagmay follow thewordstruct (aswithpoint
here). The tagnames thiskind ofstructure, andcanbeused subsequently asashorthand for
the part of the declaration in braces. 
The variables named inastructure arecalled members .Astructure member ortagandan
ordinary (i.e., non-member) variable canhave thesame name without conflict, since they can
always bedistinguished bycontext. Furthermore, thesame member names may occur in
different structures, although asamatter ofstyle onewould normally usethesame names only
for closely related objects. 
Astruct declaration defines atype. Theright brace thatterminates thelistofmembers may
be followed by a list of variables, just as for any basic type. That is, 106
   struct { ... } x, y, z;
is syntactically analogous to 
   int x, y, z;
inthesense that each statement declaresx,yandztobevariables ofthenamed type and
causes space to be set aside for them. 
Astructure declaration thatisnotfollowed byalistofvariables reserves nostorage; itmerely
describes atemplate orshape ofastructure. Ifthedeclaration istagged, however, thetagcan
beused later indefinitions ofinstances ofthestructure. Forexample, given thedeclaration of
point  above, 
   struct point pt;
defines avariableptwhich isastructure oftypestructpoint .Astructure canbeinitialized
byfollowing itsdefinition with alistofinitializers, each aconstant expression, forthe
members: 
   struct maxpt = { 320, 200 };
Anautomatic structure may also beinitialized byassignment orbycalling afunction that
returns a structure of the right type. 
A member of a particular structure is referred to in an expression by a construction of the form
  structure-name.member  
The structure member operator ``.''connects thestructure name andthemember name. To
print the coordinates of the point pt, for instance, 
   printf("%d,%d", pt.x, pt.y);
or to compute the distance from the origin (0,0) to pt, 
   double dist, sqrt(double);
   dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);
Structures canbenested. One representation ofarectangle isapairofpoints thatdenote the
diagonally opposite corners: 
   struct rect {
       struct point pt1;
       struct point pt2;
   };
The rect  structure contains two point  structures. If we declare screen  as 
   struct rect screen;
then 
   screen.pt1.x107
refers to the x coordinate of the pt1 member of screen . 
6.2 Structures and Functions
The only legal operations onastructure arecopying itorassigning toitasaunit, taking its
address with&,andaccessing itsmembers. Copy andassignment include passing arguments to
functions andreturning values from functions aswell. Structures may notbecompared. A
structure may beinitialized byalistofconstant member values; anautomatic structure may
also be initialized by an assignment. 
Letusinvestigate structures bywriting some functions tomanipulate points andrectangles.
There areatleast three possible approaches: pass components separately, pass anentire
structure, or pass a pointer to it. Each has its good points and bad points. 
The first function, makepoint , will take two integers and return a point  structure: 
   /* makepoint:  make a point from x and y components */
   struct point makepoint(int x, int y)
   {
       struct point temp;
       temp.x = x;
       temp.y = y;
       return temp;
   }
Notice that there isnoconflict between theargument name andthemember with thesame
name; indeed the re-use of the names stresses the relationship. 
makepoint cannow beused toinitialize anystructure dynamically, ortoprovide structure
arguments to a function: 
   struct rect screen;
   struct point middle;
   struct point makepoint(int, int);
   screen.pt1 = makepoint(0,0);
   screen.pt2 = makepoint(XMAX, YMAX);
   middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                      (screen.pt1.y + screen.pt2.y)/2);
The next step is a set of functions to do arithmetic on points. For instance, 
   /* addpoints:  add two points */
   struct addpoint(struct point p1, struct point p2)
   {
       p1.x += p2.x;
       p1.y += p2.y;
       return p1;
   }
Here both thearguments andthereturn value arestructures. Weincremented thecomponents
inp1rather than using anexplicit temporary variable toemphasize thatstructure parameters
are passed by value like any others. 
Asanother example, thefunctionptinrect tests whether apoint isinside arectangle, where
wehave adopted theconvention thatarectangle includes itsleftandbottom sides butnotits
top and right sides: 
   /* ptinrect:  return 1 if p in r, 0 if not */
   int ptinrect(struct point p, struct rect r)
   {
       return p.x >= r.pt1.x && p.x < r.pt2.x
           && p.y >= r.pt1.y && p.y < r.pt2.y;
   }108
This assumes thattherectangle ispresented inastandard form where thept1coordinates are
lessthan thept2coordinates. The following function returns arectangle guaranteed tobein
canonical form: 
   #define min(a, b) ((a) < (b) ? (a) : (b))
   #define max(a, b) ((a) > (b) ? (a) : (b))
   /* canonrect: canonicalize coordinates of rectangle */
   struct rect canonrect(struct rect r)
   {
       struct rect temp;
       temp.pt1.x = min(r.pt1.x, r.pt2.x);
       temp.pt1.y = min(r.pt1.y, r.pt2.y);
       temp.pt2.x = max(r.pt1.x, r.pt2.x);
       temp.pt2.y = max(r.pt1.y, r.pt2.y);
       return temp;
   }
Ifalarge structure istobepassed toafunction, itisgenerally more efficient topass apointer
than tocopy thewhole structure. Structure pointers arejustlikepointers toordinary variables.
The declaration 
   struct point *pp;
says thatppisapointer toastructure oftypestructpoint .Ifpppoints toapoint
structure, *pp isthestructure, and(*pp).x and(*pp).y arethemembers. Tousepp,we
might write, for example, 
   struct point origin, *pp;
   pp = &origin;
   printf("origin is (%d,%d)\n", (*pp).x, (*pp).y);
The parentheses arenecessary in(*pp).x because theprecedence ofthestructure member
operator .ishigher then*.The expression *pp.x means*(pp.x) ,which isillegal here
because x is not a pointer. 
Pointers tostructures aresofrequently used that analternative notation isprovided asa
shorthand. If p is a pointer to a structure, then 
   p->member-of-structure
refers to the particular member. So we could write instead 
   printf("origin is (%d,%d)\n", pp->x, pp->y);
Both . and -> associate from left to right, so if we have 
   struct rect r, *rp = &r;
then these four expressions are equivalent: 
   r.pt1.x
   rp->pt1.x
   (r.pt1).x
   (rp->pt1).x
Thestructure operators .and->,together with()forfunction calls and[]forsubscripts, are
atthetopoftheprecedence hierarchy and thus bind very tightly. Forexample, given the
declaration 
   struct {
       int len;
       char *str;
   } *p;
then 109
   ++p->len
increments len, not p, because the implied parenthesization is ++(p->len) . Parentheses can be
used toalter binding:(++p)->len increments pbefore accessing len,and(p++)->len
increments p afterward. (This last set of parentheses is unnecessary.) 
Inthesame way,*p->str fetches whatever strpoints to;*p->str++ increments strafter
accessing whatever itpoints to(just like*s++ );(*p->str)++ increments whatever strpoints
to; and *p++->str  increments p after accessing whatever str points to. 
6.3 Arrays of Structures
Consider writing aprogram tocount theoccurrences ofeach Ckeyword. Weneed anarray of
character strings tohold thenames, andanarray ofintegers forthecounts. One possibility is
to use two parallel arrays, keyword  and keycount , as in 
   char *keyword[NKEYS];
   int keycount[NKEYS];
But thevery fact that thearrays areparallel suggests adifferent organization, anarray of
structures. Each keyword is a pair: 
   char *word;
   int cout;
and there is an array of pairs. The structure declaration 
   struct key {
       char *word;
       int count;
   } keytab[NKEYS];
declares astructure typekey,defines anarraykeytab ofstructures ofthistype, andsetsaside
storage for them. Each element of the array is a structure. This could also be written 
   struct key {
       char *word;
       int count;
   };
   struct key keytab[NKEYS];
Since thestructure keytab contains aconstant setofnames, itiseasiest tomake itanexternal
variable and initialize itonce and forallwhen itisdefined. The structure initialization is
analogous to earlier ones - the definition is followed by a list of initializers enclosed in braces: 
   struct key {
       char *word;
       int count;
   } keytab[] = {
       "auto", 0,
       "break", 0,
       "case", 0,
       "char", 0,
       "const", 0,
       "continue", 0,
       "default", 0,
       /* ... */
       "unsigned", 0,
       "void", 0,
       "volatile", 0,
       "while", 0
   };
The initializers arelisted inpairs corresponding tothestructure members. Itwould bemore
precise to enclose the initializers for each "row" or structure in braces, as in 
   { "auto", 0 },110
   { "break", 0 },
   { "case", 0 },
   ...
but inner braces are not necessary when the initializers are simple variables or character strings,
andwhen allarepresent. Asusual, thenumber ofentries inthearraykeytab willbecomputed
if the initializers are present and the [] is left empty. 
The keyword counting program begins with thedefinition ofkeytab .Themain routine reads
theinput byrepeatedly calling afunctiongetword thatfetches oneword atatime. Each word
islooked upinkeytab with aversion ofthebinary search function thatwewrote inChapter 3 .
The list of keywords must be sorted in increasing order in the table. 
   #include <stdio.h>
   #include <ctype.h>
   #include <string.h>
   #define MAXWORD 100
   int getword(char *, int);
   int binsearch(char *, struct key *, int);
   /* count C keywords */
   main()
   {
       int n;
       char word[MAXWORD];
       while (getword(word, MAXWORD) != EOF)
           if (isalpha(word[0]))
               if ((n = binsearch(word, keytab, NKEYS)) >= 0)
                   keytab[n].count++;
       for (n = 0; n < NKEYS; n++)
           if (keytab[n].count > 0)
               printf("%4d %s\n",
                   keytab[n].count, keytab[n].word);
       return 0;
   }
   /* binsearch:  find word in tab[0]...tab[n-1] */
   int binsearch(char *word, struct key tab[], int n)
   {
       int cond;
       int low, high, mid;
       low = 0;
       high = n - 1;
       while (low <= high) {
           mid = (low+high) / 2;
           if ((cond = strcmp(word, tab[mid].word)) < 0)
               high = mid - 1;
           else if (cond > 0)
               low = mid + 1;
           else
               return mid;
       }
       return -1;
   }
Wewillshow thefunctiongetword inamoment; fornow itsuffices tosaythateach callto
getword  finds a word, which is copied into the array named as its first argument. 
The quantityNKEYS isthenumber ofkeywords inkeytab .Although wecould count thisby
hand, it'saloteasier andsafer todoitbymachine, especially ifthelistissubject tochange.
One possibility would betoterminate thelistofinitializers with anullpointer, then loop along
keytab  until the end is found. 111
Butthisismore than isneeded, since thesizeofthearray iscompletely determined atcompile
time. Thesizeofthearray isthesizeofoneentry times thenumber ofentries, sothenumber
of entries is just 
  size of  keytab / size of  struct key  
Cprovides acompile-time unary operator calledsizeof thatcanbeused tocompute thesize
of any object. The expressions 
   sizeof object
and 
   sizeof ( type name )
yield aninteger equal tothesize ofthespecified object ortype inbytes. (Strictly, sizeof
produces an unsigned integer value whose type, size_t , is defined in the header <stddef.h> .)
Anobject canbeavariable orarray orstructure. Atype name canbethename ofabasic type
like int or double , or a derived type like a structure or a pointer. 
Inourcase, thenumber ofkeywords isthesizeofthearray divided bythesizeofoneelement.
This computation is used in a #define  statement to set the value of NKEYS : 
   #define NKEYS (sizeof keytab / sizeof(struct key))
Another way to write this is to divide the array size by the size of a specific element: 
   #define NKEYS (sizeof keytab / sizeof(keytab[0]))
This has the advantage that it does not need to be changed if the type changes. 
Asizeof cannotbeused ina#ifline, because thepreprocessor does notparse type names.
Buttheexpression inthe#define isnotevaluated bythepreprocessor, sothecode here is
legal. 
Now forthefunctiongetword .Wehave written amore generalgetword than isnecessary for
thisprogram, butitisnotcomplicated. getword fetches thenext ``word'' from theinput,
where aword iseither astring ofletters anddigits beginning with aletter, orasingle non-
white space character. Thefunction value isthefirst character oftheword, orEOFforendof
file, or the character itself if it is not alphabetic. 
   /* getword:  get next word or character from input */
   int getword(char *word, int lim)
   {
       int c, getch(void);
       void ungetch(int);
       char *w = word;
       while (isspace(c = getch()))
           ;
       if (c != EOF)
           *w++ = c;
       if (!isalpha(c)) {
           *w = '\0';
           return c;
       }
       for ( ; --lim > 0; w++)
           if (!isalnum(*w = getch())) {
               ungetch(*w);
               break;
           }
       *w = '\0';
       return word[0];
   }112
getword uses thegetch andungetch thatwewrote inChapter 4 .When thecollection ofan
alphanumeric token stops,getword hasgone one character toofar.The calltoungetch
pushes thatcharacter back ontheinput forthenext call.getword also usesisspace toskip
whitespace, isalpha toidentify letters, andisalnum toidentify letters anddigits; allarefrom
the standard header <ctype.h> . 
Exercise 6-1. Ourversion ofgetword does notproperly handle underscores, string constants,
comments, or preprocessor control lines. Write a better version. 
6.4 Pointers to Structures
Toillustrate some oftheconsiderations involved with pointers toandarrays ofstructures, let
us write the keyword-counting program again, this time using pointers instead of array indices.
The external declaration ofkeytab need notchange, butmain andbinsearch doneed
modification. 
   #include <stdio.h>
   #include <ctype.h>
   #include <string.h>
   #define MAXWORD 100
   int getword(char *, int);
   struct key *binsearch(char *, struct key *, int);
   /* count C keywords; pointer version */
   main()
   {
       char word[MAXWORD];
       struct key *p;
       while (getword(word, MAXWORD) != EOF)
           if (isalpha(word[0]))
               if ((p=binsearch(word, keytab, NKEYS)) != NULL)
                   p->count++;
       for (p = keytab; p < keytab + NKEYS; p++)
           if (p->count > 0)
               printf("%4d %s\n", p->count, p->word);
       return 0;
   }
   /* binsearch: find word in tab[0]...tab[n-1] */
   struct key *binsearch(char *word, struck key *tab, int n)
   {
       int cond;
       struct key *low = &tab[0];
       struct key *high = &tab[n];
       struct key *mid;
       while (low < high) {
           mid = low + (high-low) / 2;
           if ((cond = strcmp(word, mid->word)) < 0)
               high = mid;
           else if (cond > 0)
               low = mid + 1;
           else
               return mid;
       }
       return NULL;
   }
There areseveral things worthy ofnote here. First, thedeclaration ofbinsearch must indicate
that itreturns apointer tostructkey instead ofaninteger; thisisdeclared both inthe113
function prototype andinbinsearch .Ifbinsearch finds theword, itreturns apointer toit;if
it fails, it returns NULL . 
Second, theelements ofkeytab arenow accessed bypointers. This requires significant
changes in binsearch . 
Theinitializers forlowandhigh arenow pointers tothebeginning andjustpast theendofthe
table. 
The computation of the middle element can no longer be simply 
   mid = (low+high) / 2    /* WRONG */
because theaddition ofpointers isillegal. Subtraction islegal, however, sohigh-low isthe
number of elements, and thus 
   mid = low + (high-low) / 2
sets mid to the element halfway between low and high . 
Themost important change istoadjust thealgorithm tomake sure thatitdoes notgenerate an
illegal pointer orattempt toaccess anelement outside thearray. Theproblem isthat&tab[-1]
and&tab[n] areboth outside thelimits ofthearraytab.Theformer isstrictly illegal, anditis
illegal todereference thelatter. Thelanguage definition does guarantee, however, thatpointer
arithmetic that involves thefirst element beyond theendofanarray (that is,&tab[n] )will
work correctly. 
In main  we wrote 
   for (p = keytab; p < keytab + NKEYS; p++)
Ifpisapointer toastructure, arithmetic onptakes intoaccount thesizeofthestructure, so
p++increments pbythecorrect amount togetthenext element ofthearray ofstructures, and
the test stops the loop at the right time. 
Don't assume, however, that thesize ofastructure isthesum ofthesizes ofitsmembers.
Because ofalignment requirements fordifferent objects, there may beunnamed ``holes'' ina
structure. Thus, for instance, if a char  is one byte and an int four bytes, the structure 
   struct {
       char c;
       int i;
   };
might well require eight bytes, not five. The sizeof  operator returns the proper value. 
Finally, anaside onprogram format: when afunction returns acomplicated type like a
structure pointer, as in 
   struct key *binsearch(char *word, struct key *tab, int n)
thefunction name canbehard tosee,andtofindwith atexteditor. Accordingly analternate
style is sometimes used: 
   struct key *
   binsearch(char *word, struct key *tab, int n)
This is a matter of personal taste; pick the form you like and hold to it. 
6.5 Self-referential Structures
Suppose wewant tohandle themore general problem ofcounting theoccurrences ofallthe
words insome input. Since thelistofwords isn'tknown inadvance, wecan't conveniently sort
itanduseabinary search. Yetwecan't doalinear search foreach word asitarrives, toseeif
it'salready been seen; theprogram would take toolong. (More precisely, itsrunning time is114
likely togrow quadratically with thenumber ofinput words.) How canweorganize thedata to
copy efficiently with a list or arbitrary words? 
One solution istokeep thesetofwords seen sofarsorted atalltimes, byplacing each word
intoitsproper position intheorder asitarrives. This shouldn't bedone byshifting words ina
linear array, though -that also takes toolong. Instead wewilluseadata structure called a
binary tree . 
The tree contains one ``node'' per distinct word; each node contains 
•A pointer to the text of the word, 
•A count of the number of occurrences, 
•A pointer to the left child node, 
•A pointer to the right child node. 
No node may have more than two children; it might have only zero or one. 
The nodes aremaintained sothat atanynode theleftsubtree contains only words that are
lexicographically lessthan theword atthenode, andtheright subtree contains only words that
aregreater. This isthetreeforthesentence ``now isthetime forallgood men tocome tothe
aid of their party'', as built by inserting each word as it is encountered: 
Tofindoutwhether anew word isalready inthetree, start attheroot andcompare thenew
word totheword stored atthatnode. Ifthey match, thequestion isanswered affirmatively. If
thenew record islessthan thetreeword, continue searching attheleftchild, otherwise atthe
right child. Ifthere isnochild intherequired direction, thenew word isnotinthetree, andin
facttheempty slotistheproper place toaddthenew word. This process isrecursive, since the
search from anynode uses asearch from oneofitschildren. Accordingly, recursive routines
for insertion and printing will be most natural. 
Going back tothedescription ofanode, itismost conveniently represented asastructure with
four components: 
   struct tnode {     /* the tree node: */
       char *word;           /* points to the text */
       int count;            /* number of occurrences */
       struct tnode *left;   /* left child */
       struct tnode *right;  /* right child */
   };
This recursive declaration ofanode might look chancy, butit'scorrect. Itisillegal fora
structure to contain an instance of itself, but 115
    struct tnode *left;
declares left  to be a pointer to a tnode , not a tnode  itself. 
Occasionally, oneneeds avariation ofself-referential structures: two structures that refer to
each other. The way to handle this is: 
   struct t {
       ...
       struct s *p;   /* p points to an s */
   };
   struct s {
       ...
       struct t *q;   /* q points to a t */
   };
The code forthewhole program issurprisingly small, given ahandful ofsupporting routines
likegetword that wehave already written. The main routine reads words withgetword and
installs them in the tree with addtree . 
   #include <stdio.h>
   #include <ctype.h>
   #include <string.h>
   #define MAXWORD 100
   struct tnode *addtree(struct tnode *, char *);
   void treeprint(struct tnode *);
   int getword(char *, int);
   /* word frequency count */
   main()
   {
       struct tnode *root;
       char word[MAXWORD];
       root = NULL;
       while (getword(word, MAXWORD) != EOF)
           if (isalpha(word[0]))
               root = addtree(root, word);
       treeprint(root);
       return 0;
   }
Thefunctionaddtree isrecursive. Aword ispresented bymain tothetoplevel (theroot) of
thetree. Ateach stage, thatword iscompared totheword already stored atthenode, andis
percolated down toeither theleftorright subtree byarecursive calltoadtree .Eventually,
theword either matches something already inthetree(inwhich case thecount isincremented),
or a null pointer is encountered, indicating that a node must be created and added to the tree. If
a new node is created, addtree  returns a pointer to it, which is installed in the parent node. 
   struct tnode *talloc(void);
   char *strdup(char *);
   /* addtree:  add a node with w, at or below p */
   struct treenode *addtree(struct tnode *p, char *w)
   {
       int cond;
       if (p == NULL) {     /* a new word has arrived */
           p = talloc();    /* make a new node */
           p->word = strdup(w);
           p->count = 1;
           p->left = p->right = NULL;
       } else if ((cond = strcmp(w, p->word)) == 0)
           p->count++;      /* repeated word */
       else if (cond < 0)   /* less than into left subtree */
           p->left = addtree(p->left, w);116
       else             /* greater than into right subtree */
           p->right = addtree(p->right, w);
       return p;
   }
Storage forthenew node isfetched byaroutinetalloc ,which returns apointer toafree
space suitable forholding atree node, andthenew word iscopied into ahidden space by
strdup .(We willdiscuss these routines inamoment.) The count isinitialized, andthetwo
children aremade null. This part ofthecode isexecuted only attheleaves ofthetree, when a
new node is being added. We have (unwisely) omitted error checking on the values returned by
strdup  and talloc . 
treeprint prints thetreeinsorted order; ateach node, itprints theleftsubtree (allthewords
lessthan thisword), then theword itself, then theright subtree (allthewords greater). Ifyou
feelshaky about how recursion works, simulatetreeprint asitoperates onthetree shown
above. 
   /* treeprint:  in-order print of tree p */
   void treeprint(struct tnode *p)
   {
       if (p != NULL) {
           treeprint(p->left);
           printf("%4d %s\n", p->count, p->word);
           treeprint(p->right);
       }
   }
Apractical note: ifthetreebecomes ``unbalanced'' because thewords don't arrive inrandom
order, therunning time oftheprogram cangrow toomuch. Asaworst case, ifthewords are
already inorder, this program does anexpensive simulation oflinear search. There are
generalizations ofthebinary treethatdonotsuffer from thisworst-case behavior, butwewill
not describe them here. 
Before leaving thisexample, itisalso worth abrief digression onaproblem related tostorage
allocators. Clearly it'sdesirable that there beonly onestorage allocator inaprogram, even
though itallocates different kinds ofobjects. Butifoneallocator istoprocess requests for,
say,pointers tochar sandpointers tostructtnode s,twoquestions arise. First, how does it
meet therequirement ofmost realmachines thatobjects ofcertain types must satisfy alignment
restrictions (for example, integers often must belocated ateven addresses)? Second, what
declarations cancope with thefactthatanallocator must necessarily return different kinds of
pointers? 
Alignment requirements cangenerally besatisfied easily, atthecost ofsome wasted space, by
ensuring thattheallocator always returns apointer that meets allalignment restrictions. The
alloc ofChapter 5 does notguarantee anyparticular alignment, sowewillusethestandard
library functionmalloc ,which does. InChapter 8 wewill show one way toimplement
malloc . 
The question ofthetype declaration forafunction likemalloc isavexing one forany
language that takes itstype-checking seriously. InC,theproper method istodeclare that
malloc returns apointer tovoid ,then explicitly coerce thepointer intothedesired type with a
cast.malloc and related routines aredeclared inthestandard header<stdlib.h> .Thus
talloc  can be written as 
   #include <stdlib.h>
   /* talloc:  make a tnode */
   struct tnode *talloc(void)
   {
       return (struct tnode *) malloc(sizeof(struct tnode));117
   }
strdup  merely copies the string given by its argument into a safe place, obtained by a call on
malloc : 
   char *strdup(char *s)   /* make a duplicate of s */
   {
       char *p;
       p = (char *) malloc(strlen(s)+1); /* +1 for '\0' */
       if (p != NULL)
           strcpy(p, s);
       return p;
   }
malloc returnsNULL ifnospace isavailable; strdup passes that value on,leaving error-
handling to its caller. 
Storage obtained bycallingmalloc may befreed forre-use bycallingfree ;seeChapters 8
and 7. 
Exercise 6-2. Write aprogram that reads aCprogram andprints inalphabetical order each
group ofvariable names that areidentical inthefirst 6characters, butdifferent somewhere
thereafter. Don't count words within strings and comments. Make 6 a parameter that can be set
from the command line. 
Exercise 6-3. Write across-referencer that prints alistofallwords inadocument, andfor
each word, alistofthelinenumbers onwhich itoccurs. Remove noise words like``the,''
``and,'' and so on. 
Exercise 6-4. Write aprogram thatprints thedistinct words initsinput sorted intodecreasing
order of frequency of occurrence. Precede each word by its count. 
6.6 Table Lookup
Inthissection wewillwrite theinnards ofatable-lookup package, toillustrate more aspects of
structures. This code istypical ofwhat might befound inthesymbol table management
routines ofamacro processor oracompiler. Forexample, consider the#define statement.
When a line like 
   #define  IN  1
isencountered, thenameINandthereplacement text1arestored inatable. Later, when the
name IN appears in a statement like 
   state = IN;
it must be replaced by 1. 
There aretwo routines that manipulate thenames and replacement texts.install(s,t)
records thenamesandthereplacement texttinatable;sandtarejustcharacter strings.
lookup(s)  searches for s in the table, and returns a pointer to the place where it was found, or
NULL  if it wasn't there. 
The algorithm isahash-search -theincoming name isconverted into asmall non-negative
integer, which isthen used toindex into anarray ofpointers. Anarray element points tothe
beginning ofalinked listofblocks describing names thathave thathash value. ItisNULL ifno
names have hashed to that value. 118
Ablock inthelistisastructure containing pointers tothename, thereplacement text, andthe
next block in the list. A null next-pointer marks the end of the list. 
   struct nlist {       /* table entry: */
       struct nlist *next;   /* next entry in chain */
       char *name;           /* defined name */
       char *defn;           /* replacement text */
   };
The pointer array is just 
   #define HASHSIZE 101
   static struct nlist *hashtab[HASHSIZE];  /* pointer table */
The hashing function, which is used by both lookup  and install , adds each character value in
thestring toascrambled combination oftheprevious ones andreturns theremainder modulo
the array size. This is not the best possible hash function, but it is short and effective. 
   /* hash:  form hash value for string s */
   unsigned hash(char *s)
   {
       unsigned hashval;
       for (hashval = 0; *s != '\0'; s++)
           hashval = *s + 31 * hashval;
       return hashval % HASHSIZE;
   }
Unsigned arithmetic ensures that the hash value is non-negative. 
Thehashing process produces astarting index inthearrayhashtab ;ifthestring istobefound
anywhere, itwillbeinthelistofblocks beginning there. Thesearch isperformed bylookup .If
lookup  finds the entry already present, it returns a pointer to it; if not, it returns NULL . 
   /* lookup:  look for s in hashtab */
   struct nlist *lookup(char *s)
   {
       struct nlist *np;
       for (np = hashtab[hash(s)];  np != NULL; np = np->next)
           if (strcmp(s, np->name) == 0)
               return np;     /* found */
       return NULL;           /* not found */
   }
The for loop in lookup  is the standard idiom for walking along a linked list: 
   for (ptr = head; ptr != NULL; ptr = ptr->next)
   ...
install useslookup todetermine whether thename being installed isalready present; ifso,
thenew definition willsupersede theoldone. Otherwise, anew entry iscreated.install
returns NULL  if for any reason there is no room for a new entry. 119
   struct nlist *lookup(char *);
   char *strdup(char *);
   /* install:  put (name, defn) in hashtab */
   struct nlist *install(char *name, char *defn)
   {
       struct nlist *np;
       unsigned hashval;
       if ((np = lookup(name)) == NULL) { /* not found */
           np = (struct nlist *) malloc(sizeof(*np));
           if (np == NULL || (np->name = strdup(name)) == NULL)
               return NULL;
           hashval = hash(name);
           np->next = hashtab[hashval];
           hashtab[hashval] = np;
       } else       /* already there */
           free((void *) np->defn);   /*free previous defn */
       if ((np->defn = strdup(defn)) == NULL)
           return NULL;
       return np;
   }
Exercise 6-5. Write afunctionundef that willremove aname anddefinition from thetable
maintained by lookup  and install . 
Exercise 6-6. Implement asimple version ofthe#define processor (i.e., noarguments)
suitable forusewith Cprograms, based ontheroutines ofthissection. You may also find
getch  and ungetch  helpful. 
6.7 Typedef
Cprovides afacility calledtypedef forcreating new data type names. For example, the
declaration 
   typedef int Length;
makes thenameLength asynonym forint.The typeLength canbeused indeclarations,
casts, etc., in exactly the same ways that the int type can be: 
   Length len, maxlen;
   Length *lengths[];
Similarly, the declaration 
   typedef char *String;
makesString asynonym forchar*orcharacter pointer, which may then beused in
declarations and casts: 
   String p, lineptr[MAXLINES], alloc(int);
   int strcmp(String, String);
   p = (String) malloc(100);
Notice that thetype being declared inatypedef appears intheposition ofavariable name,
notright after thewordtypedef .Syntactically, typedef islikethestorage classesextern ,
static , etc. We have used capitalized names for typedef s, to make them stand out. 
Asamore complicated example, wecould maketypedef sforthetreenodes shown earlier in
this chapter: 
   typedef struct tnode *Treeptr;
   typedef struct tnode { /* the tree node: */
       char *word;           /* points to the text */
       int count;            /* number of occurrences */
       struct tnode *left;   /* left child */120
       struct tnode *right;  /* right child */
   } Treenode;
This creates twonew type keywords calledTreenode (astructure) andTreeptr (apointer to
the structure). Then the routine talloc  could become 
   Treeptr talloc(void)
   {
       return (Treeptr) malloc(sizeof(Treenode));
   }
Itmust beemphasized thatatypedef declaration does notcreate anew type inanysense; it
merely adds anew name forsome existing type. Nor arethere anynew semantics: variables
declared thisway have exactly thesame properties asvariables whose declarations arespelled
outexplicitly. Ineffect,typedef islike#define ,except that since itisinterpreted bythe
compiler, itcan cope with textual substitutions that arebeyond thecapabilities ofthe
preprocessor. For example, 
   typedef int (*PFI)(char *, char *);
creates thetypePFI,for``pointer tofunction (oftwochar*arguments) returning int,''
which can be used in contexts like 
   PFI strcmp, numcmp;
in the sort program of Chapter 5 . 
Besides purely aesthetic issues, there aretwomain reasons forusingtypedef s.Thefirst isto
parameterize aprogram against portability problems. Iftypedef sareused fordata types that
may bemachine-dependent, only thetypedef sneed change when theprogram ismoved. One
common situation istousetypedef names forvarious integer quantities, then make an
appropriate setofchoices ofshort ,int,andlong foreach host machine. Types likesize_t
and ptrdiff_t  from the standard library are examples. 
The second purpose oftypedef sistoprovide better documentation foraprogram -atype
calledTreeptr may beeasier tounderstand than one declared only asapointer toa
complicated structure. 
6.8 Unions
Aunion isavariable thatmay hold (atdifferent times) objects ofdifferent types andsizes, with
thecompiler keeping track ofsize and alignment requirements. Unions provide away to
manipulate different kinds ofdata inasingle area ofstorage, without embedding anymachine-
dependent information in the program. They are analogous to variant records in pascal. 
Asanexample such asmight befound inacompiler symbol table manager, suppose that a
constant may beanint,afloat ,oracharacter pointer. The value ofaparticular constant
must bestored inavariable oftheproper type, yetitismost convenient fortable management
ifthevalue occupies thesame amount ofstorage andisstored inthesame place regardless of
itstype. This isthepurpose ofaunion -asingle variable thatcanlegitimately hold anyofone
of several types. The syntax is based on structures: 
   union u_tag {
       int ival;
       float fval;
       char *sval;
   } u;
The variableuwillbelarge enough tohold thelargest ofthethree types; thespecific sizeis
implementation-dependent. Any ofthese types may beassigned touand then used in
expressions, solong astheusage isconsistent: thetype retrieved must bethetype most
recently stored. Itistheprogrammer's responsibility tokeep track ofwhich type iscurrently121
stored inaunion; theresults areimplementation-dependent ifsomething isstored asonetype
and extracted as another. 
Syntactically, members of a union are accessed as 
  union-name .member  
or 
  union-pointer ->member  
justasforstructures. Ifthevariableutype isused tokeep track ofthecurrent type stored inu,
then one might see code such as 
   if (utype == INT)
       printf("%d\n", u.ival);
   if (utype == FLOAT)
       printf("%f\n", u.fval);
   if (utype == STRING)
       printf("%s\n", u.sval);
   else
       printf("bad type %d in utype\n", utype);
Unions may occur within structures andarrays, andvice versa. The notation foraccessing a
member ofaunion inastructure (orvice versa) isidentical tothatfornested structures. For
example, in the structure array defined by 
   struct {
       char *name;
       int flags;
       int utype;
       union {
           int ival;
           float fval;
           char *sval;
       } u;
   } symtab[NSYM];
the member ival  is referred to as 
   symtab[i].u.ival
and the first character of the string sval  by either of 
   *symtab[i].u.sval
   symtab[i].u.sval[0]
Ineffect, aunion isastructure inwhich allmembers have offset zero from thebase, the
structure isbigenough tohold the``widest'' member, andthealignment isappropriate forall
ofthetypes intheunion. The same operations arepermitted onunions asonstructures:
assignment to or copying as a unit, taking the address, and accessing a member. 
Aunion may only beinitialized with avalue ofthetype ofitsfirst member; thus unionu
described above can only be initialized with an integer value. 
The storage allocator inChapter 8 shows how aunion canbeused toforce avariable tobe
aligned on a particular kind of storage boundary. 
6.9 Bit-fields
When storage space isatapremium, itmay benecessary topack several objects intoasingle
machine word; onecommon useisasetofsingle-bit flags inapplications likecompiler symbol
tables. Externally-imposed data formats, such asinterfaces tohardware devices, also often
require the ability to get at pieces of a word. 122
Imagine afragment ofacompiler thatmanipulates asymbol table. Each identifier inaprogram
hascertain information associated with it,forexample, whether ornotitisakeyword, whether
ornotitisexternal and/or static, and soon.The most compact way toencode such
information is a set of one-bit flags in a single char  or int. 
The usual way thisisdone istodefine asetof``masks'' corresponding totherelevant bit
positions, as in 
   #define KEYWORD  01
   #define EXTRENAL 02
   #define STATIC   04
or 
   enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
The numbers must bepowers oftwo. Then accessing thebitsbecomes amatter of``bit-
fiddling'' with theshifting, masking, and complementing operators that were described in
Chapter 2 . 
Certain idioms appear frequently: 
   flags |= EXTERNAL | STATIC;
turns on the EXTERNAL  and STATIC  bits in flags , while 
   flags &= ~(EXTERNAL | STATIC);
turns them off, and 
   if ((flags & (EXTERNAL | STATIC)) == 0) ...
is true if both bits are off. 
Although these idioms arereadily mastered, asanalternative Coffers thecapability ofdefining
andaccessing fields within aword directly rather than bybitwise logical operators. Abit-field ,
orfield forshort, isasetofadjacent bitswithin asingle implementation-defined storage unit
thatwewillcalla``word.'' Forexample, thesymbol table#define sabove could bereplaced
by the definition of three fields: 
   struct {
       unsigned int is_keyword : 1;
       unsigned int is_extern  : 1;
       unsigned int is_static  : 1;
   } flags;
This defines avariable table calledflags thatcontains three 1-bit fields. Thenumber following
thecolon represents thefield width inbits. The fields aredeclaredunsigned inttoensure
that they are unsigned quantities. 
Individual fields are referenced inthe same way asother structure members:
flags.is_keyword ,flags.is_extern ,etc. Fields behave like small integers, and may
participate inarithmetic expressions justlikeother integers. Thus theprevious examples may
be written more naturally as 
   flags.is_extern = flags.is_static = 1;
to turn the bits on; 
   flags.is_extern = flags.is_static = 0;
to turn them off; and 
   if (flags.is_extern == 0 && flags.is_static == 0)
       ...
to test them. 123
Almost everything about fields isimplementation-dependent. Whether afield may overlap a
word boundary isimplementation-defined. Fields need notbenames; unnamed fields (acolon
andwidth only) areused forpadding. The special width 0may beused toforce alignment at
the next word boundary. 
Fields areassigned lefttoright onsome machines andright toleftonothers. This means that
although fields areuseful formaintaining internally-defined data structures, thequestion of
which endcomes first hastobecarefully considered when picking apart externally-defined
data; programs that depend onsuch things arenotportable. Fields may bedeclared only as
ints;forportability, specifysigned orunsigned explicitly. They arenotarrays andthey do
not have addresses, so the & operator cannot be applied on them. 124
Chapter 7 - Input and Output
Input andoutput arenotpartoftheClanguage itself, sowehave notemphasized them inour
presentation thus far.Nonetheless, programs interact with their environment inmuch more
complicated ways than those wehave shown before. Inthis chapter wewill describe the
standard library, asetoffunctions that provide input andoutput, string handling, storage
management, mathematical routines, andavariety ofother services forCprograms. Wewill
concentrate on input and output 
The ANSI standard defines these library functions precisely, sothat they can exist in
compatible form onanysystem where Cexists. Programs thatconfine their system interactions
tofacilities provided bythestandard library canbemoved from onesystem toanother without
change. 
Theproperties oflibrary functions arespecified inmore than adozen headers; wehave already
seen several ofthese, including <stdio.h> ,<string.h> ,and<ctype.h> .Wewillnotpresent
theentire library here, since wearemore interested inwriting Cprograms that useit.The
library is described in detail in Appendix B . 
7.1 Standard Input and Output
AswesaidinChapter 1 ,thelibrary implements asimple model oftextinput andoutput. Atext
stream consists ofasequence oflines; each lineends with anewline character. Ifthesystem
doesn't operate thatway, thelibrary does whatever necessary tomake itappear asifitdoes.
Forinstance, thelibrary might convert carriage return andlinefeed tonewline oninput and
back again on output. 
The simplest input mechanism istoread one character atatime from thestandard input ,
normally the keyboard, with getchar : 
   int getchar(void)
getchar returns thenext input character each time itiscalled, orEOFwhen itencounters end
offile.Thesymbolic constantEOFisdefined in<stdio.h> .Thevalue istypically -1,bustests
should be written in terms of EOF so as to be independent of the specific value. 
Inmany environments, afilemay besubstituted forthekeyboard byusing the<convention for
input redirection: if a program prog  uses getchar , then the command line 
   prog <infile
causesprog toread characters frominfile instead. Theswitching oftheinput isdone insuch
away thatprog itself isoblivious tothechange; inparticular, thestring ``<infile ''isnot
included inthecommand-line arguments inargv .Input switching isalso invisible iftheinput
comes from another program via a pipe mechanism: on some systems, the command line 
   otherprog | prog
runs thetwoprograms otherprog andprog ,andpipes thestandard output ofotherprog into
the standard input for prog . 
The function 
   int putchar(int)
isused foroutput:putchar(c) puts thecharacter conthestandard output ,which isby
default thescreen.putchar returns thecharacter written, orEOF isanerror occurs. Again,
output can usually be directed to a file with > filename : if prog  uses putchar , 125
   prog >outfile
will write the standard output to outfile  instead. If pipes are supported, 
   prog | anotherprog
puts the standard output of prog  into the standard input of anotherprog . 
Output produced byprintf also finds itsway tothestandard output. Calls toputchar and
printf  may be interleaved - output happens in the order in which the calls are made. 
Each source file that refers to an input/output library function must contain the line 
   #include <stdio.h>
before thefirst reference. When thename isbracketed by<and>asearch ismade forthe
header inastandard setofplaces (forexample, onUNIX systems, typically inthedirectory
/usr/include ). 
Many programs read only one input stream and write only one output stream; forsuch
programs, input andoutput withgetchar ,putchar ,andprintf may beentirely adequate,
andiscertainly enough togetstarted. This isparticularly true ifredirection isused toconnect
theoutput ofoneprogram totheinput ofthenext. Forexample, consider theprogramlower ,
which converts its input to lower case: 
   #include <stdio.h>
   #include <ctype.h>
   main() /* lower: convert input to lower case*/
   {
       int c
       while ((c = getchar()) != EOF)
           putchar(tolower(c));
       return 0;
   }
Thefunctiontolower isdefined in<ctype.h> ;itconverts anupper case letter tolower case,
andreturns other characters untouched. Aswementioned earlier, ``functions'' likegetchar
andputchar in<stdio.h> andtolower in<ctype.h> areoften macros, thus avoiding the
overhead ofafunction callpercharacter. Wewill show how thisisdone inSection 8.5 .
Regardless ofhow the<ctype.h> functions areimplemented onagiven machine, programs
that use them are shielded from knowledge of the character set. 
Exercise 7-1. Write aprogram that converts upper case tolower orlower case toupper,
depending on the name it is invoked with, as found in argv[0] . 
7.2 Formatted Output - printf
The output functionprintf translates internal values tocharacters. Wehave usedprintf
informally inprevious chapters. The description here covers most typical uses butisnot
complete; for the full story, see Appendix B . 
   int printf(char *format, arg1, arg2, ...);
printf converts, formats, andprints itsarguments onthestandard output under control ofthe
format . It returns the number of characters printed. 
The format string contains twotypes ofobjects: ordinary characters, which arecopied tothe
output stream, andconversion specifications, each ofwhich causes conversion andprinting of
thenext successive argument toprintf .Each conversion specification begins with a%and
ends with aconversion character. Between the%andtheconversion character there may be,
in order: 126
•A minus sign, which specifies left adjustment of the converted argument. 
•Anumber that specifies theminimum field width. The converted argument will be
printed inafield atleast thiswide. Ifnecessary itwillbepadded ontheleft(orright, if
left adjustment is called for) to make up the field width. 
•A period, which separates the field width from the precision. 
•A number, the precision, that specifies the maximum number of characters to be printed
from astring, orthenumber ofdigits after thedecimal point ofafloating-point value,
or the minimum number of digits for an integer. 
•An h if the integer is to be printed as a short , or l (letter ell) if as a long . 
Conversion characters areshown inTable 7.1.Ifthecharacter after the%isnotaconversion
specification, the behavior is undefined. 
Table 7.1  Basic Printf Conversions  
Character Argument type; Printed As 
d,i int; decimal number
o int; unsigned octal number (without a leading zero)
x,Xint; unsigned hexadecimal number (without a leading 0x or 0X), using abcdef  or
ABCDEF  for 10, ...,15.
u int; unsigned decimal number
c int; single character
schar * ; print characters from the string until a '\0'  or the number of characters
given by the precision.
fdouble ; [-]m.dddddd , where the number of d's is given by the precision (default
6).
e,Edouble ; [-]m.dddddd e+/- xx or [-]m.dddddd E+/- xx, where the number of d's
is given by the precision (default 6).
g,Gdouble ; use %e or %E if the exponent is less than -4 or greater than or equal to the
precision; otherwise use %f. Trailing zeros and a trailing decimal point are not
printed.
p void * ; pointer (implementation-dependent representation).
% no argument is converted; print a %
Awidth orprecision may bespecified as*,inwhich case thevalue iscomputed byconverting
thenext argument (which must beanint).Forexample, toprint atmostmaxcharacters from
a string s, 
   printf("%.*s", max, s);
Most oftheformat conversions have been illustrated inearlier chapters. One exception isthe
precision asitrelates tostrings. The following table shows theeffect ofavariety of
specifications inprinting ``hello, world'' (12characters). Wehave putcolons around each field
so you can see it extent. 
   :%s:          :hello, world:
   :%10s:        :hello, world:
   :%.10s:       :hello, wor:
   :%-10s:       :hello, world:
   :%.15s:       :hello, world:
   :%-15s:       :hello, world   :
   :%15.10s:     :     hello, wor:
   :%-15.10s:    :hello, wor     :127
Awarning: printf uses itsfirst argument todecide how many arguments follow andwhat
their type is.Itwillgetconfused, andyouwillgetwrong answers, ifthere arenotenough
arguments ofifthey arethewrong type. You should also beaware ofthedifference between
these two calls: 
   printf(s);         /* FAILS if s contains % */
   printf("%s", s);   /* SAFE */
The functionsprintf does thesame conversions asprintf does, butstores theoutput ina
string: 
   int sprintf(char *string, char *format, arg1, arg2, ...);
sprintf formats thearguments inarg1 ,arg2 ,etc., according toformat asbefore, butplaces
theresult instring instead ofthestandard output;string must bebigenough toreceive the
result. 
Exercise 7-2. Write aprogram thatwillprint arbitrary input inasensible way. Asaminimum,
itshould print non-graphic characters inoctal orhexadecimal according tolocal custom, and
break long text lines. 
7.3 Variable-length Argument Lists
This section contains animplementation ofaminimal version ofprintf ,toshow how towrite
afunction thatprocesses avariable-length argument listinaportable way. Since wearemainly
interested intheargument processing, minprintf willprocess theformat string andarguments
but will call the real printf  to do the format conversions. 
The proper declaration for printf  is 
   int printf(char *fmt, ...)
where thedeclaration ...means thatthenumber andtypes ofthese arguments may vary. The
declaration ... can only appear at the end of an argument list. Our minprintf  is declared as 
   void minprintf(char *fmt, ...)
since we will not return the character count that printf  does. 
Thetricky bitishowminprintf walks along theargument listwhen thelistdoesn't even have
aname. Thestandard header<stdarg.h> contains asetofmacro definitions thatdefine how
tostep through anargument list.Theimplementation ofthisheader willvary from machine to
machine, but the interface it presents is uniform. 
The typeva_list isused todeclare avariable that willrefer toeach argument inturn; in
minprintf ,thisvariable iscalledap,for``argument pointer.'' Themacrova_start initializes
aptopoint tothefirst unnamed argument. Itmust becalled once beforeapisused. There
must beatleast onenamed argument; thefinal named argument isused byva_start toget
started. 
Each callofva_arg returns oneargument andstepsaptothenext;va_arg uses atype name
todetermine what type toreturn andhow bigastep totake. Finally,va_end does whatever
cleanup is necessary. It must be called before the program returns. 
These properties form the basis of our simplified printf : 
   #include <stdarg.h>
   /* minprintf: minimal printf with variable argument list */
   void minprintf(char *fmt, ...)
   {
       va_list ap; /* points to each unnamed arg in turn */
       char *p, *sval;128
       int ival;
       double dval;
       va_start(ap, fmt); /* make ap point to 1st unnamed arg */
       for (p = fmt; *p; p++) {
           if (*p != '%') {
               putchar(*p);
               continue;
           }
           switch (*++p) {
           case 'd':
               ival = va_arg(ap, int);
               printf("%d", ival);
               break;
           case 'f':
               dval = va_arg(ap, double);
               printf("%f", dval);
               break;
           case 's':
               for (sval = va_arg(ap, char *); *sval; sval++)
                   putchar(*sval);
               break;
           default:
               putchar(*p);
               break;
           }
       }
       va_end(ap); /* clean up when done */
   }
Exercise 7-3.  Revise minprintf  to handle more of the other facilities of printf . 
7.4 Formatted Input - Scanf
The functionscanf istheinput analog ofprintf ,providing many ofthesame conversion
facilities in the opposite direction. 
   int scanf(char *format, ...)
scanf reads characters from thestandard input, interprets them according tothespecification
informat ,andstores theresults through theremaining arguments. The format argument is
described below; theother arguments, each ofwhich must beapointer ,indicate where the
corresponding converted input should bestored. Aswithprintf ,thissection isasummary of
the most useful features, not an exhaustive list. 
scanf stops when itexhausts itsformat string, orwhen some input fails tomatch thecontrol
specification. Itreturns asitsvalue thenumber ofsuccessfully matched andassigned input
items. This canbeused todecide how many items were found. Ontheendoffile,EOF is
returned; note thatthisisdifferent from 0,which means thatthenext input character does not
match thefirst specification intheformat string. The next calltoscanf resumes searching
immediately after the last character already converted. 
There is also a function sscanf  that reads from a string instead of the standard input: 
   int sscanf(char *string, char *format, arg1, arg2, ...)
Itscans thestring according totheformat informat andstores theresulting values through
arg1 , arg2 , etc. These arguments must be pointers. 
The format string usually contains conversion specifications, which areused tocontrol
conversion of input. The format string may contain: 
•Blanks or tabs, which are not ignored. 129
•Ordinary characters (not %),which areexpected tomatch thenext non-white space
character of the input stream. 
•Conversion specifications, consisting ofthecharacter %,anoptional assignment
suppression character *,anoptional number specifying amaximum field width, an
optional h, l or L indicating the width of the target, and a conversion character. 
Aconversion specification directs theconversion ofthenext input field. Normally theresult is
places inthevariable pointed tobythecorresponding argument. Ifassignment suppression is
indicated bythe*character, however, theinput field isskipped; noassignment ismade. An
input field isdefined asastring ofnon-white space characters; itextends either tothenext
white space character oruntil thefield width, isspecified, isexhausted. This implies thatscanf
will read across boundaries tofind itsinput, since newlines arewhite space. (White space
characters are blank, tab, newline, carriage return, vertical tab, and formfeed.) 
The conversion character indicates theinterpretation oftheinput field. The corresponding
argument must beapointer, asrequired bythecall-by-value semantics ofC.Conversion
characters are shown in Table 7.2. 
Table 7.2:  Basic Scanf Conversions  
Character Input Data; Argument type 
d decimal integer; int *
iinteger; int * . The integer may be in octal (leading 0) or hexadecimal (leading
0x or 0X).
o octal integer (with or without leading zero); int *
u unsigned decimal integer; unsigned int *
x hexadecimal integer (with or without leading 0x or 0X); int *
ccharacters; char * . The next input characters (default 1) are placed at the
indicated spot. The normal skip-over white space is suppressed; to read the next
non-white space character, use %1s
scharacter string (not quoted); char * , pointing to an array of characters long
enough for the string and a terminating '\0'  that will be added.
e,f,gfloating-point number with optional sign, optional decimal point and optional
exponent; float *
% literal %; no assignment is made.
Theconversion characters d,i,o,u,andxmay bepreceded byhtoindicate thatapointer to
short rather thanintappears intheargument list,orbyl(letter ell)toindicate thatapointer
to long  appears in the argument list. 
Asafirst example, therudimentary calculator ofChapter 4 canbewritten withscanf todo
the input conversion: 
   #include <stdio.h>
   main()  /* rudimentary calculator */
   {
       double sum, v;
       sum = 0;
       while (scanf("%lf", &v) == 1)
           printf("\t%.2f\n", sum += v);
       return 0;
   }
Suppose we want to read input lines that contain dates of the form 130
   25 Dec 1988
The scanf  statement is 
   int day, year;
   char monthname[20];
   scanf("%d %s %d", &day, monthname, &year);
No & is used with monthname , since an array name is a pointer. 
Literal characters canappear inthescanf format string; they must match thesame characters
in the input. So we could read dates of the form mm/dd/yy  with the scanf  statement: 
   int day, month, year;
   scanf("%d/%d/%d", &month, &day, &year);
scanf ignores blanks andtabs initsformat string. Furthermore, itskips over white space
(blanks, tabs, newlines, etc.) asitlooks forinput values. Toread input whose format isnot
fixed, itisoften best toread alineatatime, then pick itapart withscanf .Forexample,
suppose wewant toread lines thatmight contain adate ineither oftheforms above. Then we
could write 
   while (getline(line, sizeof(line)) > 0) {
       if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
           printf("valid: %s\n", line); /* 25 Dec 1988 form */
       else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
           printf("valid: %s\n", line); /* mm/dd/yy form */
       else
           printf("invalid: %s\n", line); /* invalid form */
   }
Calls toscanf canbemixed with calls toother input functions. The next calltoanyinput
function will begin by reading the first character not read by scanf . 
Afinal warning: thearguments toscanf andsscanf must bepointers. Byfarthemost
common error is writing 
   scanf("%d", n);
instead of 
   scanf("%d", &n);
This error is not generally detected at compile time. 
Exercise 7-4. Write aprivate version ofscanf analogous tominprintf from theprevious
section. 
Exercise 5-5. Rewrite thepostfix calculator ofChapter 4 tousescanf and/orsscanf todo
the input and number conversion. 
7.5 File Access
The examples so far have all read the standard input and written the standard output, which are
automatically defined for a program by the local operating system. 
The next step istowrite aprogram that accesses afilethat isnotalready connected tothe
program. One program thatillustrates theneed forsuch operations iscat,which concatenates
asetofnamed filesintothestandard output.catisused forprinting files onthescreen, andas
a general-purpose input collector for programs that do not have the capability of accessing files
by name. For example, the command 
   cat x.c y.c131
prints the contents of the files x.c and y.c (and nothing else) on the standard output. 
The question ishow toarrange forthenamed files toberead -that is,how toconnect the
external names that a user thinks of to the statements that read the data. 
The rules aresimple. Before itcanberead orwritten, afilehastobeopened bythelibrary
functionfopen .fopen takes anexternal name likex.cory.c,does some housekeeping and
negotiation with theoperating system (details ofwhich needn't concern us), andreturns a
pointer to be used in subsequent reads or writes of the file. 
This pointer, called thefilepointer ,points toastructure that contains information about the
file,such asthelocation ofabuffer, thecurrent character position inthebuffer, whether the
fileisbeing read orwritten, andwhether errors orendoffilehave occurred. Users don't need
toknow thedetails, because thedefinitions obtained from<stdio.h> include astructure
declaration called FILE . The only declaration needed for a file pointer is exemplified by 
   FILE *fp;
   FILE *fopen(char *name, char *mode);
This says thatfpisapointer toaFILE ,andfopen returns apointer toaFILE .Notice that
FILE isatype name, likeint,notastructure tag;itisdefined with atypedef .(Details ofhow
fopen  can be implemented on the UNIX system are given in Section 8.5 .) 
The call to fopen  in a program is 
   fp = fopen(name, mode);
The first argument offopen isacharacter string containing thename ofthefile.Thesecond
argument isthemode ,also acharacter string, which indicates how oneintends tousethefile.
Allowable modes include read ("r"),write ("w"),andappend ("a").Some systems distinguish
between text and binary files; for the latter, a "b" must be appended to the mode string. 
Ifafilethatdoes notexist isopened forwriting orappending, itiscreated ifpossible. Opening
an existing file for writing causes the old contents to be discarded, while opening for appending
preserves them. Trying toread afilethat does notexist isanerror, andthere may beother
causes oferror aswell, liketrying toread afilewhen youdon't have permission. Ifthere isany
error,fopen willreturnNULL .(The error canbeidentified more precisely; seethediscussion of
error-handling functions at the end of Section 1 in Appendix B .) 
Thenext thing needed isaway toread orwrite thefileonce itisopen.getc returns thenext
character from a file; it needs the file pointer to tell it which file. 
   int getc(FILE *fp)
getc returns thenext character from thestream referred tobyfp;itreturnsEOFforendoffile
or error. 
putc  is an output function: 
   int putc(int c, FILE *fp)
putc writes thecharacter ctothefilefpandreturns thecharacter written, orEOF ifanerror
occurs. Like getchar  and putchar , getc  and putc  may be macros instead of functions. 
When aCprogram isstarted, theoperating system environment isresponsible foropening
three files andproviding pointers forthem. These files arethestandard input, thestandard
output, andthestandard error; thecorresponding filepointers arecalledstdin ,stdout ,and
stderr ,andaredeclared in<stdio.h> .Normally stdin isconnected tothekeyboard and
stdout andstderr areconnected tothescreen, butstdin andstdout may beredirected to
files or pipes as described in Section 7.1 . 132
getchar  and putchar  can be defined in terms of getc , putc , stdin , and stdout  as follows: 
   #define getchar()    getc(stdin)
   #define putchar(c)   putc((c), stdout)
Forformatted input oroutput offiles, thefunctions fscanf andfprintf may beused. These
areidentical toscanf andprintf ,except thatthefirstargument isafilepointer thatspecifies
the file to be read or written; the format string is the second argument. 
   int fscanf(FILE *fp, char *format, ...)
   int fprintf(FILE *fp, char *format, ...)
With these preliminaries outoftheway, wearenow inaposition towrite theprogramcatto
concatenate files. The design isonethat hasbeen found convenient formany programs. If
there arecommand-line arguments, they areinterpreted asfilenames, andprocessed inorder. If
there are no arguments, the standard input is processed. 
   #include <stdio.h>
   /* cat:  concatenate files, version 1 */
   main(int argc, char *argv[])
   {
       FILE *fp;
       void filecopy(FILE *, FILE *)
       if (argc == 1) /* no args; copy standard input */
           filecopy(stdin, stdout);
       else
          while(--argc > 0)
              if ((fp = fopen(*++argv, "r")) == NULL) {
                  printf("cat: can't open %s\n, *argv);
                  return 1;
              } else {
                 filecopy(fp, stdout);
                 fclose(fp);
              }
          return 0;
   }
    /* filecopy:  copy file ifp to file ofp */
    void filecopy(FILE *ifp, FILE *ofp)
    {
        int c;
        while ((c = getc(ifp)) != EOF)
            putc(c, ofp);
    }
Thefilepointersstdin andstdout areobjects oftypeFILE*.They areconstants, however,
not variables, so it is not possible to assign to them. 
The function 
   int fclose(FILE *fp)
istheinverse offopen ,itbreaks theconnection between thefilepointer andtheexternal name
that was established byfopen ,freeing thefilepointer foranother file.Since most operating
systems have some limit onthenumber offiles thataprogram may have open simultaneously,
it'sagood idea tofree thefilepointers when they arenolonger needed, aswedidincat.
There isalso another reason forfclose onanoutput file-itflushes thebuffer inwhichputc
iscollecting output.fclose iscalled automatically foreach open filewhen aprogram
terminates normally. (You canclosestdin andstdout ifthey arenotneeded. They canalso
be reassigned by the library function freopen .) 
7.6 Error Handling - Stderr and Exit133
The treatment oferrors incat isnotideal. The trouble isthat ifone ofthefiles can't be
accessed forsome reason, thediagnostic isprinted attheendoftheconcatenated output. That
might beacceptable iftheoutput isgoing toascreen, butnotifit'sgoing into afileorinto
another program via a pipeline. 
Tohandle this situation better, asecond output stream, calledstderr ,isassigned toa
program inthesame way thatstdin andstdout are. Output written onstderr normally
appears on the screen even if the standard output is redirected. 
Let us revise cat to write its error messages on the standard error. 
   #include <stdio.h>
   /* cat:  concatenate files, version 2 */
   main(int argc, char *argv[])
   {
       FILE *fp;
       void filecopy(FILE *, FILE *);
       char *prog = argv[0];  /* program name for errors */
       if (argc == 1 ) /* no args; copy standard input */
           filecopy(stdin, stdout);
       else
           while (--argc > 0)
               if ((fp = fopen(*++argv, "r")) == NULL) {
                   fprintf(stderr, "%s: can't open %s\n",
                           prog, *argv);
                   exit(1);
               } else {
                   filecopy(fp, stdout);
                   fclose(fp);
               }
       if (ferror(stdout)) {
           fprintf(stderr, "%s: error writing stdout\n", prog);
           exit(2);
       }
       exit(0);
   }
The program signals errors intwo ways. First, thediagnostic output produced byfprintf
goes to stderr , so it finds its way to the screen instead of disappearing down a pipeline or into
anoutput file. Weincluded theprogram name, fromargv[0] ,inthemessage, soifthis
program is used with others, the source of an error is identified. 
Second, theprogram uses thestandard library function exit ,which terminates program
execution when itiscalled. Theargument ofexit isavailable towhatever process called this
one, sothesuccess orfailure oftheprogram canbetested byanother program thatuses this
one asasub-process. Conventionally, areturn value of0signals that alliswell; non-zero
values usually signal abnormal situations. exit callsfclose foreach open output file,toflush
out any buffered output. 
Withinmain ,return expr isequivalent toexit (expr).exit hastheadvantage thatitcanbe
called from other functions, andthatcalls toitcanbefound with apattern-searching program
like those in Chapter 5 . 
The function ferror  returns non-zero if an error occurred on the stream fp. 
   int ferror(FILE *fp)
Although output errors arerare, they dooccur (forexample, ifadisk fillsup), soaproduction
program should check this as well. 134
The functionfeof(FILE *)isanalogous toferror ;itreturns non-zero ifendoffilehas
occurred on the specified file. 
   int feof(FILE *fp)
Wehave generally notworried about exitstatus inoursmall illustrative programs, butany
serious program should take care to return sensible, useful status values. 
7.7 Line Input and Output
Thestandard library provides aninput andoutput routinefgets thatissimilar tothegetline
function that we have used in earlier chapters: 
   char *fgets(char *line, int maxline, FILE *fp)
fgets reads thenext input line(including thenewline) from filefpinto thecharacter array
line ;atmostmaxline-1 characters willberead. The resulting lineisterminated with'\0' .
Normally fgets returnsline ;onendoffileorerror itreturnsNULL .(Ourgetline returns the
line length, which is a more useful value; zero means end of file.) 
For output, the function fputs  writes a string (which need not contain a newline) to a file: 
   int fputs(char *line, FILE *fp)
It returns EOF if an error occurs, and non-negative otherwise. 
The library functions gets andputs aresimilar tofgets andfputs ,butoperate onstdin
and stdout . Confusingly, gets  deletes the terminating '\n' , and puts  adds it. 
Toshow that there isnothing special about functions likefgets andfputs ,here they are,
copied from the standard library on our system: 
   /* fgets:  get at most n chars from iop */
   char *fgets(char *s, int n, FILE *iop)
   {
       register int c;
       register char *cs;
       cs = s;
       while (--n > 0 && (c = getc(iop)) != EOF)
           if ((*cs++ = c) == '\n')
               break;
       *cs = '\0';
       return (c == EOF && cs == s) ? NULL : s;
   }
   /* fputs:  put string s on file iop */
   int fputs(char *s, FILE *iop)
   {
       int c;
       while (c = *s++)
           putc(c, iop);
       return ferror(iop) ? EOF : 0;
   }
For no obvious reason, the standard specifies different return values for ferror  and fputs . 
It is easy to implement our getline  from fgets : 
   /* getline:  read a line, return length */
   int getline(char *line, int max)
   {
       if (fgets(line, max, stdin) == NULL)
           return 0;
       else135
           return strlen(line);
   }
Exercise 7-6.  Write a program to compare two files, printing the first line where they differ. 
Exercise 7-7. Modify thepattern finding program ofChapter 5 totake itsinput from asetof
named files or,ifnofiles arenamed asarguments, from thestandard input. Should thefile
name be printed when a matching line is found? 
Exercise 7-8. Write aprogram toprint asetoffiles, starting each new oneonanew page,
with a title and a running page count for each file. 
7.8 Miscellaneous Functions
Thestandard library provides awide variety offunctions. This section isabrief synopsis ofthe
most useful. More details and many other functions can be found in Appendix B . 
7.8.1 String Operations
Wehave already mentioned thestring functions strlen ,strcpy ,strcat ,andstrcmp ,found
in <string.h> . In the following, s and t are char * 's, and c and n are ints. 
strcat(s,t)  concatenate t to end of s
strncat(s,t,n) concatenate n characters of t to end of s
strcmp(s,t)  return negative, zero, or positive for s < t , s == t , s > t
strncmp(s,t,n) same as strcmp  but only in first n characters
strcpy(s,t)  copy t to s
strncpy(s,t,n) copy at most n characters of t to s
strlen(s)  return length of s
strchr(s,c)  return pointer to first c in s, or NULL  if not present
strrchr(s,c)  return pointer to last c in s, or NULL  if not present
7.8.2 Character Class Testing and Conversion
Several functions from<ctype.h> perform character tests andconversions. Inthefollowing, c
is an int that can be represented as an unsigned char  or EOF. The function returns int. 
isalpha(c) non-zero if c is alphabetic, 0 if not
isupper(c) non-zero if c is upper case, 0 if not
islower(c) non-zero if c is lower case, 0 if not
isdigit(c) non-zero if c is digit, 0 if not
isalnum(c) non-zero if isalpha(c)  or isdigit(c) , 0 if not
isspace(c) non-zero if c is blank, tab, newline, return, formfeed, vertical tab
toupper(c) return c converted to upper case
tolower(c) return c converted to lower case
7.8.3 Ungetc
Thestandard library provides arather restricted version ofthefunctionungetch thatwewrote
in Chapter 4 ; it is called ungetc . 
   int ungetc(int c, FILE *fp)
pushes thecharacter cback onto filefp,andreturns eitherc,orEOFforanerror. Only one
character ofpushback isguaranteed perfile.ungetc may beused with anyoftheinput
functions like scanf , getc , or getchar . 
7.8.4 Command Execution
The functionsystem(char *s) executes thecommand contained inthecharacter strings,
then resumes execution ofthecurrent program. Thecontents ofsdepend strongly onthelocal
operating system. As a trivial example, on UNIX systems, the statement 
   system("date");136
causes theprogramdate toberun; itprints thedate andtime ofdayonthestandard output.
system returns asystem-dependent integer status from thecommand executed. IntheUNIX
system, the status return is the value returned by exit . 
7.8.5 Storage Management
The functions malloc  and calloc  obtain blocks of memory dynamically. 
   void *malloc(size_t n)
returns a pointer to n bytes of uninitialized storage, or NULL  if the request cannot be satisfied. 
   void *calloc(size_t n, size_t size)
returns apointer toenough freespace foranarray ofnobjects ofthespecified size, orNULL if
the request cannot be satisfied. The storage is initialized to zero. 
Thepointer returned bymalloc orcalloc hastheproper alignment fortheobject inquestion,
but it must be cast into the appropriate type, as in 
   int *ip;
   ip = (int *) calloc(n, sizeof(int));
free(p) frees thespace pointed tobyp,wherepwasoriginally obtained byacalltomalloc
orcalloc .There arenorestrictions ontheorder inwhich space isfreed, butitisaghastly
error to free something not obtained by calling malloc  or calloc . 
Itisalsoanerror tousesomething after ithasbeen freed. Atypical butincorrect piece ofcode
is this loop that frees items from a list: 
   for (p = head; p != NULL; p = p->next) /* WRONG */
       free(p);
The right way is to save whatever is needed before freeing: 
   for (p = head; p != NULL; p = q) {
       q = p->next;
       free(p);
   }
Section 8.7 shows theimplementation ofastorage allocator likemalloc ,inwhich allocated
blocks may be freed in any order. 
7.8.6 Mathematical Functions
There aremore than twenty mathematical functions declared in<math.h> ;here aresome of
the more frequently used. Each takes one or two double  arguments and returns a double . 
sin(x)  sine of x, x in radians
cos(x)  cosine of x, x in radians
atan2(y,x) arctangent of y/x, in radians
exp(x)  exponential function ex
log(x)  natural (base e) logarithm of x (x>0)
log10(x)  common (base 10) logarithm of x (x>0)
pow(x,y)  xy
sqrt(x)  square root of x (x>0)
fabs(x)  absolute value of x
7.8.7 Random Number generation
The function rand()  computes a sequence of pseudo-random integers in the range zero to
RAND_MAX , which is defined in <stdlib.h> . One way to produce random floating-point
numbers greater than or equal to zero but less than one is 
   #define frand() ((double) rand() / (RAND_MAX+1.0))137
(If your library already provides a function for floating-point random numbers, it is likely to
have better statistical properties than this one.) 
The functionsrand(unsigned) setstheseed forrand .Theportable implementation ofrand
and srand  suggested by the standard appears in Section 2.7 . 
Exercise 7-9. Functions likeisupper canbeimplemented tosave space ortosave time.
Explore both possibilities. 138
Chapter 8 - The UNIX System Interface
The UNIX operating system provides itsservices through asetofsystem calls ,which arein
effect functions within theoperating system thatmay becalled byuser programs. This chapter
describes how tousesome ofthemost important system calls from Cprograms. Ifyouuse
UNIX, thisshould bedirectly helpful, foritissometimes necessary toemploy system calls for
maximum efficiency, ortoaccess some facility thatisnotinthelibrary. Even ifyouuseCona
different operating system, however, youshould beable toglean insight into Cprogramming
from studying these examples; although details vary, similar code willbefound onanysystem.
Since theANSI Clibrary isinmany cases modeled onUNIX facilities, thiscode may help your
understanding of the library as well. 
This chapter isdivided intothree major parts: input/output, filesystem, andstorage allocation.
The first two parts assume amodest familiarity with theexternal characteristics ofUNIX
systems. 
Chapter 7 was concerned with aninput/output interface that isuniform across operating
systems. Onanyparticular system theroutines ofthestandard library have tobewritten in
terms ofthefacilities provided bythehost system. Inthenext fewsections wewilldescribe the
UNIX system calls forinput andoutput, andshow how parts ofthestandard library canbe
implemented with them. 
8.1 File Descriptors
IntheUNIX operating system, allinput andoutput isdone byreading orwriting files, because
allperipheral devices, even keyboard andscreen, arefiles inthefilesystem. This means thata
single homogeneous interface handles allcommunication between aprogram andperipheral
devices. 
Inthemost general case, before youread andwrite afile,youmust inform thesystem ofyour
intent todoso,aprocess called opening thefile.Ifyouaregoing towrite onafileitmay also
be necessary to create it or to discard its previous contents. The system checks your right to do
so(Does thefileexist? Doyouhave permission toaccess it?)andifalliswell, returns tothe
program asmall non-negative integer called afiledescriptor .Whenever input oroutput isto
bedone onthefile,thefiledescriptor isused instead ofthename toidentify thefile.(Afile
descriptor isanalogous tothefilepointer used bythestandard library, ortothefilehandle of
MS-DOS.) Allinformation about anopen fileismaintained bythesystem; theuser program
refers to the file only by the file descriptor. 
Since input andoutput involving keyboard andscreen issocommon, special arrangements
exist tomake thisconvenient. When thecommand interpreter (the ``shell'') runs aprogram,
three files areopen, with filedescriptors 0,1,and2,called thestandard input, thestandard
output, andthestandard error. Ifaprogram reads 0andwrites 1and2,itcandoinput and
output without worrying about opening files. 
The user of a program can redirect I/O to and from files with < and >: 
   prog <infile >outfile
Inthiscase, theshell changes thedefault assignments forthefiledescriptors 0and1tothe
named files. Normally filedescriptor 2remains attached tothescreen, soerror messages can
gothere. Similar observations hold forinput oroutput associated with apipe. Inallcases, the
fileassignments arechanged bytheshell, notbytheprogram. The program does notknow
where itsinput comes from norwhere itsoutput goes, solong asituses file0forinput and1
and 2 for output. 139
8.2 Low Level I/O - Read and Write
Input andoutput uses theread andwrite system calls, which areaccessed from Cprograms
through twofunctions calledread andwrite .Forboth, thefirstargument isafiledescriptor.
The second argument isacharacter array inyour program where thedata istogotoorto
come from. The third argument is the number is the number of bytes to be transferred. 
   int n_read = read(int fd, char *buf, int n);
   int n_written = write(int fd, char *buf, int n);
Each callreturns acount ofthenumber ofbytes transferred. Onreading, thenumber ofbytes
returned may belessthan thenumber requested. Areturn value ofzero bytes implies endof
file,and-1indicates anerror ofsome sort. Forwriting, thereturn value isthenumber ofbytes
written; an error has occurred if this isn't equal to the number requested. 
Any number ofbytes canberead orwritten inonecall. Themost common values are1,which
means one character atatime (``unbuffered''), and anumber like 1024 or4096 that
corresponds toaphysical block sizeonaperipheral device. Larger sizes willbemore efficient
because fewer system calls will be made. 
Putting these facts together, wecanwrite asimple program tocopy itsinput toitsoutput, the
equivalent ofthefilecopying program written forChapter 1 .This program willcopy anything
to anything, since the input and output can be redirected to any file or device. 
   #include "syscalls.h"
   main()  /* copy input to output */
   {
       char buf[BUFSIZ];
       int n;
       while ((n = read(0, buf, BUFSIZ)) > 0)
           write(1, buf, n);
       return 0;
   }
Wehave collected function prototypes forthesystem calls intoafilecalledsyscalls.h sowe
can include it in the programs of this chapter. This name is not standard, however. 
The parameter BUFSIZ isalso defined insyscalls.h ;itsvalue isagood size forthelocal
system. Ifthefilesizeisnotamultiple ofBUFSIZ ,someread willreturn asmaller number of
bytes to be written by write ; the next call to read  after that will return zero. 
Itisinstructive toseehowread andwrite canbeused toconstruct higher-level routines like
getchar ,putchar ,etc.Forexample, here isaversion ofgetchar thatdoes unbuffered input,
by reading the standard input one character at a time. 
   #include "syscalls.h"
   /* getchar:  unbuffered single character input */
   int getchar(void)
   {
       char c;
       return (read(0, &c, 1) == 1) ? (unsigned char) c : EOF;
   }
cmust beachar ,becauseread needs acharacter pointer. Castingctounsigned char inthe
return statement eliminates any problem of sign extension. 
Thesecond version ofgetchar does input inbigchunks, andhands outthecharacters oneata
time. 140
   #include "syscalls.h"
   /* getchar:  simple buffered version */
   int getchar(void)
   {
       static char buf[BUFSIZ];
       static char *bufp = buf;
       static int n = 0;
       if (n == 0) {  /* buffer is empty */
           n = read(0, buf, sizeof buf);
           bufp = buf;
       }
       return (--n >= 0) ? (unsigned char) *bufp++ : EOF;
   }
Ifthese versions ofgetchar were tobecompiled with<stdio.h> included, itwould be
necessary to #undef  the name getchar  in case it is implemented as a macro. 
8.3 Open, Creat, Close, Unlink
Other than thedefault standard input, output anderror, youmust explicitly open files inorder
to read or write them. There are two system calls for this, open  and creat  [sic]. 
open israther likethefopen discussed inChapter 7 ,except that instead ofreturning afile
pointer, it returns a file descriptor, which is just an int. open  returns -1 if any error occurs. 
   #include <fcntl.h>
   int fd;
   int open(char *name, int flags, int perms);
   fd = open(name, flags, perms);
Aswithfopen ,thename argument isacharacter string containing thefilename. The second
argument, flags , is an int that specifies how the file is to be opened; the main values are 
O_RDONLY open for reading only
O_WRONLY open for writing only
O_RDWR open for both reading and writing
These constants aredefined in<fcntl.h> onSystem VUNIX systems, andin<sys/file.h>
on Berkeley (BSD) versions. 
To open an existing file for reading, 
   fd = open(name, O_RDONLY,0);
The perms  argument is always zero for the uses of open  that we will discuss. 
Itisanerror totrytoopen afilethat does notexist. The system callcreat isprovided to
create new files, or to re-write old ones. 
   int creat(char *name, int perms);
   fd = creat(name, perms);
returns afiledescriptor ifitwasable tocreate thefile,and-1ifnot.Ifthefilealready exists,
creat willtruncate ittozero length, thereby discarding itsprevious contents; itisnotanerror
to creat  a file that already exists. 
Ifthefiledoes notalready exist,creat creates itwith thepermissions specified bytheperms
argument. IntheUNIX filesystem, there arenine bitsofpermission information associated
with afilethatcontrol read, write andexecute access fortheowner ofthefile,fortheowner's
group, andforallothers. Thus athree-digit octal number isconvenient forspecifying the141
permissions. Forexample, 0775 specifies read, write andexecute permission fortheowner,
and read and execute permission for the group and everyone else. 
Toillustrate, here isasimplified version oftheUNIX programcp,which copies onefileto
another. Our version copies only onefile, itdoes notpermit thesecond argument tobea
directory, and it invents permissions instead of copying them. 
   #include <stdio.h>
   #include <fcntl.h>
   #include "syscalls.h"
   #define PERMS 0666     /* RW for owner, group, others */
   void error(char *,  ...);
   /* cp:  copy f1 to f2 */
   main(int argc, char *argv[])
   {
       int f1, f2, n;
       char buf[BUFSIZ];
       if (argc != 3)
           error("Usage: cp from to");
       if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
           error("cp: can't open %s", argv[1]);
       if ((f2 = creat(argv[2], PERMS)) == -1)
           error("cp: can't create %s, mode %03o",
               argv[2], PERMS);
       while ((n = read(f1, buf, BUFSIZ)) > 0)
           if (write(f2, buf, n) != n)
               error("cp: write error on file %s", argv[2]);
       return 0;
   }
This program creates the output file with fixed permissions of 0666 . With the stat  system call,
described inSection 8.6 ,wecandetermine themode ofanexisting fileandthus give thesame
mode to the copy. 
Notice that thefunctionerror iscalled with variable argument lists much likeprintf .The
implementation oferror illustrates how touseanother member oftheprintf family. The
standard library functionvprintf islikeprintf except that thevariable argument listis
replaced byasingle argument that hasbeen initialized bycalling theva_start macro.
Similarly, vfprintf  and vsprintf  match fprintf  and sprintf . 
   #include <stdio.h>
   #include <stdarg.h>
   /* error:  print an error message and die */
   void error(char *fmt, ...)
   {
       va_list args;
       va_start(args, fmt);
       fprintf(stderr, "error: ");
       vprintf(stderr, fmt, args);
       fprintf(stderr, "\n");
       va_end(args);
       exit(1);
   }
There isalimit (often about 20) onthenumber offiles that aprogram may open
simultaneously. Accordingly, anyprogram thatintends toprocess many files must beprepared
tore-use filedescriptors. The functionclose(int fd)breaks theconnection between afile
descriptor and anopen file, and frees thefiledescriptor forusewith some other file; it142
corresponds tofclose inthestandard library except that there isnobuffer toflush.
Termination of a program via exit  or return from the main program closes all open files. 
Thefunctionunlink(char *name) removes thefilename from thefilesystem. Itcorresponds
to the standard library function remove . 
Exercise 8-1. Rewrite theprogramcatfrom Chapter 7 usingread ,write ,open ,andclose
instead oftheir standard library equivalents. Perform experiments todetermine therelative
speeds of the two versions. 
8.4 Random Access - Lseek
Input andoutput arenormally sequential: eachread orwrite takes place ataposition inthe
fileright after theprevious one. When necessary, however, afilecanberead orwritten inany
arbitrary order. Thesystem calllseek provides away tomove around inafilewithout reading
or writing any data: 
   long lseek(int fd, long offset, int origin);
setsthecurrent position inthefilewhose descriptor isfdtooffset ,which istaken relative to
thelocation specified byorigin .Subsequent reading orwriting willbegin atthat position.
origin canbe0,1,or2tospecify thatoffset istobemeasured from thebeginning, from the
current position, orfrom theendofthefilerespectively. Forexample, toappend toafile(the
redirection >> in the UNIX shell, or "a" for fopen ), seek to the end before writing: 
   lseek(fd, 0L, 2);
To get back to the beginning (``rewind''), 
   lseek(fd, 0L, 0);
Notice the0Largument; itcould also bewritten as(long)0orjustas0iflseek isproperly
declared. 
Withlseek ,itispossible totreat files more orlesslikearrays, attheprice ofslower access.
Forexample, thefollowing function reads anynumber ofbytes from anyarbitrary place ina
file. It returns the number read, or -1 on error. 
   #include "syscalls.h"
   /*get:  read n bytes from position pos */
   int get(int fd, long pos, char *buf, int n)
   {
       if (lseek(fd, pos, 0) >= 0) /* get to pos */
           return read(fd, buf, n);
       else
           return -1;
   }
Thereturn value fromlseek isalong thatgives thenew position inthefile,or-1ifanerror
occurs. Thestandard library functionfseek issimilar tolseek except thatthefirst argument
is a FILE *  and the return is non-zero if an error occurred. 
8.5 Example - An implementation of Fopen and Getc
Letusillustrate how some ofthese pieces fittogether byshowing animplementation ofthe
standard library routines fopen  and getc . 
Recall thatfilesinthestandard library aredescribed byfilepointers rather than filedescriptors.
Afilepointer isapointer toastructure thatcontains several pieces ofinformation about the
file: apointer toabuffer, sothefilecanberead inlarge chunks; acount ofthenumber of
characters leftinthebuffer; apointer tothenext character position inthebuffer; thefile
descriptor; and flags describing read/write mode, error status, etc. 143
Thedata structure thatdescribes afileiscontained in<stdio.h> ,which must beincluded (by
#include )inanysource filethatuses routines from thestandard input/output library. Itisalso
included byfunctions inthatlibrary. Inthefollowing excerpt from atypical<stdio.h> ,names
thatareintended foruseonly byfunctions ofthelibrary begin with anunderscore sothey are
lesslikely tocollide with names inauser's program. This convention isused byallstandard
library routines. 
   #define NULL      0
   #define EOF       (-1)
   #define BUFSIZ    1024
   #define OPEN_MAX  20    /* max #files open at once */
   typedef struct _iobuf {
       int  cnt;       /* characters left */
       char *ptr;      /* next character position */
       char *base;     /* location of buffer */
       int  flag;      /* mode of file access */
       int  fd;        /* file descriptor */
   } FILE;
   extern FILE _iob[OPEN_MAX];
   #define stdin   (&_iob[0])
   #define stdout  (&_iob[1])
   #define stderr  (&_iob[2])
   enum _flags {
       _READ   = 01,   /* file open for reading */
       _WRITE  = 02,   /* file open for writing */
       _UNBUF  = 04,   /* file is unbuffered */
       _EOF    = 010,  /* EOF has occurred on this file */
       _ERR    = 020   /* error occurred on this file */
   };
   int _fillbuf(FILE *);
   int _flushbuf(int, FILE *);
   #define feof(p)     ((p)->flag & _EOF) != 0)
   #define ferror(p)   ((p)->flag & _ERR) != 0)
   #define fileno(p)   ((p)->fd)
   #define getc(p)   (--(p)->cnt >= 0 \
                  ? (unsigned char) *(p)->ptr++ : _fillbuf(p))
   #define putc(x,p) (--(p)->cnt >= 0 \
                  ? *(p)->ptr++ = (x) : _flushbuf((x),p))
   #define getchar()   getc(stdin)
   #define putcher(x)  putc((x), stdout)
Thegetc macro normally decrements thecount, advances thepointer, and returns the
character. (Recall that along#define iscontinued with abackslash.) Ifthecount goes
negative, however, getc calls thefunction_fillbuf toreplenish thebuffer, re-initialize the
structure contents, and return acharacter. The characters arereturned unsigned ,which
ensures that all characters will be positive. 
Although wewillnotdiscuss anydetails, wehave included thedefinition ofputc toshow that
itoperates inmuch thesame way asgetc ,calling afunction_flushbuf when itsbuffer isfull.
Wehave also included macros foraccessing theerror and end-of-file status and thefile
descriptor. 
The functionfopen cannow bewritten. Most offopen isconcerned with getting thefile
opened andpositioned attheright place, andsetting theflagbitstoindicate theproper state.
fopen  does not allocate any buffer space; this is done by _fillbuf  when the file is first read. 144
   #include <fcntl.h>
   #include "syscalls.h"
   #define PERMS 0666    /* RW for owner, group, others */
   FILE *fopen(char *name, char *mode)
   {
       int fd;
       FILE *fp;
       if (*mode != 'r' && *mode != 'w' && *mode != 'a')
           return NULL;
       for (fp = _iob; fp < _iob + OPEN_MAX; fp++)
           if ((fp->flag & (_READ | _WRITE)) == 0)
               break;        /* found free slot */
       if (fp >= _iob + OPEN_MAX)   /* no free slots */
           return NULL;
       if (*mode == 'w')
           fd = creat(name, PERMS);
       else if (*mode == 'a') {
           if ((fd = open(name, O_WRONLY, 0)) == -1)
               fd = creat(name, PERMS);
           lseek(fd, 0L, 2);
       } else
           fd = open(name, O_RDONLY, 0);
       if (fd == -1)         /* couldn't access name */
           return NULL;
       fp->fd = fd;
       fp->cnt = 0;
       fp->base = NULL;
       fp->flag = (*mode == 'r') ? _READ : _WRITE;
       return fp;
   }
This version offopen does nothandle alloftheaccess mode possibilities ofthestandard,
though adding them would nottake much code. Inparticular, ourfopen does notrecognize
the``b''thatsignals binary access, since thatismeaningless onUNIX systems, northe``+''that
permits both reading and writing. 
The first calltogetc foraparticular filefinds acount ofzero, which forces acall of
_fillbuf .If_fillbuf finds thatthefileisnotopen forreading, itreturnsEOFimmediately.
Otherwise, it tries to allocate a buffer (if reading is to be buffered). 
Once thebuffer isestablished, _fillbuf callsread tofillit,setsthecount andpointers, and
returns thecharacter atthebeginning ofthebuffer. Subsequent calls to_fillbuf willfinda
buffer allocated. 
   #include "syscalls.h"
   /* _fillbuf:  allocate and fill input buffer */
   int _fillbuf(FILE *fp)
   {
       int bufsize;
       if ((fp->flag&(_READ|_EOF_ERR)) != _READ)
           return EOF;
       bufsize = (fp->flag & _UNBUF) ? 1 : BUFSIZ;
       if (fp->base == NULL)     /* no buffer yet */
           if ((fp->base = (char *) malloc(bufsize)) == NULL)
               return EOF;       /* can't get buffer */
       fp->ptr = fp->base;
       fp->cnt = read(fp->fd, fp->ptr, bufsize);
       if (--fp->cnt < 0) {
           if (fp->cnt == -1)
               fp->flag |= _EOF;145
           else
               fp->flag |= _ERR;
           fp->cnt = 0;
           return EOF;
       }
       return (unsigned char) *fp->ptr++;
   }
Theonly remaining loose endishow everything gets started. Thearray_iob must bedefined
and initialized for stdin , stdout  and stderr : 
   FILE _iob[OPEN_MAX] = {    /* stdin, stdout, stderr */
       { 0, (char *) 0, (char *) 0, _READ, 0 },
       { 0, (char *) 0, (char *) 0, _WRITE, 1 },
       { 0, (char *) 0, (char *) 0, _WRITE, | _UNBUF, 2 }
   };
Theinitialization oftheflag partofthestructure shows thatstdin istoberead,stdout isto
be written, and stderr  is to be written unbuffered. 
Exercise 8-2. Rewritefopen and_fillbuf with fields instead ofexplicit bitoperations.
Compare code size and execution speed. 
Exercise 8-3.  Design and write _flushbuf , fflush , and fclose . 
Exercise 8-4.  The standard library function 
   int fseek(FILE *fp, long offset, int origin)
isidentical tolseek except thatfpisafilepointer instead ofafiledescriptor andreturn value
isanintstatus, notaposition. Writefseek .Make sure thatyourfseek coordinates properly
with the buffering done for the other functions of the library. 
8.6 Example - Listing Directories
Adifferent kind offilesystem interaction issometimes called for-determining information
about afile,notwhat itcontains. Adirectory-listing program such astheUNIX command ls
isanexample -itprints thenames offiles inadirectory, and, optionally, other information,
such as sizes, permissions, and so on. The MS-DOS dir command is analogous. 
Since aUNIX directory isjustafile,lsneed only read ittoretrieve thefilenames. Butisis
necessary touseasystem calltoaccess other information about afile,such asitssize. On
other systems, asystem callmay beneeded even toaccess filenames; thisisthecase onMS-
DOS forinstance. What wewant isprovide access totheinformation inarelatively system-
independent way, even though the implementation may be highly system-dependent. 
Wewillillustrate some ofthisbywriting aprogram calledfsize .fsize isaspecial form of
lsthatprints thesizes ofallfiles named initscommandline argument list.Ifoneofthefiles is
adirectory, fsize applies itself recursively tothatdirectory. Ifthere arenoarguments atall,it
processes the current directory. 
Letusbegin with ashort review ofUNIX filesystem structure. Adirectory isafilethat
contains alistoffilenames andsome indication ofwhere they arelocated. The``location'' isan
index into another table called the``inode list.'' The inode forafileiswhere allinformation
about thefileexcept itsname iskept. Adirectory entry generally consists ofonly two items,
the filename and an inode number. 
Regrettably, theformat andprecise contents ofadirectory arenotthesame onallversions of
thesystem. Sowewilldivide thetask intotwopieces totrytoisolate thenon-portable parts.
Theouter level defines astructure called aDirent andthree routinesopendir ,readdir ,and
closedir toprovide system-independent access tothename andinode number inadirectory
entry. Wewillwritefsize with thisinterface. Then wewillshow how toimplement these on146
systems thatusethesame directory structure asVersion 7andSystem VUNIX; variants are
left as exercises. 
TheDirent structure contains theinode number andthename. The maximum length ofa
filename component isNAME_MAX ,which isasystem-dependent value.opendir returns a
pointer toastructure calledDIR,analogous toFILE ,which isused byreaddir andclosedir .
This information is collected into a file called dirent.h . 
   #define NAME_MAX   14  /* longest filename component; */
                                  /* system-dependent */
   typedef struct {       /* portable directory entry */
       long ino;                  /* inode number */
       char name[NAME_MAX+1];     /* name + '\0' terminator */
   } Dirent;
   typedef struct {       /* minimal DIR: no buffering, etc. */
       int fd;               /* file descriptor for the directory */
       Dirent d;             /* the directory entry */
   } DIR;
   DIR *opendir(char *dirname);
   Dirent *readdir(DIR *dfd);
   void closedir(DIR *dfd);
The system callstat takes afilename andreturns alloftheinformation intheinode forthat
file, or -1 if there is an error. That is, 
   char *name;
   struct stat stbuf;
   int stat(char *, struct stat *);
   stat(name, &stbuf);
fillsthestructure stbuf with theinode information forthefilename. Thestructure describing
the value returned by stat  is in <sys/stat.h> , and typically looks like this: 
   struct stat   /* inode information returned by stat */
   {
       dev_t     st_dev;      /* device of inode */
       ino_t     st_ino;      /* inode number */
       short     st_mode;     /* mode bits */
       short     st_nlink;    /* number of links to file */
       short     st_uid;      /* owners user id */
       short     st_gid;      /* owners group id */
       dev_t     st_rdev;     /* for special files */
       off_t     st_size;     /* file size in characters */
       time_t    st_atime;    /* time last accessed */
       time_t    st_mtime;    /* time last modified */
       time_t    st_ctime;    /* time originally created */
   };
Most ofthese values areexplained bythecomment fields. Thetypes likedev_t andino_t are
defined in <sys/types.h> , which must be included too. 
Thest_mode entry contains asetofflags describing thefile. The flag definitions arealso
included in <sys/types.h> ; we need only the part that deals with file type: 
   #define S_IFMT    0160000  /* type of file: */
   #define S_IFDIR   0040000  /* directory */
   #define S_IFCHR   0020000  /* character special */
   #define S_IFBLK   0060000  /* block special */
   #define S_IFREG   0010000  /* regular */
   /* ... */147
Now weareready towrite theprogramfsize .Ifthemode obtained fromstat indicates that
afileisnotadirectory, then thesizeisathand andcanbeprinted directly. Ifthename isa
directory, however, then wehave toprocess that directory onefileatatime; itmay inturn
contain sub-directories, so the process is recursive. 
Themain routine deals with command-line arguments; ithands each argument tothefunction
fsize . 
   #include <stdio.h>
   #include <string.h>
   #include "syscalls.h"
   #include <fcntl.h>      /* flags for read and write */
   #include <sys/types.h>  /* typedefs */
   #include <sys/stat.h>   /* structure returned by stat */
   #include "dirent.h"
   void fsize(char *)
   /* print file name */
   main(int argc, char **argv)
   {
       if (argc == 1)  /* default: current directory */
           fsize(".");
       else
           while (--argc > 0)
               fsize(*++argv);
       return 0;
   }
The functionfsize prints thesizeofthefile.Ifthefileisadirectory, however, fsize first
callsdirwalk tohandle allthefiles init.Note how theflagnamesS_IFMT andS_IFDIR are
used todecide ifthefileisadirectory. Parenthesization matters, because theprecedence of&is
lower than that of ==. 
   int stat(char *, struct stat *);
   void dirwalk(char *, void (*fcn)(char *));
   /* fsize:  print the name of file "name" */
   void fsize(char *name)
   {
       struct stat stbuf;
       if (stat(name, &stbuf) == -1) {
           fprintf(stderr, "fsize: can't access %s\n", name);
           return;
       }
       if ((stbuf.st_mode & S_IFMT) == S_IFDIR)
           dirwalk(name, fsize);
       printf("%8ld %s\n", stbuf.st_size, name);
   }
Thefunctiondirwalk isageneral routine thatapplies afunction toeach fileinadirectory. It
opens thedirectory, loops through thefiles init,calling thefunction oneach, then closes the
directory and returns. Since fsize  calls dirwalk  on each directory, the two functions call each
other recursively. 
   #define MAX_PATH 1024
   /* dirwalk:  apply fcn to all files in dir */
   void dirwalk(char *dir, void (*fcn)(char *))
   {
       char name[MAX_PATH];
       Dirent *dp;
       DIR *dfd;148
       if ((dfd = opendir(dir)) == NULL) {
           fprintf(stderr, "dirwalk: can't open %s\n", dir);
           return;
       }
       while ((dp = readdir(dfd)) != NULL) {
           if (strcmp(dp->name, ".") == 0
               || strcmp(dp->name, ".."))
               continue;    /* skip self and parent */
           if (strlen(dir)+strlen(dp->name)+2 > sizeof(name))
               fprintf(stderr, "dirwalk: name %s %s too long\n",
                   dir, dp->name);
           else {
               sprintf(name, "%s/%s", dir, dp->name);
               (*fcn)(name);
           }
       }
       closedir(dfd);
   }
Each calltoreaddir returns apointer toinformation forthenext file,orNULL when there are
nofiles left.Each directory always contains entries foritself, called".",anditsparent,".." ;
these must be skipped, or the program will loop forever. 
Down to this last level, the code is independent of how directories are formatted. The next step
istopresent minimal versions ofopendir ,readdir ,andclosedir foraspecific system. The
following routines areforVersion 7andSystem VUNIX systems; they usethedirectory
information in the header <sys/dir.h> , which looks like this: 
   #ifndef DIRSIZ
   #define DIRSIZ  14
   #endif
   struct direct {   /* directory entry */
       ino_t d_ino;           /* inode number */
       char  d_name[DIRSIZ];  /* long name does not have '\0' */
   };
Some versions of the system permit much longer names and have a more complicated directory
structure. 
The typeino_t isatypedef that describes theindex into theinode list.Ithappens tobe
unsigned short onthesystems weuseregularly, butthisisnotthesort ofinformation to
embed inaprogram; itmight bedifferent onadifferent system, sothetypedef isbetter. A
complete set of ``system'' types is found in <sys/types.h> . 
opendir opens thedirectory, verifies thatthefileisadirectory (this time bythesystem call
fstat ,which islikestat except that itapplies toafiledescriptor), allocates adirectory
structure, and records the information: 
   int fstat(int fd, struct stat *);
   /* opendir:  open a directory for readdir calls */
   DIR *opendir(char *dirname)
   {
       int fd;
       struct stat stbuf;
       DIR *dp;
       if ((fd = open(dirname, O_RDONLY, 0)) == -1
        || fstat(fd, &stbuf) == -1
        || (stbuf.st_mode & S_IFMT) != S_IFDIR
        || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)
            return NULL;
       dp->fd = fd;
       return dp;
   }149
closedir  closes the directory file and frees the space: 
   /* closedir:  close directory opened by opendir */
   void closedir(DIR *dp)
   {
       if (dp) {
           close(dp->fd);
           free(dp);
       }
   }
Finally,readdir usesread toread each directory entry. Ifadirectory slotisnotcurrently in
use(because afilehasbeen removed), theinode number iszero, andthisposition isskipped.
Otherwise, the inode number and name are placed in a static  structure and a pointer to that is
returned to the user. Each call overwrites the information from the previous one. 
   #include <sys/dir.h>   /* local directory structure */
   /* readdir:  read directory entries in sequence */
   Dirent *readdir(DIR *dp)
   {
       struct direct dirbuf;  /* local directory structure */
       static Dirent  d;      /* return: portable structure */
       while (read(dp->fd, (char *) &dirbuf, sizeof(dirbuf))
                       == sizeof(dirbuf)) {
           if (dirbuf.d_ino == 0) /* slot not in use */
               continue;
           d.ino = dirbuf.d_ino;
           strncpy(d.name, dirbuf.d_name, DIRSIZ);
           d.name[DIRSIZ] = '\0';  /* ensure termination */
           return &d;
       }
       return NULL;
   }
Although thefsize program israther specialized, itdoes illustrate acouple ofimportant
ideas. First, many programs arenot``system programs''; they merely useinformation that is
maintained bytheoperating system. Forsuch programs, itiscrucial thattherepresentation of
theinformation appear only instandard headers, and that programs include those headers
instead ofembedding thedeclarations inthemselves. Thesecond observation isthatwith care
itispossible tocreate aninterface tosystem-dependent objects thatisitself relatively system-
independent. The functions of the standard library are good examples. 
Exercise 8-5. Modify thefsize program toprint theother information contained intheinode
entry. 
8.7 Example - A Storage Allocator
InChapter 5 ,wepresented avary limited stack-oriented storage allocator. Theversion thatwe
willnow write isunrestricted. Calls tomalloc andfree may occur inanyorder;malloc calls
upon theoperating system toobtain more memory asnecessary. These routines illustrate some
oftheconsiderations involved inwriting machine-dependent code inarelatively machine-
independent way, and also show a real-life application of structures, unions and typedef . 
Rather than allocating from acompiled-in fixed-size array,malloc willrequest space from the
operating system asneeded. Since other activities intheprogram may also request space
without calling thisallocator, thespace thatmalloc manages may notbecontiguous. Thus its
free storage iskept asalistoffree blocks. Each block contains asize, apointer tothenext
block, andthespace itself. Theblocks arekept inorder ofincreasing storage address, andthe
last block (highest address) points to the first. 150
When arequest ismade, thefree listisscanned until abig-enough block isfound. This
algorithm iscalled ``first fit,''bycontrast with ``best fit,''which looks forthesmallest block
thatwillsatisfy therequest. Iftheblock isexactly thesizerequested itisunlinked from thelist
andreturned totheuser. Iftheblock istoobig,itissplit, andtheproper amount isreturned to
theuser while theresidue remains onthefree list.Ifnobig-enough block isfound, another
large chunk is obtained by the operating system and linked into the free list. 
Freeing also causes asearch ofthefreelist,tofindtheproper place toinsert theblock being
freed. Iftheblock being freed isadjacent toafreeblock oneither side, itiscoalesced with it
into asingle bigger block, sostorage does notbecome toofragmented. Determining the
adjacency is easy because the free list is maintained in order of decreasing address. 
One problem, which wealluded toinChapter 5 ,istoensure that thestorage returned by
malloc isaligned properly fortheobjects thatwillbestored init.Although machines vary, for
each machine there isamost restrictive type: ifthemost restrictive type canbestored ata
particular address, allother types may bealso. Onsome machines, themost restrictive type isa
double ; on others, int or long  suffices. 
Afreeblock contains apointer tothenext block inthechain, arecord ofthesizeoftheblock,
andthen thefreespace itself; thecontrol information atthebeginning iscalled the``header.''
Tosimplify alignment, allblocks aremultiples oftheheader size, andtheheader isaligned
properly. This isachieved byaunion thatcontains thedesired header structure andaninstance
of the most restrictive alignment type, which we have arbitrarily made a long : 
   typedef long Align;    /* for alignment to long boundary */
   union header {         /* block header */
       struct {
           union header *ptr; /* next block if on free list */
           unsigned size;     /* size of this block */
       } s;
       Align x;           /* force alignment of blocks */
   };
   typedef union header Header;
TheAlign field isnever used; itjust forces each header tobealigned onaworst-case
boundary. 
Inmalloc ,therequested sizeincharacters isrounded uptotheproper number ofheader-sized
units; theblock thatwillbeallocated contains onemore unit, fortheheader itself, andthisis
thevalue recorded inthesize field oftheheader. The pointer returned bymalloc points at
thefreespace, notattheheader itself. Theuser candoanything with thespace requested, but
if anything is written outside of the allocated space the list is likely to be scrambled. 151
Thesizefield isnecessary because theblocks controlled bymalloc need notbecontiguous -it
is not possible to compute sizes by pointer arithmetic. 
The variablebase isused togetstarted. Iffreep isNULL ,asitisatthefirst callofmalloc ,
then adegenerate freelistiscreated; itcontains oneblock ofsizezero, andpoints toitself. In
anycase, thefreelististhen searched. Thesearch forafreeblock ofadequate sizebegins at
the point (freep )where thelast block was found; this strategy helps keep the list
homogeneous. Ifatoo-big block isfound, thetailendisreturned totheuser; inthisway the
header oftheoriginal needs only tohave itssizeadjusted. Inallcases, thepointer returned to
the user points to the free space within the block, which begins one unit beyond the header. 
   static Header base;       /* empty list to get started */
   static Header *freep = NULL;     /* start of free list */
   /* malloc:  general-purpose storage allocator */
   void *malloc(unsigned nbytes)
   {
       Header *p, *prevp;
       Header *moreroce(unsigned);
       unsigned nunits;
       nunits = (nbytes+sizeof(Header)-1)/sizeof(header) + 1;
       if ((prevp = freep) == NULL) {   /* no free list yet */ 
           base.s.ptr = freeptr = prevptr = &base;
           base.s.size = 0;
       }
       for (p = prevp->s.ptr; ; prevp = p, p = p->s.ptr) {
           if (p->s.size >= nunits) {  /* big enough */
               if (p->s.size == nunits)  /* exactly */
                   prevp->s.ptr = p->s.ptr;
               else {              /* allocate tail end */
                   p->s.size -= nunits;
                   p += p->s.size;
                   p->s.size = nunits;
               }
               freep = prevp;
               return (void *)(p+1);
           }
           if (p == freep)  /* wrapped around free list */
               if ((p = morecore(nunits)) == NULL)
                   return NULL;    /* none left */
       }
   }
Thefunctionmorecore obtains storage from theoperating system. Thedetails ofhow itdoes
this vary from system tosystem. Since asking thesystem formemory isacomparatively
expensive operation. wedon't want todothatonevery calltomalloc ,somorecore requests
alleastNALLOC units; thislarger block willbechopped upasneeded. After setting thesize
field, morecore  inserts the additional memory into the arena by calling free . 152
TheUNIX system callsbrk(n) returns apointer tonmore bytes ofstorage.sbrk returns-1
ifthere wasnospace, even thoughNULL could have been abetter design. The-1must becast
tochar*soitcanbecompared with thereturn value. Again, casts make thefunction
relatively immune tothedetails ofpointer representation ondifferent machines. There isstill
one assumption, however, that pointers todifferent blocks returned bysbrk can be
meaningfully compared. This isnot guaranteed bythestandard, which permits pointer
comparisons only within anarray. Thus this version ofmalloc isportable only among
machines for which general pointer comparison is meaningful. 
   #define NALLOC  1024   /* minimum #units to request */
   /* morecore:  ask system for more memory */
   static Header *morecore(unsigned nu)
   {
       char *cp, *sbrk(int);
       Header *up;
       if (nu < NALLOC)
           nu = NALLOC;
       cp = sbrk(nu * sizeof(Header));
       if (cp == (char *) -1)   /* no space at all */
           return NULL;
       up = (Header *) cp;
       up->s.size = nu;
       free((void *)(up+1));
       return freep;
   }
free itself isthelastthing. Itscans thefree list,starting atfreep ,looking fortheplace to
insert thefreeblock. This iseither between twoexisting blocks orattheendofthelist.Inany
case, iftheblock being freed isadjacent toeither neighbor, theadjacent blocks arecombined.
The only troubles are keeping the pointers pointing to the right things and the sizes correct. 
   /* free:  put block ap in free list */
   void free(void *ap)
   {
       Header *bp, *p;
       bp = (Header *)ap - 1;    /* point to  block header */
       for (p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
            if (p >= p->s.ptr && (bp > p || bp < p->s.ptr))
                break;  /* freed block at start or end of arena */
       if (bp + bp->size == p->s.ptr) {    /* join to upper nbr */
           bp->s.size += p->s.ptr->s.size;
           bp->s.ptr = p->s.ptr->s.ptr;
       } else
           bp->s.ptr = p->s.ptr;
       if (p + p->size == bp) {            /* join to lower nbr */
           p->s.size += bp->s.size;
           p->s.ptr = bp->s.ptr;
       } else
           p->s.ptr = bp;
       freep = p;
   }
Although storage allocation isintrinsically machine-dependent, thecode above illustrates how
themachine dependencies canbecontrolled andconfined toavery small part oftheprogram.
The useoftypedef andunion handles alignment (given thatsbrk supplies anappropriate
pointer). Casts arrange thatpointer conversions aremade explicit, andeven cope with abadly-
designed system interface. Even though thedetails here arerelated tostorage allocation, the
general approach is applicable to other situations as well. 153
Exercise 8-6. Thestandard library functioncalloc(n,size) returns apointer tonobjects of
sizesize ,with thestorage initialized tozero. Writecalloc ,bycallingmalloc orby
modifying it. 
Exercise 8-7.malloc accepts asize request without checking itsplausibility; free believes
that the block it is asked to free contains a valid size field. Improve these routines so they make
more pains with error checking. 
Exercise 8-8. Write aroutinebfree(p,n) thatwillfreeanyarbitrary blockpofncharacters
into thefreelistmaintained bymalloc andfree .Byusingbfree ,auser canaddastatic or
external array to the free list at any time. 154
Appendix A - Reference Manual
A.1 Introduction
This manual describes theClanguage specified bythedraft submitted toANSI on31October,
1988, forapproval as``American Standard forInformation Systems -programming Language
C,X3.159-1989.'' The manual isaninterpretation oftheproposed standard, notthestandard
itself, although care has been taken to make it a reliable guide to the language. 
Forthemost part, thisdocument follows thebroad outline ofthestandard, which inturn
follows thatofthefirstedition ofthisbook, although theorganization differs indetail. Except
forrenaming afewproductions, andnotformalizing thedefinitions ofthelexical tokens orthe
preprocessor, thegrammar given here forthelanguage proper isequivalent tothat ofthe
standard. 
Throughout thismanual, commentary material isindented andwritten insmaller type, asthisis.Most
often these comments highlight ways inwhich ANSI Standard Cdiffers from thelanguage defined by
the first edition of this book, or from refinements subsequently introduced in various compilers. 
A.2 Lexical Conventions
Aprogram consists ofoneormore translation units stored infiles. Itistranslated inseveral
phases, which aredescribed inPar.A.12 .Thefirstphases dolow-level lexical transformations,
carry outdirectives introduced bythelines beginning with the#character, andperform macro
definition andexpansion. When thepreprocessing ofPar.A.12 iscomplete, theprogram has
been reduced to a sequence of tokens. 
A.2.1 Tokens
There aresixclasses oftokens: identifiers, keywords, constants, string literals, operators, and
other separators. Blanks, horizontal andvertical tabs, newlines, formfeeds andcomments as
described below (collectively, ``white space'') areignored except asthey separate tokens.
Some white space isrequired toseparate otherwise adjacent identifiers, keywords, and
constants. 
Iftheinput stream hasbeen separated intotokens uptoagiven character, thenext token isthe
longest string of characters that could constitute a token. 
A.2.2 Comments
The characters /*introduce acomment, which terminates with thecharacters */.Comments
do not nest, and they do not occur within a string or character literals. 
A.2.3 Identifiers
Anidentifier isasequence ofletters and digits. The first character must bealetter; the
underscore _counts asaletter. Upper andlower case letters aredifferent. Identifiers may have
anylength, andforinternal identifiers, atleast thefirst 31characters aresignificant; some
implementations may take more characters significant. Internal identifiers include preprocessor
macro names andallother names that donothave external linkage (Par.A.11.2 ).Identifiers
with external linkage aremore restricted: implementations may make asfewasthefirst six
characters significant, and may ignore case distinctions. 
A.2.4 Keywords
The following identifiers are reserved for the use as keywords, and may not be used otherwise:
     auto          double      int          struct
     break         else        long         switch155
     case          enum        register     typedef
     char          extern      return       union
     const         float       short        unsigned
     continue      for         signed       void
     default       goto        sizeof       volatile
     do            if          static       while
Some implementations also reserve the words fortran  and asm. 
The keywordsconst ,signed ,andvolatile arenew with theANSI standard;enum andvoid
arenew since thefirst edition, butincommon use;entry ,formerly reserved butnever used, isno
longer reserved. 
A.2.5 Constants
There are several kinds of constants. Each has a data type; Par.A.4.2  discusses the basic types: 
    constant:
      integer-constant
      character-constant
      floating-constant
      enumeration-constant 
A.2.5.1 Integer Constants
Aninteger constant consisting ofasequence ofdigits istaken tobeoctal ifitbegins with 0
(digit zero), decimal otherwise. Octal constants donotcontain thedigits8or9.Asequence of
digits preceded by0xor0X(digit zero) istaken tobeahexadecimal integer. Thehexadecimal
digits include a or A through f or F with values 10 through 15. 
Aninteger constant may besuffixed bytheletteruorU,tospecify thatitisunsigned. Itmay
also be suffixed by the letter l or L to specify that it is long. 
The type ofaninteger constant depends onitsform, value andsuffix. (See Par.A.4 fora
discussion oftypes). Ifitisunsuffixed anddecimal, ithasthefirst ofthese types inwhich its
value canberepresented: int,longint,unsigned longint.Ifitisunsuffixed, octal or
hexadecimal, ithasthefirstpossible ofthese types:int,unsigned int,longint,unsigned
longint.Ifitissuffixed byuorU,thenunsigned int,unsigned longint.Ifitis
suffixed bylorL,thenlongint,unsigned longint.Ifaninteger constant issuffixed by
UL, it is unsigned long . 
The elaboration ofthetypes ofinteger constants goes considerably beyond thefirst edition, which
merely caused large integer constants to be long . The U suffixes are new. 
A.2.5.2 Character Constants
Acharacter constant isasequence ofoneormore characters enclosed insingle quotes asin
'x'.The value ofacharacter constant with only onecharacter isthenumeric value ofthe
character inthemachine's character setatexecution time. The value ofamulti-character
constant is implementation-defined. 
Character constants donotcontain the'character ornewlines; inorder torepresent them, and
certain other characters, the following escape sequences may be used: 
newline NL (LF)  \n    backslash \ \\
horizontal tab HT \t question mark ? \?
vertical tab VT \v single quote ' \'
backspace BS \b double quote " \"
carriage return CR \r octal number ooo\ooo
formfeed FF \f hex number hh \xhh
audible alert BEL \a156
Theescape\ooo consists ofthebackslash followed by1,2,or3octal digits, which aretaken
tospecify thevalue ofthedesired character. Acommon example ofthisconstruction is\0(not
followed byadigit), which specifies thecharacter NUL. The escape\xhh consists ofthe
backslash, followed byx,followed byhexadecimal digits, which aretaken tospecify thevalue
of the desired character. There is no limit on the number of digits, but the behavior is undefined
iftheresulting character value exceeds that ofthelargest character. For either octal or
hexadecimal escape characters, iftheimplementation treats thechar type assigned, thevalue
issign-extended asifcast tochar type. Ifthecharacter following the\isnotoneofthose
specified, the behavior is undefined. 
Insome implementations, there isanextended setofcharacters thatcannot berepresented in
thechar type. Aconstant inthisextended setiswritten with apreceding L,forexampleL'x' ,
andiscalled awide character constant. Such aconstant hastypewchar_t ,anintegral type
defined inthestandard header<stddef.h> .Aswith ordinary character constants, hexadecimal
escapes may beused; theeffect isundefined ifthespecified value exceeds that representable
with wchar_t . 
Some ofthese escape sequences arenew, inparticular thehexadecimal character representation.
Extended characters arealso new. The character sets commonly used intheAmericas andwestern
Europe can beencoded tofitinthechar type; themain intent inaddingwchar_t was to
accommodate Asian languages. 
A.2.5.3 Floating Constants
Afloating constant consists ofaninteger part, adecimal part, afraction part, aneorE,an
optionally signed integer exponent andanoptional type suffix, oneoff,F,l,orL.Theinteger
andfraction parts both consist ofasequence ofdigits. Either theinteger part, orthefraction
part (not both) may bemissing; either thedecimal point ortheeandtheexponent (not both)
may bemissing. The type isdetermined bythesuffix;Forfmakes itfloat ,Lorlmakes it
long double , otherwise it is double . 
A2.5.4 Enumeration Constants
Identifiers declared as enumerators (see Par.A.8.4 ) are constants of type int. 
A.2.6 String Literals
Astring literal, also called astring constant, isasequence ofcharacters surrounded bydouble
quotes asin"..." .Astring hastype ``array ofcharacters'' andstorage classstatic (see
Par.A.3 below) andisinitialized with thegiven characters. Whether identical string literals are
distinct isimplementation-defined, andthebehavior ofaprogram thatattempts toalter astring
literal is undefined. 
Adjacent string literals areconcatenated into asingle string. After anyconcatenation, anull
byte\0isappended tothestring sothatprograms thatscan thestring canfinditsend. String
literals do not contain newline or double-quote characters; in order to represent them, the same
escape sequences as for character constants are available. 
Aswith character constants, string literals inanextended character setarewritten with a
preceding L,asinL"..." .Wide-character string literals have type ``array ofwchar_t .''
Concatenation of ordinary and wide string literals is undefined. 
The specification thatstring literals need notbedistinct, andtheprohibition against modifying them,
arenew intheANSI standard, asistheconcatenation ofadjacent string literals. Wide-character string
literals are new. 
A.3 Syntax Notation
Inthesyntax notation used inthismanual, syntactic categories areindicated byitalic type, and
literal words andcharacters intypewriter style. Alternative categories areusually listed on
separate lines; inafewcases, along setofnarrow alternatives ispresented ononeline, marked157
by the phrase ``one of.'' An optional terminal or nonterminal symbol carries the subscript `` opt,''
so that, for example, 
{ expression opt } 
means an optional expression, enclosed in braces. The syntax is summarized in Par.A.13 . 
Unlike thegrammar given inthefirst edition ofthisbook, theonegiven here makes precedence and
associativity of expression operators explicit. 
A.4 Meaning of Identifiers
Identifiers, ornames, refer toavariety ofthings: functions; tags ofstructures, unions, and
enumerations; members ofstructures orunions; enumeration constants; typedef names; and
objects. Anobject, sometimes called avariable, isalocation instorage, anditsinterpretation
depends ontwomain attributes: itsstorage class anditstype.Thestorage class determines the
lifetime ofthestorage associated with theidentified object; thetype determines themeaning of
thevalues found intheidentified object. Aname also hasascope, which istheregion ofthe
program inwhich itisknown, andalinkage, which determines whether thesame name in
another scope refers tothesame object orfunction. Scope and linkage arediscussed in
Par.A.11 . 
A.4.1 Storage Class
There aretwo storage classes: automatic and static. Several keywords, together with the
context ofanobject's declaration, specify itsstorage class. Automatic objects arelocal toa
block (Par.9.3 ),andarediscarded onexitfrom theblock. Declarations within ablock create
automatic objects ifnostorage class specification ismentioned, oriftheauto specifier isused.
Objects declaredregister areautomatic, andare(ifpossible) stored infastregisters ofthe
machine. 
Static objects may belocal toablock orexternal toallblocks, butineither case retain their
values across exitfrom andreentry tofunctions andblocks. Within ablock, including ablock
that provides the code for a function, static objects are declared with the keyword static . The
objects declared outside allblocks, atthesame level asfunction definitions, arealways static.
They may bemade local toaparticular translation unit byuseofthestatic keyword; this
gives them internal linkage .They become global toanentire program byomitting anexplicit
storage class, or by using the keyword extern ; this gives them external linkage . 
A.4.2 Basic Types
There areseveral fundamental types. Thestandard header<limits.h> described inAppendix
Bdefines thelargest andsmallest values ofeach type inthelocal implementation. Thenumbers
given in Appendix B  show the smallest acceptable magnitudes. 
Objects declared ascharacters (char )arelarge enough tostore anymember oftheexecution
character set.Ifagenuine character from that setisstored inachar object, itsvalue is
equivalent totheinteger code forthecharacter, andisnon-negative. Other quantities may be
stored into char  variables, but the available range of values, and especially whether the value is
signed, is implementation-dependent. 
Unsigned characters declaredunsigned char consume thesame amount ofspace asplain
characters, butalways appear non-negative; explicitly signed characters declaredsignedchar
likewise take the same space as plain characters. 
unsignedchar type does notappear inthefirst edition ofthisbook, butisincommon use.signed
char  is new. 
Besides thechar types, uptothree sizes ofinteger, declaredshortint,int,andlongint,
areavailable. Plainint objects have thenatural size suggested bythehost machine158
architecture; theother sizes areprovided tomeet special needs. Longer integers provide at
least asmuch storage asshorter ones, buttheimplementation may make plain integers
equivalent toeither short integers, orlong integers. Theinttypes allrepresent signed values
unless specified otherwise. 
Unsigned integers, declared using thekeyword unsigned ,obey thelaws ofarithmetic modulo
2nwhere nisthenumber ofbits intherepresentation, and thus arithmetic onunsigned
quantities cannever overflow. The setofnon-negative values that canbestored inasigned
object isasubset ofthevalues thatcanbestored inthecorresponding unsigned object, andthe
representation for the overlapping values is the same. 
Any ofsingle precision floating point (float ),double precision floating point (double ),and
extra precision floating point (longdouble )may besynonymous, buttheones later inthelist
are at least as precise as those before. 
longdouble isnew. Thefirst edition madelongfloat equivalent todouble ;thelocution has
been withdrawn. 
Enumerations areunique types thathave integral values; associated with each enumeration isa
setofnamed constants (Par.A.8.4 ).Enumerations behave likeintegers, butitiscommon fora
compiler toissue awarning when anobject ofaparticular enumeration isassigned something
other than one of its constants, or an expression of its type. 
Because objects ofthese types canbeinterpreted asnumbers, they will bereferred toas
arithmetic types. Typeschar ,andint ofallsizes, each with orwithout sign, and also
enumeration types, willcollectively becalled integral types. The typesfloat ,double ,and
long double  will be called floating  types. 
Thevoid type specifies anempty setofvalues. Itisused asthetype returned byfunctions that
generate no value. 
A.4.3 Derived types
Beside thebasic types, there isaconceptually infinite class ofderived types constructed from
the fundamental types in the following ways: 
  arrays  of objects of a given type;
  functions  returning objects of a given type;
  pointers  to objects of a given type;
  structures  containing a sequence of objects of various types;
  unions  capable of containing any of one of several objects of various types. 
In general these methods of constructing objects can be applied recursively. 
A.4.4 Type Qualifiers
Anobject's type may have additional qualifiers. Declaring anobjectconst announces thatits
value will notbechanged; declaring itvolatile announces that ithasspecial properties
relevant to optimization. Neither qualifier affects the range of values or arithmetic properties of
the object. Qualifiers are discussed in Par.A.8.2 . 
A.5 Objects and Lvalues
AnObject isanamed region ofstorage; anlvalue isanexpression referring toanobject. An
obvious example ofanlvalue expression isanidentifier with suitable type andstorage class.
There areoperators thatyield lvalues, ifEisanexpression ofpointer type, then*Eisanlvalue
expression referring totheobject towhichEpoints. The name ``lvalue'' comes from the
assignment expression E1=E2inwhich theleftoperandE1must beanlvalue expression. The159
discussion ofeach operator specifies whether itexpects lvalue operands andwhether ityields
an lvalue. 
A.6 Conversions
Some operators may, depending ontheir operands, cause conversion ofthevalue ofan
operand from onetype toanother. This section explains theresult tobeexpected from such
conversions. Par.6.5 summarizes theconversions demanded bymost ordinary operators; itwill
be supplemented as required by the discussion of each operator. 
A.6.1 Integral Promotion
Acharacter, ashort integer, oraninteger bit-field, alleither signed ornot, oranobject of
enumeration type, may beused inanexpression wherever aninteger may beused. Ifanint
canrepresent allthevalues oftheoriginal type, then thevalue isconverted toint;otherwise
the value is converted to unsigned int . This process is called integral promotion . 
A.6.2 Integral Conversions
Any integer isconverted toagiven unsigned type byfinding thesmallest non-negative value
that iscongruent tothat integer, modulo one more than thelargest value that can be
represented intheunsigned type. Inatwo's complement representation, thisisequivalent to
left-truncation ifthebitpattern oftheunsigned type isnarrower, andtozero-filling unsigned
values and sign-extending signed values if the unsigned type is wider. 
When anyinteger isconverted toasigned type, thevalue isunchanged ifitcanberepresented
in the new type and is implementation-defined otherwise. 
A.6.3 Integer and Floating
When avalue offloating type isconverted tointegral type, thefractional part isdiscarded; if
theresulting value cannot berepresented intheintegral type, thebehavior isundefined. In
particular, theresult ofconverting negative floating values tounsigned integral types isnot
specified. 
When avalue ofintegral type isconverted tofloating, andthevalue isintherepresentable
range butisnotexactly representable, then theresult may beeither thenext higher ornext
lower representable value. If the result is out of range, the behavior is undefined. 
A.6.4 Floating Types
When alessprecise floating value isconverted toanequally ormore precise floating type, the
value isunchanged. When amore precise floating value isconverted toalessprecise floating
type, andthevalue iswithin representable range, theresult may beeither thenext higher orthe
next lower representable value. If the result is out of range, the behavior is undefined. 
A.6.5 Arithmetic Conversions
Many operators cause conversions andyield result types inasimilar way. Theeffect istobring
operands into acommon type, which isalso thetype oftheresult. This pattern iscalled the
usual arithmetic conversions . 
•First, if either operand is long double , the other is converted to long double . 
•Otherwise, if either operand is double , the other is converted to double . 
•Otherwise, if either operand is float , the other is converted to float . 
•Otherwise, theintegral promotions areperformed onboth operands; then, ifeither
operand is unsigned long int , the other is converted to unsigned long int . 160
•Otherwise, ifone operand islongint andtheother isunsigned int,theeffect
depends onwhether alongintcanrepresent allvalues ofanunsigned int;ifso,
theunsigned int operand isconverted tolongint;ifnot, both areconverted to
unsigned long int . 
•Otherwise, if one operand is long int , the other is converted to long int . 
•Otherwise, ifeither operand isunsigned int,theother isconverted tounsigned
int. 
•Otherwise, both operands have type int. 
There aretwochanges here. First, arithmetic onfloat operands may bedone insingle precision,
rather than double; thefirst edition specified thatallfloating arithmetic wasdouble precision. Second,
shorter unsigned types, when combined with alarger signed type, donotpropagate theunsigned
property totheresult type; inthefirst edition, theunsigned always dominated. The new rules are
slightly more complicated, butreduce somewhat thesurprises that may occur when anunsigned
quantity meets signed. Unexpected results may stilloccur when anunsigned expression iscompared to
a signed expression of the same size. 
A.6.6 Pointers and Integers
Anexpression ofintegral type may beadded toorsubtracted from apointer; insuch acase the
integral expression isconverted asspecified inthediscussion oftheaddition operator
(Par.A.7.7 ). 
Two pointers toobjects ofthesame type, inthesame array, may besubtracted; theresult is
converted to an integer as specified in the discussion of the subtraction operator ( Par.A.7.7 ). 
Anintegral constant expression with value 0,orsuch anexpression casttotypevoid*,may
beconverted, byacast, byassignment, orbycomparison, toapointer ofanytype. This
produces anullpointer thatisequal toanother nullpointer ofthesame type, butunequal to
any pointer to a function or object. 
Certain other conversions involving pointers arepermitted, buthave implementation-defined
aspects. They must bespecified byanexplicit type-conversion operator, orcast (Pars. A.7.5
and A.8.8 ). 
Apointer may beconverted toanintegral type large enough tohold it;therequired size is
implementation-dependent. The mapping function is also implementation-dependent. 
Apointer toonetype may beconverted toapointer toanother type. Theresulting pointer may
cause addressing exceptions ifthesubject pointer does notrefer toanobject suitably aligned in
storage. Itisguaranteed thatapointer toanobject may beconverted toapointer toanobject
whose type requires lessorequally strict storage alignment andback again without change; the
notion of``alignment'' isimplementation-dependent, butobjects ofthechar types have least
strict alignment requirements. Asdescribed inPar.A.6.8 ,apointer may also beconverted to
type void *  and back again without change. 
Apointer may beconverted toanother pointer whose type isthesame except fortheaddition
orremoval ofqualifiers (Pars. A.4.4 ,A.8.2 )oftheobject type towhich thepointer refers. If
qualifiers areadded, thenew pointer isequivalent totheoldexcept forrestrictions implied by
the new qualifiers. If qualifiers are removed, operations on the underlying object remain subject
to the qualifiers in its actual declaration. 
Finally, apointer toafunction may beconverted toapointer toanother function type. Calling
thefunction specified bytheconverted pointer isimplementation-dependent; however, ifthe
converted pointer isreconverted toitsoriginal type, theresult isidentical totheoriginal
pointer. 161
A.6.7 Void
The(nonexistent) value ofavoid object may notbeused inanyway, andneither explicit nor
implicit conversion toanynon-void type may beapplied. Because avoid expression denotes a
nonexistent value, such anexpression may beused only where thevalue isnotrequired, for
example asanexpression statement (Par.A.9.2 )orastheleftoperand ofacomma operator
(Par.A.7.18 ). 
Anexpression may beconverted totypevoid byacast. Forexample, avoid cast documents
the discarding of the value of a function call used as an expression statement. 
void  did not appear in the first edition of this book, but has become common since. 
A.6.8 Pointers to Void
Any pointer toanobject may beconverted totypevoid*without lossofinformation. Ifthe
result isconverted back totheoriginal pointer type, theoriginal pointer isrecovered. Unlike
thepointer-to-pointer conversions discussed inPar.A.6.6 ,which generally require anexplicit
cast, pointers may beassigned toandfrom pointers oftypevoid*,andmay becompared
with them. 
This interpretation ofvoid*pointers isnew; previously, char*pointers played therole of
generic pointer. The ANSI standard specifically blesses themeeting ofvoid*pointers with object
pointers in assignments and relationals, while requiring explicit casts for other pointer mixtures. 
A.7 Expressions
The precedence ofexpression operators isthesame astheorder ofthemajor subsections of
thissection, highest precedence first. Thus, forexample, theexpressions referred toasthe
operands of+(Par.A.7.7 )arethose expressions defined inPars. A.7.1 -A.7.6 .Within each
subsection, theoperators have thesame precedence. Left- orright-associativity isspecified in
each subsection fortheoperators discussed therein. Thegrammar given inPar.13 incorporates
the precedence and associativity of the operators. 
Theprecedence andassociativity ofoperators isfully specified, buttheorder ofevaluation of
expressions is,with certain exceptions, undefined, even ifthesubexpressions involve side
effects. That is,unless thedefinition oftheoperator guarantees thatitsoperands areevaluated
inaparticular order, theimplementation isfreetoevaluate operands inanyorder, oreven to
interleave their evaluation. However, each operator combines thevalues produced byits
operands in a way compatible with the parsing of the expression in which it appears. 
This rule revokes theprevious freedom toreorder expressions with operators that aremathematically
commutative andassociative, butcanfailtobecomputationally associative. The change affects only
floating-point computations near thelimits oftheir accuracy, and situations where overflow is
possible. 
The handling ofoverflow, divide check, andother exceptions inexpression evaluation isnot
defined bythelanguage. Most existing implementations ofCignore overflow inevaluation of
signed integral expressions andassignments, butthisbehavior isnotguaranteed. Treatment of
division by0,andallfloating-point exceptions, varies among implementations; sometimes itis
adjustable by a non-standard library function. 
A.7.1 Pointer Conversion
Ifthetype ofanexpression orsubexpression is``array ofT,''forsome type T,then thevalue of
theexpression isapointer tothefirst object inthearray, andthetype oftheexpression is
altered to``pointer toT.''This conversion does nottake place iftheexpression isinthe
operand oftheunary&operator, orof++,--,sizeof ,orastheleftoperand ofanassignment
operator orthe.operator. Similarly, anexpression oftype ``function returning T,''except
when used as the operand of the & operator, is converted to ``pointer to function returning T.'' 
A.7.2 Primary Expressions162
Primary expressions are identifiers, constants, strings, or expressions in parentheses. 
    primary-expression
      identifier
      constant
      string
      (expression) 
An identifier is a primary expression, provided it has been suitably declared as discussed below.
Itstype isspecified byitsdeclaration. Anidentifier isanlvalue ifitrefers toanobject
(Par.A.5 ) and if its type is arithmetic, structure, union, or pointer. 
A constant is a primary expression. Its type depends on its form as discussed in Par.A.2.5 . 
Astring literal isaprimary expression. Itstype isoriginally ``array ofchar ''(for wide-char
strings, ``array ofwchar_t ''),butfollowing therulegiven inPar.A.7.1 ,thisisusually modified
to``pointer tochar ''(wchar_t )andtheresult isapointer tothefirst character inthestring.
The conversion also does not occur in certain initializers; see Par.A.8.7 . 
Aparenthesized expression isaprimary expression whose type andvalue areidentical tothose
oftheunadorned expression. The precedence ofparentheses does notaffect whether the
expression is an lvalue. 
A.7.3 Postfix Expressions
The operators in postfix expressions group left to right. 
    postfix-expression:
      primary-expression
      postfix-expression[expression]
      postfix-expression(argument-expression-list opt)
      postfix-expression.identifier
      postfix-expression ->identifier
      postfix-expression ++
      postfix-expression -- 
    argument-expression-list:
      assignment-expression
      assignment-expression-list , assignment-expression 
A.7.3.1 Array References
Apostfix expression followed byanexpression insquare brackets isapostfix expression
denoting asubscripted array reference. One ofthetwoexpressions must have type ``pointer to
T'',where Tissome type, andtheother must have integral type; thetype ofthesubscript
expression isT.The expression E1[E2] isidentical (bydefinition) to*((E1)+(E2)) .See
Par.A.8.6.2  for further discussion. 
A.7.3.2 Function Calls
Afunction callisapostfix expression, called thefunction designator, followed byparentheses
containing apossibly empty, comma-separated listofassignment expressions (Par.A7.17 ),
which constitute thearguments tothefunction. Ifthepostfix expression consists ofan
identifier forwhich nodeclaration exists inthecurrent scope, theidentifier isimplicitly
declared as if the declaration 
    extern int  identifier(); 163
hadbeen given intheinnermost block containing thefunction call. The postfix expression
(after possible explicit declaration andpointer generation, Par.A7.1 )must beoftype ``pointer
to function returning T,'' for some type T, and the value of the function call has type T. 
Inthefirst edition, thetype was restricted to``function,'' andanexplicit*operator was required to
callthrough pointers tofunctions. The ANSI standard blesses thepractice ofsome existing compilers
bypermitting thesame syntax forcalls tofunctions andtofunctions specified bypointers. The older
syntax is still usable. 
The term argument isused foranexpression passed byafunction call; theterm parameter is
used foraninput object (oritsidentifier) received byafunction definition, ordescribed ina
function declaration. The terms ``actual argument (parameter)'' and ``formal argument
(parameter)'' respectively are sometimes used for the same distinction. 
Inpreparing forthecalltoafunction, acopy ismade ofeach argument; allargument-passing
is strictly by value. A function may change the values of its parameter objects, which are copies
oftheargument expressions, butthese changes cannot affect thevalues ofthearguments.
However, itispossible topass apointer ontheunderstanding thatthefunction may change the
value of the object to which the pointer points. 
There aretwo styles inwhich functions may bedeclared. Inthenew style, thetypes of
parameters areexplicit andarepart ofthetype ofthefunction; such adeclaration osalso
called afunction prototype. Intheoldstyle, parameter types arenotspecified. Function
declaration is issued in Pars.A.8.6.3  and A.10.1 . 
Ifthefunction declaration inscope foracallisold-style, then default argument promotion is
applied toeach argument asfollows: integral promotion (Par.A.6.1 )isperformed oneach
argument ofintegral type, andeachfloat argument isconverted todouble .Theeffect ofthe
callisundefined ifthenumber ofarguments disagrees with thenumber ofparameters inthe
definition ofthefunction, orifthetype ofanargument after promotion disagrees with thatof
thecorresponding parameter. Type agreement depends onwhether thefunction's definition is
new-style orold-style. Ifitisold-style, then thecomparison isbetween thepromoted type of
thearguments ofthecall, andthepromoted type oftheparameter, ifthedefinition isnew-
style, thepromoted type oftheargument must bethat oftheparameter itself, without
promotion. 
Ifthefunction declaration inscope foracallisnew-style, then thearguments areconverted, as
ifbyassignment, tothetypes ofthecorresponding parameters ofthefunction's prototype. The
number ofarguments must bethesame asthenumber ofexplicitly described parameters,
unless thedeclaration's parameter listends with theellipsis notation(,...) .Inthatcase, the
number ofarguments must equal orexceed thenumber ofparameters; trailing arguments
beyond theexplicitly typed parameters suffer default argument promotion asdescribed inthe
preceding paragraph. Ifthedefinition ofthefunction isold-style, then thetype ofeach
parameter inthedefinition, after thedefinition parameter's type hasundergone argument
promotion. 
These rules areespecially complicated because they must cater toamixture ofold- and new-style
functions. Mixtures are to be avoided if possible. 
The order ofevaluation ofarguments isunspecified; take note that various compilers differ.
However, thearguments andthefunction designator arecompletely evaluated, including all
side effects, before the function is entered. Recursive calls to any function are permitted. 
A.7.3.3 Structure References
Apostfix expression followed byadotfollowed byanidentifier isapostfix expression. The
firstoperand expression must beastructure oraunion, andtheidentifier must name amember
ofthestructure orunion. The value isthenamed member ofthestructure orunion, andits164
type isthetype ofthemember. Theexpression isanlvalue ifthefirst expression isanlvalue,
and if the type of the second expression is not an array type. 
Apostfix expression followed byanarrow (built from-and>)followed byanidentifier isa
postfix expression. Thefirstoperand expression must beapointer toastructure orunion, and
theidentifier must name amember ofthestructure orunion. The result refers tothenamed
member ofthestructure orunion towhich thepointer expression points, andthetype isthe
type of the member; the result is an lvalue if the type is not an array type. 
Thus the expression E1->MOS  is the same as (*E1).MOS . Structures and unions are discussed in
Par.A.8.3 . 
Inthefirst edition ofthisbook, itwasalready therulethatamember name insuch anexpression had
tobelong tothestructure orunion mentioned inthepostfix expression; however, anote admitted that
this rule was not firmly enforced. Recent compilers, and ANSI, do enforce it. 
A.7.3.4 Postfix Incrementation
Apostfix expression followed bya++or--operator isapostfix expression. Thevalue ofthe
expression isthevalue oftheoperand. After thevalue isnoted, theoperand isincremented ++
ordecremented --by1.The operand must beanlvalue; seethediscussion ofadditive
operators (Par.A.7.7 )andassignment (Par.A.7.17 )forfurther constraints ontheoperand and
details of the operation. The result is not an lvalue. 
A.7.4 Unary Operators
Expressions with unary operators group right-to-left. 
    unary-expression :
      postfix expression
      ++unary expression
      --unary expression
      unary-operator cast-expression
      sizeof  unary-expression
      sizeof (type-name ) 
    unary operator:  one of
      & * + - ~ !  
A.7.4.1 Prefix Incrementation Operators
Aunary expression followed bya++or--operator isaunary expression. The operand is
incremented ++ordecremented --by1.The value oftheexpression isthevalue after the
incrementation (decrementation). Theoperand must beanlvalue; seethediscussion ofadditive
operators (Par.A.7.7 )andassignment (Par.A.7.17 )forfurther constraints ontheoperands and
details of the operation. The result is not an lvalue. 
A.7.4.2 Address Operator
Theunary operator&takes theaddress ofitsoperand. Theoperand must beanlvalue referring
neither toabit-field nortoanobject declared asregister ,ormust beoffunction type. The
result isapointer totheobject orfunction referred tobythelvalue. Ifthetype oftheoperand
is T, the type of the result is ``pointer to T.'' 
A.7.4.3 Indirection Operator
The unary*operator denotes indirection, and returns theobject orfunction towhich its
operand points. Itisanlvalue iftheoperand isapointer toanobject ofarithmetic, structure,
union, or pointer type. If the type of the expression is ``pointer to T,'' the type of the result is T.
A.7.4.4 Unary Plus Operator165
The operand oftheunary+operator must have arithmetic type, andtheresult isthevalue of
theoperand. Anintegral operand undergoes integral promotion. The type oftheresult isthe
type of the promoted operand. 
The unary + is new with the ANSI standard. It was added for symmetry with the unary -. 
A.7.4.5 Unary Minus Operator
The operand oftheunary-operator must have arithmetic type, andtheresult isthenegative
ofitsoperand. Anintegral operand undergoes integral promotion. Thenegative ofanunsigned
quantity iscomputed bysubtracting thepromoted value from thelargest value ofthepromoted
type and adding one; butnegative zero iszero. The type oftheresult isthetype ofthe
promoted operand. 
A.7.4.6 One's Complement Operator
Theoperand ofthe~operator must have integral type, andtheresult istheone's complement
ofitsoperand. Theintegral promotions areperformed. Iftheoperand isunsigned, theresult is
computed bysubtracting thevalue from thelargest value ofthepromoted type. Iftheoperand
issigned, theresult iscomputed byconverting thepromoted operand tothecorresponding
unsigned type, applying~,andconverting back tothesigned type. Thetype oftheresult isthe
type of the promoted operand. 
A.7.4.7 Logical Negation Operator
Theoperand ofthe!operator must have arithmetic type orbeapointer, andtheresult is1if
the value of its operand compares equal to 0, and 0 otherwise. The type of the result is int. 
A.7.4.8 Sizeof Operator
Thesizeof operator yields thenumber ofbytes required tostore anobject ofthetype ofits
operand. Theoperand iseither anexpression, which isnotevaluated, oraparenthesized type
name. Whensizeof isapplied toachar ,theresult is1;when applied toanarray, theresult is
thetotal number ofbytes inthearray. When applied toastructure orunion, theresult isthe
number ofbytes intheobject, including anypadding required tomake theobject tileanarray:
thesizeofanarray ofnelements isntimes thesizeofoneelement. Theoperator may notbe
applied toanoperand offunction type, orofincomplete type, ortoabit-field. Theresult isan
unsigned integral constant; theparticular type isimplementation-defined. Thestandard header
<stddef.h>  (See appendix B ) defines this type as size_t . 
A.7.5 Casts
Aunary expression preceded bytheparenthesized name ofatype causes conversion ofthe
value of the expression to the named type. 
    cast-expression:
      unary expression
      (type-name) cast-expression 
This construction iscalled acast.The names aredescribed inPar.A.8.8 .The effects of
conversions are described in Par.A.6 . An expression with a cast is not an lvalue. 
A.7.6 Multiplicative Operators
The multiplicative operators *, /, and % group left-to-right. 
    multiplicative-expression :
      multiplicative-expression  * cast-expression
      multiplicative-expression  / cast-expression
      multiplicative-expression  % cast-expression  166
Theoperands of*and/must have arithmetic type; theoperands of%must have integral type.
The usual arithmetic conversions areperformed ontheoperands, andpredict thetype ofthe
result. 
The binary * operator denotes multiplication. 
Thebinary/operator yields thequotient, andthe%operator theremainder, ofthedivision of
the first operand by the second; if the second operand is 0, the result is undefined. Otherwise, it
isalways true that(a/b)*b +a%bisequal toa.Ifboth operands arenon-negative, then the
remainder isnon-negative andsmaller than thedivisor, ifnot, itisguaranteed only that the
absolute value of the remainder is smaller than the absolute value of the divisor. 
A.7.7 Additive Operators
The additive operators +and-group left-to-right. Iftheoperands have arithmetic type, the
usual arithmetic conversions areperformed. There aresome additional type possibilities for
each operator. 
    additive-expression :
      multiplicative-expression
      additive-expression  + multiplicative-expression
      additive-expression  - multiplicative-expression  
Theresult ofthe+operator isthesum oftheoperands. Apointer toanobject inanarray anda
value ofanyintegral type may beadded. The latter isconverted toanaddress offset by
multiplying itbythesizeoftheobject towhich thepointer points. Thesum isapointer ofthe
same type astheoriginal pointer, andpoints toanother object inthesame array, appropriately
offset from theoriginal object. Thus ifPisapointer toanobject inanarray, theexpression
P+1isapointer tothenext object inthearray. Ifthesum pointer points outside thebounds of
the array, except at the first location beyond the high end, the result is undefined. 
The provision forpointers justbeyond theendofanarray isnew. Itlegitimizes acommon idiom for
looping over the elements of an array. 
Theresult ofthe-operator isthedifference oftheoperands. Avalue ofanyintegral type may
besubtracted from apointer, andthen thesame conversions andconditions asforaddition
apply. 
Iftwopointers toobjects ofthesame type aresubtracted, theresult isasigned integral value
representing thedisplacement between thepointed-to objects; pointers tosuccessive objects
differ by1.Thetype oftheresult isdefined asptrdiff_t inthestandard header<stddef.h> .
Thevalue isundefined unless thepointers point toobjects within thesame array; however, ifP
points to the last member of an array, then (P+1)-P  has value 1. 
A.7.8 Shift Operators
The shift operators <<and>>group left-to-right. Forboth operators, each operand must be
integral, and issubject tointegral thepromotions. The type oftheresult isthat ofthe
promoted leftoperand. Theresult isundefined iftheright operand isnegative, orgreater than
or equal to the number of bits in the left expression's type. 
    shift-expression :
      additive-expression
      shift-expression  << additive-expression
      shift-expression  >> additive-expression  
The value ofE1<<E2 isE1(interpreted asabitpattern) left-shifted E2bits; intheabsence of
overflow, thisisequivalent tomultiplication by2E2.Thevalue ofE1>>E2 isE1right-shifted E2167
bitpositions. The right shift isequivalent todivision by2E2ifE1isunsigned orithasanon-
negative value; otherwise the result is implementation-defined. 
A.7.9 Relational Operators
The relational operators group left-to-right, butthisfact isnotuseful;a<b<c isparsed as
(a<b)<c , and evaluates to either 0 or 1. 
    relational-expression :
      shift-expression
      relational-expression  < shift-expression
      relational-expression  > shift-expression
      relational-expression  <= shift-expression
      relational-expression  >= shift-expression  
Theoperators <(less),>(greater), <=(less orequal) and>=(greater orequal) allyield 0ifthe
specified relation isfalse and1ifitistrue. Thetype oftheresult isint.Theusual arithmetic
conversions areperformed onarithmetic operands. Pointers toobjects ofthesame type
(ignoring anyqualifiers) may becompared; theresult depends ontherelative locations inthe
address space ofthepointed-to objects. Pointer comparison isdefined only forparts ofthe
same object; iftwo pointers point tothesame simple object, they compare equal; ifthe
pointers aretomembers ofthesame structure, pointers toobjects declared later inthe
structure compare higher; ifthepointers refer tomembers ofanarray, thecomparison is
equivalent tocomparison ofthethecorresponding subscripts. IfPpoints tothelastmember of
anarray, thenP+1 compares higher thanP,even thoughP+1 points outside thearray.
Otherwise, pointer comparison is undefined. 
These rules slightly liberalize therestrictions stated inthefirst edition, bypermitting comparison of
pointers to different members of a structure or union. They also legalize comparison with a pointer just
off the end of an array. 
A.7.10 Equality Operators
    equality-expression :
      relational-expression
      equality-expression  == relational-expression
      equality-expression  != relational-expression  
The==(equal to)andthe!=(not equal to)operators areanalogous totherelational operators
except fortheir lower precedence. (Thusa<b==c<d is1whenever a<b andc<d have the
same truth-value.) 
The equality operators follow thesame rules astherelational operators, butpermit additional
possibilities: apointer may becompared toaconstant integral expression with value 0,ortoa
pointer to void . See Par.A.6.6 . 
A.7.11 Bitwise AND Operator
    AND-expression :
      equality-expression
      AND-expression  & equality-expression  
Theusual arithmetic conversions areperformed; theresult isthebitwise AND function ofthe
operands. The operator applies only to integral operands. 
A.7.12 Bitwise Exclusive OR Operator
    exclusive-OR-expression :
      AND-expression
      exclusive-OR-expression  ^ AND-expression  168
Theusual arithmetic conversions areperformed; theresult isthebitwise exclusive ORfunction
of the operands. The operator applies only to integral operands. 
A.7.13 Bitwise Inclusive OR Operator
    inclusive-OR-expression :
      exclusive-OR-expression
      inclusive-OR-expression  | exclusive-OR-expression  
Theusual arithmetic conversions areperformed; theresult isthebitwise inclusive ORfunction
of the operands. The operator applies only to integral operands. 
A.7.14 Logical AND Operator
    logical-AND-expression :
      inclusive-OR-expression
      logical-AND-expression  && inclusive-OR-expression  
The&&operator groups left-to-right. Itreturns 1ifboth itsoperands compare unequal tozero,
0otherwise. Unlike&,&&guarantees left-to-right evaluation: thefirst operand isevaluated,
including allsideeffects; ifitisequal to0,thevalue oftheexpression is0.Otherwise, theright
operand is evaluated, and if it is equal to 0, the expression's value is 0, otherwise 1. 
Theoperands need nothave thesame type, buteach must have arithmetic type orbeapointer.
The result is int. 
A.7.15 Logical OR Operator
    logical-OR-expression :
      logical-AND-expression
      logical-OR-expression  || logical-AND-expression  
The||operator groups left-to-right. Itreturns 1ifeither ofitsoperands compare unequal to
zero, and0otherwise. Unlike|,||guarantees left-to-right evaluation: thefirst operand is
evaluated, including allside effects; ifitisunequal to0,thevalue oftheexpression is1.
Otherwise, theright operand isevaluated, andifitisunequal to0,theexpression's value is1,
otherwise 0. 
Theoperands need nothave thesame type, buteach must have arithmetic type orbeapointer.
The result is int. 
A.7.16 Conditional Operator
    conditional-expression :
      logical-OR-expression
      logical-OR-expression  ? expression  : conditional-expression  
The first expression isevaluated, including allside effects; ifitcompares unequal to0,the
result isthevalue ofthesecond expression, otherwise thatofthethird expression. Only oneof
thesecond andthird operands isevaluated. Ifthesecond andthird operands arearithmetic, the
usual arithmetic conversions areperformed tobring them toacommon type, andthattype is
thetype oftheresult. Ifboth arevoid ,orstructures orunions ofthesame type, orpointers to
objects ofthesame type, theresult hasthecommon type. Ifoneisapointer andtheother the
constant 0,the0isconverted tothepointer type, andtheresult hasthat type. Ifoneisa
pointer tovoid andtheother isanother pointer, theother pointer isconverted toapointer to
void , and that is the type of the result. 169
Inthetype comparison forpointers, anytype qualifiers (Par.A.8.2 )inthetype towhich the
pointer points areinsignificant, buttheresult type inherits qualifiers from both arms ofthe
conditional. 
A.7.17 Assignment Expressions
There are several assignment operators; all group right-to-left. 
    assignment-expression :
      conditional-expression
      unary-expression assignment-operator assignment-expression  
    assignment-operator : one of
      = *= /= %= += -= <<= >>= &= ^= |=  
Allrequire anlvalue asleftoperand, andthelvalue must bemodifiable: itmust notbeanarray,
andmust nothave anincomplete type, orbeafunction. Also, itstype must notbequalified
withconst ;ifitisastructure orunion, itmust nothave any member or,recursively,
submember qualified withconst .The type ofanassignment expression isthat ofitsleft
operand, andthevalue isthevalue stored intheleftoperand after theassignment hastaken
place. 
Inthesimple assignment with=,thevalue oftheexpression replaces thatoftheobject referred
tobythelvalue. One ofthefollowing must betrue: both operands have arithmetic type, in
which case theright operand isconverted tothetype oftheleftbytheassignment; orboth
operands arestructures orunions ofthesame type; oroneoperand isapointer andtheother is
apointer tovoid ,ortheleftoperand isapointer and theright operand isaconstant
expression with value 0;orboth operands arepointers tofunctions orobjects whose types are
the same except for the possible absence of const  or volatile  in the right operand. 
Anexpression oftheformE1op=E2isequivalent toE1=E1op(E2) except thatE1is
evaluated only once. 
A.7.18 Comma Operator
    expression :
      assignment-expression
      expression  , assignment-expression  
Apairofexpressions separated byacomma isevaluated left-to-right, andthevalue oftheleft
expression isdiscarded. The type andvalue oftheresult arethetype andvalue oftheright
operand. Allside effects from theevaluation oftheleft-operand arecompleted before
beginning theevaluation oftheright operand. Incontexts where comma isgiven aspecial
meaning, forexample inlists offunction arguments (Par.A.7.3.2 )and lists ofinitializers
(Par.A.8.7 ),therequired syntactic unit isanassignment expression, sothecomma operator
appears only in a parenthetical grouping, for example, 
   f(a, (t=3, t+2), c)
has three arguments, the second of which has the value 5. 
A.7.19 Constant Expressions
Syntactically, a constant expression is an expression restricted to a subset of operators: 
    constant-expression :
      conditional-expression  170
Expressions that evaluate toaconstant arerequired inseveral contexts: aftercase ,asarray
bounds andbit-field lengths, asthevalue ofanenumeration constant, ininitializers, andin
certain preprocessor expressions. 
Constant expressions may not contain assignments, increment or decrement operators, function
calls, orcomma operators; except inanoperand ofsizeof .Iftheconstant expression is
required tobeintegral, itsoperands must consist ofinteger, enumeration, character, and
floating constants; casts must specify anintegral type, andanyfloating constants must becast
tointeger. This necessarily rules outarrays, indirection, address-of, and structure member
operations. (However, any operand is permitted for sizeof .) 
More latitude ispermitted fortheconstant expressions ofinitializers; theoperands may beany
type ofconstant, andtheunary&operator may beapplied toexternal orstatic objects, andto
external andstatic arrays subscripted with aconstant expression. The unary&operator can
alsobeapplied implicitly byappearance ofunsubscripted arrays andfunctions. Initializers must
evaluate either toaconstant ortotheaddress ofapreviously declared external orstatic object
plus or minus a constant. 
Less latitude isallowed fortheintegral constant expressions after#if;sizeof expressions,
enumeration constants, and casts are not permitted. See Par.A.12.5 . 
A.8 Declarations
Declarations specify theinterpretation given toeach identifier; they donotnecessarily reserve
storage associated with theidentifier. Declarations thatreserve storage arecalled definitions .
Declarations have the form 
    declaration :
      declaration-specifiers init-declarator-list opt; 
Thedeclarators intheinit-declarator listcontain theidentifiers being declared; thedeclaration-
specifiers consist of a sequence of type and storage class specifiers. 
    declaration-specifiers :
      storage-class-specifier declaration-specifiers opt
      type-specifier declaration-specifiers opt
      type-qualifier declaration-specifiers opt 
    init-declarator-list :
      init-declarator
      init-declarator-list  , init-declarator  
    init-declarator :
      declarator
      declarator  = initializer  
Declarators will bediscussed later (Par.A.8.5 );they contain thenames being declared. A
declaration must have atleast onedeclarator, oritstype specifier must declare astructure tag,
a union tag, or the members of an enumeration; empty declarations are not permitted. 
A.8.1 Storage Class Specifiers
The storage class specifiers are: 
    storage-class specifier :
      auto
      register171
      static
      extern
      typedef  
The meaning of the storage classes were discussed in Par.A.4.4 . 
Theauto andregister specifiers give thedeclared objects automatic storage class, andmay
beused only within functions. Such declarations also serve asdefinitions andcause storage to
bereserved. Aregister declaration isequivalent toanauto declaration, buthints that the
declared objects will beaccessed frequently. Only afew objects areactually placed into
registers, andonly certain types areeligible; therestrictions areimplementation-dependent.
However, ifanobject isdeclaredregister ,theunary&operator may notbeapplied toit,
explicitly or implicitly. 
The rule thatitisillegal tocalculate theaddress ofanobject declaredregister ,butactually taken
to be auto , is new. 
Thestatic specifier gives thedeclared objects static storage class, andmay beused either
inside oroutside functions. Inside afunction, thisspecifier causes storage tobeallocated, and
serves as a definition; for its effect outside a function, see Par.A.11.2 . 
Adeclaration withextern ,used inside afunction, specifies thatthestorage forthedeclared
objects is defined elsewhere; for its effects outside a function, see Par.A.11.2 . 
Thetypedef specifier does notreserve storage andiscalled astorage class specifier only for
syntactic convenience; it is discussed in Par.A.8.9 . 
Atmost onestorage class specifier may begiven inadeclaration. Ifnone isgiven, these rules
areused: objects declared inside afunction aretaken tobeauto ;functions declared within a
function aretaken tobeextern ;objects andfunctions declared outside afunction aretaken to
be static , with external linkage. See Pars. A.10 -A.11 . 
A.8.2 Type Specifiers
The type-specifiers are 
    type specifier :
      void
      char
      short
      int
      long
      float
      double
      signed
      unsigned
      struct-or-union-specifier
      enum-specifier
      typedef-name  
Atmost oneofthewordslong orshort may bespecified together withint;themeaning is
thesame ifintisnotmentioned. Thewordlong may bespecified together withdouble .At
most oneofsigned orunsigned may bespecified together withintoranyofitsshort or
long varieties, orwithchar .Either may appear alone inwhich caseintisunderstood. The
signed specifier isuseful forforcingchar objects tocarry asign; itispermissible but
redundant with other integral types. 172
Otherwise, atmost onetype-specifier may begiven inadeclaration. Ifthetype-specifier is
missing from a declaration, it is taken to be int. 
Types may also be qualified, to indicate special properties of the objects being declared. 
    type-qualifier :
      const
      volatile  
Type qualifiers may appear with anytype specifier. Aconst object may beinitialized, butnot
thereafter assigned to.There arenoimplementation-dependent semantics forvolatile
objects. 
Theconst andvolatile properties arenew with theANSI standard. Thepurpose ofconst isto
announce objects that may beplaced inread-only memory, andperhaps toincrease opportunities for
optimization. The purpose ofvolatile istoforce animplementation tosuppress optimization that
could otherwise occur. Forexample, foramachine with memory-mapped input/output, apointer toa
device register might bedeclared asapointer tovolatile ,inorder toprevent thecompiler from
removing apparently redundant references through thepointer. Except thatitshould diagnose explicit
attempts to change const  objects, a compiler may ignore these qualifiers. 
A.8.3 Structure and Union Declarations
Astructure isanobject consisting ofasequence ofnamed members ofvarious types. Aunion
isanobject thatcontains, atdifferent times, anyofseveral members ofvarious types. Structure
and union specifiers have the same form. 
    struct-or-union-specifier :
      struct-or-union identifier opt{ struct-declaration-list  }
      struct-or-union identifier  
    struct-or-union :
      struct
      union  
Astruct-declaration-list isasequence ofdeclarations forthemembers ofthestructure or
union: 
    struct-declaration-list :
      struct declaration
      struct-declaration-list struct declaration  
    struct-declaration :       specifier-qualifier-list struct-declarator-list ; 
    specifier-qualifier-list :
      type-specifier specifier-qualifier-list opt
      type-qualifier specifier-qualifier-list opt 
    struct-declarator-list :
      struct-declarator
      struct-declarator-list  , struct-declarator  
Usually, astruct-declarator isjust adeclarator foramember ofastructure orunion. A
structure member may also consist ofaspecified number ofbits. Such amember isalso called
a bit-field ; its length is set off from the declarator for the field name by a colon. 
    struct-declarator :
      declarator        declarator opt : constant-expression  173
A type specifier of the form 
    struct-or-union identifier  { struct-declaration-list  } 
declares theidentifier tobethetagofthestructure orunion specified bythelist.Asubsequent
declaration inthesame oraninner scope may refer tothesame type byusing thetagina
specifier without the list: 
    struct-or-union identifier  
Ifaspecifier with atagbutwithout alistappears when thetagisnotdeclared, anincomplete
type isspecified. Objects with anincomplete structure orunion type may bementioned in
contexts where their size isnotneeded, forexample indeclarations (not definitions), for
specifying apointer, orforcreating atypedef ,butnototherwise. Thetype becomes complete
onoccurrence ofasubsequent specifier with thattag,andcontaining adeclaration list.Even in
specifiers with alist,thestructure orunion type being declared isincomplete within thelist,
and becomes complete only at the } terminating the specifier. 
Astructure may notcontain amember ofincomplete type. Therefore, itisimpossible to
declare astructure orunion containing aninstance ofitself. However, besides giving aname to
thestructure orunion type, tags allow definition ofself-referential structures; astructure or
union may contain apointer toaninstance ofitself, because pointers toincomplete types may
be declared. 
A very special rule applies to declarations of the form 
    struct-or-union identifier ; 
that declare astructure orunion, buthave nodeclaration listandnodeclarators. Even ifthe
identifier isastructure orunion tagalready declared inanouter scope (Par.A.11.1 ),this
declaration makes theidentifier thetagofanew, incompletely-typed structure orunion inthe
current scope. 
This recondite isnew with ANSI. Itisintended todeal with mutually-recursive structures declared in
an inner scope, but whose tags might already be declared in the outer scope. 
Astructure orunion specifier with alistbutnotagcreates aunique type; itcanbereferred to
directly only in the declaration of which it is a part. 
Thenames ofmembers andtags donotconflict with each other orwith ordinary variables. A
member name may not appear twice in the same structure or union, but the same member name
may be used in different structures or unions. 
Inthefirst edition ofthisbook, thenames ofstructure andunion members were notassociated with
their parent. However, this association became common in compilers well before the ANSI standard. 
Anon-field member ofastructure orunion may have anyobject type. Afield member (which
need not have a declarator and thus may be unnamed) has type int, unsigned int , or signed
int,andisinterpreted asanobject ofintegral type ofthespecified length inbits; whether an
int field istreated assigned isimplementation-dependent. Adjacent field members of
structures arepacked into implementation-dependent storage units inanimplementation-
dependent direction. When afield following another field will notfitinto apartially-filled
storage unit, itmay besplit between units, ortheunitmay bepadded. Anunnamed field with
width 0forces thispadding, sothatthenext field willbegin attheedge ofthenext allocation
unit. 
The ANSI standard makes fields even more implementation-dependent than didthefirst edition. Itis
advisable toread thelanguage rules forstoring bit-fields as``implementation-dependent'' without
qualification. Structures with bit-fields may beused asaportable way ofattempting toreduce the
storage required forastructure (with theprobable cost ofincreasing theinstruction space, andtime,174
needed toaccess thefields), orasanon-portable way todescribe astorage layout known atthebit-
level. In the second case, it is necessary to understand the rules of the local implementation. 
Themembers ofastructure have addresses increasing intheorder oftheir declarations. Anon-
field member ofastructure isaligned atanaddressing boundary depending onitstype;
therefore, there may beunnamed holes inastructure. Ifapointer toastructure iscast tothe
type of a pointer to its first member, the result refers to the first member. 
Aunion may bethought ofasastructure allofwhose members begin atoffset 0andwhose
sizeissufficient tocontain anyofitsmembers. Atmost oneofthemembers canbestored ina
union atanytime. Ifapointr toaunion iscasttothetype ofapointer toamember, theresult
refers to that member. 
A simple example of a structure declaration is 
   struct tnode {
       char tword[20];
       int count;
       struct tnode *left;
       struct tnode *right;
   }
which contains anarray of20characters, aninteger, andtwo pointers tosimilar structures.
Once this declaration has bene given, the declaration 
   struct tnode s, *sp;
declaresstobeastructure ofthegiven sort, andsptobeapointer toastructure ofthegiven
sort. With these declarations, the expression 
   sp->count
refers to the count  field of the structure to which sp points; 
   s.left
refers to the left subtree pointer of the structure s, and 
   s.right->tword[0]
refers to the first character of the tword  member of the right subtree of s. 
Ingeneral, amember ofaunion may notbeinspected unless thevalue oftheunion hasbeen
assigned using thesame member. However, onespecial guarantee simplifies theuseofunions:
ifaunion contains several structures that share acommon initial sequence, and theunion
currently contains oneofthese structures, itispermitted torefer tothecommon initial part of
any of the contained structures. For example, the following is a legal fragment: 
   union {
       struct {
           int type;
       } n;
       struct {
           int type;
           int intnode;
       } ni;
       struct {
           int type;
           float floatnode;
       } nf;
   } u;
   ...
   u.nf.type = FLOAT;
   u.nf.floatnode = 3.14;
   ...
   if (u.n.type == FLOAT)175
       ... sin(u.nf.floatnode) ...
A.8.4 Enumerations
Enumerations areunique types with values ranging over asetofnamed constants called
enumerators. The form of an enumeration specifier borrows from that of structures and unions.
    enum-specifier :
      enum  identifier opt { enumerator-list  }
      enum  identifier  
    enumerator-list :
      enumerator
      enumerator-list  , enumerator  
    enumerator :
      identifier
      identifier  = constant-expression  
The identifiers inanenumerator listaredeclared asconstants oftypeint,andmay appear
wherever constants arerequired. Ifnoenumerations with=appear, then thevalues ofthe
corresponding constants begin at0andincrease by1asthedeclaration isread from leftto
right. Anenumerator with=gives theassociated identifier thevalue specified; subsequent
identifiers continue the progression from the assigned value. 
Enumerator names inthesame scope must allbedistinct from each other andfrom ordinary
variable names, but the values need not be distinct. 
The role oftheidentifier intheenum-specifier isanalogous tothat ofthestructure tagina
struct-specifier; itnames aparticular enumeration. The rules forenum-specifiers with and
without tags and lists arethesame asthose forstructure orunion specifiers, except that
incomplete enumeration types donotexist; thetagofanenum-specifier without anenumerator
list must refer to an in-scope specifier with a list. 
Enumerations arenew since thefirst edition ofthisbook, buthave been part ofthelanguage forsome
years. 
A.8.5 Declarators
Declarators have the syntax: 
    declarator :
      pointer opt direct-declarator  
    direct-declarator :
      identifier
      (declarator )
      direct-declarator  [ constant-expression opt ]
      direct-declarator  ( parameter-type-list  )
      direct-declarator  ( identifier-list opt ) 
    pointer :
      * type-qualifier-list opt
      * type-qualifier-list opt pointer  
    type-qualifier-list :
      type-qualifier
      type-qualifier-list type-qualifier  176
Thestructure ofdeclarators resembles thatofindirection, function, andarray expressions; the
grouping is the same. 
A.8.6 Meaning of Declarators
Alistofdeclarators appears after asequence oftype and storage class specifiers. Each
declarator declares aunique main identifier, theonethatappears asthefirst alternative ofthe
production fordirect-declarator .The storage class specifiers apply directly tothisidentifier,
butitstype depends ontheform ofitsdeclarator. Adeclarator isread asanassertion that
when itsidentifier appears inanexpression ofthesame form asthedeclarator, ityields an
object of the specified type. 
Considering only thetype parts ofthedeclaration specifiers (Par. A.8.2 )and aparticular
declarator, adeclaration hastheform ``TD,''whereTisatype andDisadeclarator. Thetype
attributed totheidentifier inthevarious forms ofdeclarator isdescribed inductively using this
notation. 
In a declaration T D where D is an unadored identifier, the type of the identifier is T. 
In a declaration T D where D has the form 
      ( D1 )
then thetype oftheidentifier inD1isthesame asthatofD.Theparentheses donotalter the
type, but may change the binding of complex declarators. 
A.8.6.1 Pointer Declarators
In a declaration T D where D has the form 
    * type-qualifier-list opt D1 
andthetype oftheidentifier inthedeclaration TD1is``type-modifier T,''thetype ofthe
identifier ofDis``type-modifier type-qualifier-list pointer toT.''Qualifiers following *apply to
pointer itself, rather than to the object to which the pointer points. 
For example, consider the declaration 
      int *ap[];
Here,ap[] plays therole ofD1;adeclaration ``intap[] ''(below) would giveapthetype
``array ofint,'' thetype-qualifier listisempty, andthetype-modifier is``array of.''Hence the
actual declaration gives ap the type ``array to pointers to int.'' 
As other examples, the declarations 
      int i, *pi, *const cpi = &i;
      const int ci = 3, *pci;
declare anintegeriandapointer toanintegerpi.Thevalue oftheconstant pointercpimay
notbechanged; itwillalways point tothesame location, although thevalue towhich itrefers
may bealtered. The integerciisconstant, and may notbechanged (though itmay be
initialized, ashere.) Thetype ofpciis``pointer toconstint,''andpciitself may bechanged
topoint toanother place, butthevalue towhich itpoints may notbealtered byassigning
through pci. 
A.8.6.2 Array Declarators
In a declaration T D where D has the form 
    D1 [ constant-expression opt] 177
andthetype oftheidentifier inthedeclaration TD1is``type-modifier T,''thetype ofthe
identifier ofDis``type-modifier array ofT.''Iftheconstant-expression ispresent, itmust have
integral type, andvalue greater than 0.Iftheconstant expression specifying thebound is
missing, the array has an incomplete type. 
Anarray may beconstructed from anarithmetic type, from apointer, from astructure or
union, orfrom another array (togenerate amulti-dimensional array). Any type from which an
array isconstructed must becomplete; itmust notbeanarray ofstructure ofincomplete type.
This implies that foramulti-dimensional array, only thefirst dimension may bemissing. The
type ofanobject ofincomplete aray type iscompleted byanother, complete, declaration for
the object ( Par.A.10.2 ), or by initializing it ( Par.A.8.7 ). For example, 
      float fa[17], *afp[17];
declares an array of float  numbers and an array of pointers to float  numbers. Also, 
      static int x3d[3][5][7];
declares astatic three-dimensional array ofintegers, with rank 3X5X7.Incomplete detail,
x3disanarray ofthree items: each item isanarray offivearrays; each ofthelatter arrays isan
array ofseven integers. Any oftheexpressions x3d,x3d[i] ,x3d[i][j] ,x3d[i][j][k] may
reasonably appear inanexpression. The first three have type ``array,'', thelasthastypeint.
More specifically, x3d[i][j] isanarray of7integers, andx3d[i] isanarray of5arrays of7
integers. 
Thearray subscripting operation isdefined sothatE1[E2] isidentical to*(E1+E2) .Therefore,
despite itsasymmetric appearance, subscripting isacommutative operation. Because ofthe
conversion rules thatapply to+andtoarrays (Pars. A6.6 ,A.7.1 ,A.7.7 ),ifE1isanarray and
E2 an integer, then E1[E2]  refers to the E2-th member of E1. 
Intheexample, x3d[i][j][k] isequivalent to*(x3d[i][j] +k).The first subexpression
x3d[i][j] isconverted byPar.A.7.1 totype ``pointer toarray ofintegers,'' byPar.A.7.7 ,the
addition involves multiplication bythesizeofaninteger. Itfollows from therules thatarrays
arestored byrows (last subscript varies fastest) andthatthefirst subscript inthedeclaration
helps determine theamount ofstorage consumed byanarray, butplays noother part in
subscript calculations. 
A.8.6.3 Function Declarators
In a new-style function declaration T D where D has the form 
    D1 (parameter-type-list ) 
andthetype oftheidentifier inthedeclaration TD1is``type-modifier T,''thetype ofthe
identifier of D is ``type-modifier  function with arguments parameter-type-list  returning T.'' 
The syntax of the parameters is 
    parameter-type-list :
      parameter-list
      parameter-list  , ...  
    parameter-list :
      parameter-declaration
      parameter-list  , parameter-declaration  
    parameter-declaration :
      declaration-specifiers declarator
      declaration-specifiers abstract-declarator opt 178
Inthenew-style declaration, theparameter listspecifies thetypes oftheparameters. Asa
special case, thedeclarator foranew-style function with noparameters hasaparameter list
consisting soley ofthekeyword void .Iftheparameter listends with anellipsis ``,...'',then
thefunction may accept more arguments than thenumber ofparameters explicitly described,
see Par.A.7.3.2 . 
Thetypes ofparameters thatarearrays orfunctions arealtered topointers, inaccordance with
therules forparameter conversions; seePar.A.10.1 .Theonly storage class specifier permitted
inaparameter's declaration isregister ,and thisspecifier isignored unless thefunction
declarator heads afunction definition. Similarly, ifthedeclarators intheparameter declarations
contain identifiers and thefunction declarator does not head afunction definition, the
identifiers gooutofscope immediately. Abstract declarators, which donotmention the
identifiers, are discussed in Par.A.8.8 . 
In an old-style function declaration T D where D has the form 
    D1(identifier-list opt) 
andthetype oftheidentifier inthedeclaration TD1is``type-modifier T,''thetype ofthe
identifier ofDis``type-modifier function ofunspecified arguments returning T.''The
parameters (if present) have the form 
    identifier-list :
      identifier
      identifier-list  , identifier  
Intheold-style declarator, theidentifier listmust beabsent unless thedeclarator isused inthe
head ofafunction definition (Par.A.10.1 ).Noinformation about thetypes oftheparameters is
supplied by the declaration. 
For example, the declaration 
      int f(), *fpi(), (*pfi)();
declares afunctionfreturning aninteger, afunctionfpireturning apointer toaninteger, and
apointerpfi toafunction returning aninteger. Innone ofthese aretheparameter types
specified; they are old-style. 
In the new-style declaration 
      int strcpy(char *dest, const char *source), rand(void);
strcpy isafunction returning int,with twoarguments, thefirst acharacter pointer, andthe
second apointer toconstant characters. The parameter names areeffectively comments. The
second function rand  takes no arguments and returns int. 
Function declarators with parameter prototypes are, byfar, themost important language change
introduced bytheANSI standard. They offer anadvantage over the``old-style'' declarators ofthefirst
edition byproviding error-detection and coercion ofarguments across function calls, butatacost:
turmoil andconfusion during their introduction, andthenecessity ofaccomodating both forms. Some
syntactic ugliness was required forthesake ofcompatibility, namelyvoid asanexplicit marker of
new-style functions without parameters. 
Theellipsis notation ``,...''forvariadic functions isalso new, and, together with themacros inthe
standard header<stdarg.h> ,formalizes amechanism thatwasofficially forbidden butunofficially
condoned in the first edition. 
These notations were adapted from the C++ language. 
A.8.7 Initialization179
When anobject isdeclared, itsinit-declarator may specify aninitial value fortheidentifier
being declared. The initializer ispreceded by=,and iseither anexpression, oralistof
initializers nested in braces. A list may end with a comma, a nicety for neat formatting. 
    initializer :
      assignment-expression
      { initializer-list  }
      { initializer-list  , } 
    initializer-list :
      initializer
      initializer-list  , initializer  
Alltheexpressions intheinitializer forastatic object orarray must beconstant expressions as
described inPar.A.7.19 .The expressions intheinitializer foranauto orregister object or
array must likewise beconstant expressions iftheinitializer isabrace-enclosed list.However,
iftheinitializer foranautomatic object isasingle expression, itneed notbeaconstant
expression, but must merely have appropriate type for assignment to the object. 
The first edition didnotcountenance initialization ofautomatic structures, unions, orarrays. The
ANSI standard allows it,butonly byconstant constructions unless theinitializer canbeexpressed bya
simple expression. 
Astatic object notexplicitly initialized isinitialized asifit(oritsmembers) were assigned the
constant 0. The initial value of an automatic object not explicitly intialized is undefined. 
The initializer forapointer oranobject ofarithmetic type isasingle expression, perhaps in
braces. The expression is assigned to the object. 
Theinitializer forastructure iseither anexpression ofthesame type, orabrace-enclosed list
ofinitializers foritsmembers inorder. Unnamed bit-field members areignored, andarenot
initialized. Ifthere arefewer initializers inthelistthan members ofthestructure, thetrailing
members areinitialized with 0.There may notbemore initializers than members. Unnamed bit-
field members are ignored,and are not initialized. 
The initializer for an array is a brace-enclosed list of initializers for its members. If the array has
unknown size, thenumber ofinitializers determines thesizeofthearray, anditstype becomes
complete. Ifthearray hasfixed size, thenumber ofinitializers may notexceed thenumber of
members of the array; if there are fewer, the trailing members are initialized with 0. 
Asaspecial case, acharacter array may beinitialized byastring literal; successive characters
ofthestring initialize successive members ofthearray. Similarly, awide character literal
(Par.A.2.6 )may initialize anarray oftypewchar_t .Ifthearray hasunknown size, thenumber
ofcharacters inthestring, including theterminating nullcharacter, determines itssize; ifits
sizeisfixed, thenumber ofcharacters inthestring, notcounting theterminating nullcharacter,
must not exceed the size of the array. 
The initializer foraunion iseither asingle expression ofthesame type, orabrace-enclosed
initializer for the first member of the union. 
The first edition didnotallow initialization ofunions. The ``first-member'' rule isclumsy, butishard
togeneralize without new syntax. Besides allowing unions tobeexplicitly initialized inatleast a
primitive way, this ANSI rule makes definite the semantics of static unions not explicitly initialized. 
Anaggregate isastructure orarray. Ifanaggregate contains members ofaggregate type, the
initialization rules apply recursively. Braces may beelided intheinitialization asfollows: ifthe
initializer foranaggregate's member thatitself isanaggregate begins with aleftbrace, then the
succeding comma-separated listofinitializers initializes themembers ofthesubaggregate; itis
erroneous forthere tobemore initializers than members. If,however, theinitializer fora180
subaggregate does notbegin with aleftbrace, then only enough elements from thelistare
taken into account forthemembers ofthesubaggregate; anyremaining members areleftto
initialize the next member of the aggregate of which the subaggregate is a part. 
For example, 
   int x[] = { 1, 3, 5 };
declares and initializes xasa1-dimensional array with three members, since nosize was
specified and there are three initializers. 
   float y[4][3] = {
       { 1, 3, 5 },
       { 2, 4, 6 },
       { 3, 5, 7 },
   };
isacompletely-bracketed initialization: 1,3and5initialize thefirst row ofthearrayy[0] ,
namelyy[0][0] ,y[0][1] ,andy[0][2] .Likewise thenext twolines initializey[1] andy[2] .
The initializer ends early, andtherefore theelements ofy[3] areinitialized with 0.Precisely
the same effect could have been achieved by 
   float y[4][3] = {
       1, 3, 5, 2, 4, 6, 3, 5, 7
   };
The initializer forybegins with aleftbrace, butthat fory[0] does not; therefore three
elements from thelistareused. Likewise thenext three aretaken successively fory[1] andfor
y[2] . Also, 
   float y[4][3] = {
       { 1 }, { 2 }, { 3 }, { 4 }
   };
initializes the first column of y (regarded as a two-dimensional array) and leaves the rest 0. 
Finally, 
   char msg[] = "Syntax error on line %s\n";
shows acharacter array whose members areinitialized with astring; itssize includes the
terminating null character. 
A.8.8 Type names
Inseveral contexts (tospecify type conversions explicitly with acast, todeclare parameter
types infunction declarators, andasargument ofsizeof )itisnecessary tosupply thename of
adata type. This isaccomplished using atype name ,which issyntactically adeclaration foran
object of that type omitting the name of the object. 
    type-name :
      specifier-qualifier-list abstract-declarator opt
    abstract-declarator :
      pointer
      pointer opt direct-abstract-declarator  
    direct-abstract-declarator :
      ( abstract-declarator  )
      direct-abstract-declarator opt [constant-expression opt]
      direct-abstract-declarator opt (parameter-type-list opt) 181
Itispossible toidentify uniquely thelocation intheabstract-declarator where theidentifier
would appear iftheconstruction were adeclarator inadeclaration. Thenamed type isthen the
same as the type of the hypothetical identifier. For example, 
   int
   int *
   int *[3]
   int (*)[]
   int *()
   int (*[])(void)
name respectively thetypes ``integer,'' ``pointer tointeger,'' ``array of3pointers tointegers,''
``pointer toanunspecified number ofintegers,'' ``function ofunspecified parameters returning
pointer tointeger,'' and``array, ofunspecified size, ofpointers tofunctions with noparameters
each returning an integer.'' 
A.8.9 Typedef
Declarations whose storage class specifier istypedef donotdeclare objects; instead they
define identifiers that name types. These identifiers are called typedef names. 
    typedef-name :
      identifier  
Atypedef declaration attributes atype toeach name among itsdeclarators intheusual way
(see Par.A.8.6 ).Thereafter, each such typedef name issyntactically equivalent toatype
specifier keyword for the associated type. 
For example, after 
   typedef long Blockno, *Blockptr;
   typedef struct { double r, theta; } Complex;
the constructions 
   Blockno b;
   extern Blockptr bp;
   Complex z, *zp;
arelegal declarations. The type ofbislong ,thatofbpis``pointer tolong ,''andthatofzis
the specified structure; zp is a pointer to such a structure. 
typedef does notintroduce new types, only synonyms fortypes that could bespecified in
another way. In the example, b has the same type as any long  object. 
Typedef names may beredeclared inaninner scope, butanon-empty setoftype specifiers
must be given. For example, 
   extern Blockno;
does not redeclare Blockno , but 
   extern int Blockno;
does. 
A.8.10 Type Equivalence
Two type specifier lists areequivalent ifthey contain thesame setoftype specifiers, taking
into account that some specifiers canbeimplied byothers (for example, long alone implies
longint).Structures, unions, andenumerations with different tags aredistinct, andatagless
union, structure, or enumeration specifies a unique type. 182
Two types arethesame iftheir abstract declarators (Par.A.8.8 ),after expanding anytypedef
types, anddeleting anyfunction parameter specifiers, arethesame uptotheequivalence of
type specifier lists. Array sizes and function parameter types are significant. 
A.9 Statements
Except asdescribed, statements areexecuted insequence. Statements areexecuted fortheir
effect, and do not have values. They fall into several groups. 
    statement :
      labeled-statement
      expression-statement
      compound-statement
      selection-statement
      iteration-statement
      jump-statement  
A.9.1 Labeled Statements
Statements may carry label prefixes. 
    labeled-statement :
      identifier  : statement
      case  constant-expression  : statement
      default :  statement  
Alabel consisting ofanidentifier declares theidentifier. Theonly useofanidentifier label isas
atarget ofgoto .Thescope oftheidentifier isthecurrent function. Because labels have their
own name space, they donotinterfere with other identifiers andcannot beredeclared. See
Par.A.11.1 . 
Case labels anddefault labels areused with theswitch statement (Par.A.9.4 ).The constant
expression of case  must have integral type. 
Labels themselves do not alter the flow of control. 
A.9.2 Expression Statement
Most statements are expression statements, which have the form 
    expression-statement :
      expression opt; 
Most expression statements areassignments orfunction calls. Allside effects from the
expression arecompleted before thenext statement isexecuted. Iftheexpression ismissing,
theconstruction iscalled anull statement; itisoften used tosupply anempty body toan
iteration statement to place a label. 
A.9.3 Compound Statement
Sothatseveral statements canbeused where oneisexpected, thecompound statement (also
called ``block'') is provided. The body of a function definition is a compound statement. 
    compound-statement :
      { declaration-list opt statement-list opt } 
    declaration-list :
      declaration
      declaration-list declaration  183
    statement-list :
      statement
      statement-list statement  
Ifanidentifier inthedeclaration-list was inscope outside theblock, theouter declaration is
suspended within theblock (seePar.A.11.1 ),after which itresumes itsforce. Anidentifier may
bedeclared only once inthesame block. These rules apply toidentifiers inthesame name
space ( Par.A.11 ); identifiers in different name spaces are treated as distinct. 
Initialization ofautomatic objects isperformed each time theblock isentered atthetop, and
proceeds intheorder ofthedeclarators. Ifajump into theblock isexecuted, these
initializations arenotperformed. Initialization ofstatic objects areperformed only once,
before the program begins execution. 
A.9.4 Selection Statements
Selection statements choose one of several flows of control. 
    selection-statement :
      if (expression ) statement
      if (expression ) statement  else  statement
      switch  (expression ) statement  
Inboth forms oftheifstatement, theexpression, which must have arithmetic orpointer type,
isevaluated, including allsideeffects, andifitcompares unequal to0,thefirstsubstatement is
executed. Inthesecond form, thesecond substatement isexecuted iftheexpression is0.The
else ambiguity isresolved byconnecting anelse with thelastencountered else -lessifat
the same block nesting level. 
Theswitch statement causes control tobetransferred tooneofseveral statements depending
onthevalue ofanexpression, which must have integral type. Thesubstatement controlled bya
switch istypically compound. Any statement within thesubstatement may belabeled with one
ormorecase labels (Par.A.9.1 ).The controlling expression undergoes integral promotion
(Par.A.6.1 ),andthecase constants areconverted tothepromoted type. Notwoofthese case
constants associated with thesame switch may have thesame value after conversion. There
may also beatmost onedefault label associated with aswitch. Switches may benested; a
case  or default  label is associated with the smallest switch that contains it. 
When theswitch statement isexecuted, itsexpression isevaluated, including allside effects,
andcompared with each case constant. Ifoneofthecase constants isequal tothevalue ofthe
expression, control passes tothestatement ofthematched case label. Ifnocase constant
matches theexpression, andifthere isadefault label, control passes tothelabeled statement.
Ifnocase matches, andifthere isnodefault ,then none ofthesubstatements oftheswtich is
executed. 
Inthefirst edition ofthisbook, thecontrolling expression ofswitch ,andthecase constants, were
required to have int type. 
A.9.5 Iteration Statements
Iteration statements specify looping. 
    iteration-statement :
      while  (expression ) statement
      do statement  while  (expression );
      for (expression opt; expression opt; expression opt) statement  184
Inthewhile anddostatements, thesubstatement isexecuted repeatedly solong asthevalue
oftheexpression remains unequal to0;theexpression must have arithmetic orpointer type.
Withwhile ,thetest, including allside effects from theexpression, occurs before each
execution of the statement; with do, the test follows each iteration. 
Intheforstatement, thefirstexpression isevaluated once, andthus specifies initialization for
theloop. There isnorestriction onitstype. The second expression must have arithmetic or
pointer type; itisevaluated before each iteration, andifitbecomes equal to0,thefor is
terminated. The third expression isevaluated after each iteration, and thus specifies are-
initialization fortheloop. There isnorestriction onitstype. Side-effects from each expression
arecompleted immediately after itsevaluation. Ifthesubstatement does notcontaincontinue ,
a statement 
    for (expression1 ; expression2 ; expression3 ) statement  
is equivalent to 
expression1 ;
while (expression2 ) {
    statement
    expression3 ;
}
Any ofthethree expressions may bedropped. Amissing second expression makes theimplied
test equivalent to testing a non-zero element. 
A.9.6 Jump statements
Jump statements transfer control unconditionally. 
    jump-statement :
      goto  identifier;
      continue;
      break;
      return  expression opt; 
Inthegoto statement, theidentifier must bealabel (Par.A.9.1 )located inthecurrent function.
Control transfers to the labeled statement. 
Acontinue statement may appear only within aniteration statement. Itcauses control topass
totheloop-continuation portion ofthesmallest enclosing such statement. More precisely,
within each of the statements 
   while (...) {       do {                 for (...) {
     ...                 ...                  ...
   contin: ;           contin: ;            contin: ;
   }                   } while (...);       }
a continue  not contained in a smaller iteration statement is the same as goto contin . 
Abreak statement may appear only inaniteration statement oraswitch statement, and
terminates execution ofthesmallest enclosing such statement; control passes tothestatement
following the terminated statement. 
Afunction returns toitscaller bythereturn statement. Whenreturn isfollowed byan
expression, thevalue isreturned tothecaller ofthefunction. The expression isconverted, as
by assignment, to the type returned by the function in which it appears. 
Flowing offtheendofafunction isequivalent toareturn with noexpression. Ineither case,
the returned value is undefined. 185
A.10 External Declarations
The unit ofinput provided totheCcompiler iscalled atranslation unit; itconsists ofa
sequence of external declarations, which are either declarations or function definitions. 
    translation-unit :
      external-declaration
      translation-unit external-declaration  
    external-declaration :
      function-definition
      declaration  
Thescope ofexternal declarations persists totheendofthetranslation unitinwhich they are
declared, justastheeffect ofdeclarations within theblocks persists totheendoftheblock.
The syntax ofexternal declarations isthesame asthatofalldeclarations, except thatonly at
this level may the code for functions be given. 
A.10.1 Function Definitions
Function definitions have the form 
    function-definition :
      declaration-specifiers opt declarator declaration-list opt compound-statement  
The only storage-class specifiers allowed among thedeclaration specifiers areextern or
static ; see Par.A.11.2  for the distinction between them. 
Afunction may return anarithmetic type, astructure, aunion, apointer, orvoid ,butnota
function oranarray. The declarator inafunction declaration must specify explicitly that the
declared identifier has function type; that is, it must contain one of the forms (see Par.A.8.6.3 ).
      direct-declarator  ( parameter-type-list  )
      direct-declarator  ( identifier-list opt ) 
where thedirect-declarator isanidentifier oraparenthesized identifier. Inparticular, itmust
not achieve function type by means of a typedef . 
Inthefirst form, thedefinition isanew-style function, anditsparameters, together with their
types, aredeclared initsparameter type list; thedeclaration-list following thefunction's
declarator must beabsent. Unless theparameter type listconsists solely ofvoid ,showing that
thefunction takes noparameters, each declarator intheparameter type listmust contain an
identifier. Iftheparameter type listends with ``,...''then thefunction may becalled with
more arguments than parameters; theva_arg macro mechanism defined inthestandard header
<stdarg.h> and described inAppendix B must beused torefer totheextra arguments.
Variadic functions must have at least one named parameter. 
Inthesecond form, thedefinition isold-style: theidentifier listnames theparameters, while the
declaration listattributes types tothem. Ifnodeclaration isgiven foraparameter, itstype is
taken tobeint.The declaration listmust declare only parameters named inthelist,
initialization is not permitted, and the only storage-class specifier possible is register . 
Inboth styles offunction definition, theparameters areunderstood tobedeclared justafter the
beginning ofthecompound statement constituting thefunction's body, and thus thesame
identifiers must notberedeclared there (although they may, likeother identifiers, beredeclared
ininner blocks). Ifaparameter isdeclared tohave type ``array oftype,''thedeclaration is
adjusted toread ``pointer totype;''similarly, ifaparameter isdeclared tohave type ``function186
returning type,''thedeclaration isadjusted toread ``pointer tofunction returning type.''During
thecall toafunction, thearguments areconverted asnecessary and assigned tothe
parameters; see Par.A.7.3.2 . 
New-style function definitions arenew with theANSI standard. There isalso asmall change inthe
details ofpromotion; thefirst edition specified that thedeclarations offloat parameters were
adjusted toreaddouble .The difference becomes noticable when apointer toaparameter is
generated within a function. 
A complete example of a new-style function definition is 
   int max(int a, int b, int c)
   {
       int m;
       m = (a > b) ? a : b;
       return (m > c) ? m : c;
   }
Here int is the declaration specifier; max(int a, int b, int c)  is the function's declarator,
and{...}istheblock giving thecode forthefunction. The corresponding old-style
definition would be 
   int max(a, b, c)
   int a, b, c;
   {
       /* ... */
   }
where nowintmax(a,b,c)isthedeclarator, andinta,b,c;isthedeclaration listfor
the parameters. 
A.10.2 External Declarations
External declarations specify thecharacteristics ofobjects, functions andother identifiers. The
term ``external'' refers totheir location outside functions, andisnotdirectly connected with the
extern keyword; thestorage class foranexternally-declared object may beleftempty, orit
may be specified as extern  or static . 
Several external declarations for the same identifier may exist within the same translation unit if
they agree in type and linkage, and if there is at most one definition for the identifier. 
Two declarations foranobject orfunction aredeemed toagree intype under therule
discussed in Par.A.8.10 . In addition, if the declarations differ because one type is an incomplete
structure, union, orenumeration type (Par.A.8.3 )andtheother isthecorresponding completed
type with thesame tag,thetypes aretaken toagree. Moreover, ifonetype isanincomplete
array type (Par.A.8.6.2 )and theother isacompleted array type, thetypes, ifotherwise
identical, arealso taken toagree. Finally, ifonetype specifies anold-style function, andthe
other anotherwise identical new-style function, with parameter declarations, thetypes are
taken to agree. 
Ifthefirst external declarator forafunction orobject includes thestatic specifier, the
identifier hasinternal linkage ;otherwise ithasexternal linkage .Linkage isdiscussed in
Par.11.2 . 
Anexternal declaration foranobject isadefinition ifithasaninitializer. Anexternal object
declaration that does nothave aninitializer, anddoes notcontain theextern specifier, isa
tentative definition .Ifadefinition foranobject appears inatranslation unit, anytentative
definitions aretreated merely asredundant declarations. Ifnodefinition fortheobject appears
in the translation unit, all its tentative definitions become a single definition with initializer 0. 187
Each object must have exactly onedefinition. Forobjects with internal linkage, thisruleapplies
separately toeach translation unit, because internally-linked objects areunique toatranslation
unit. For objects with external linkage, it applies to the entire program. 
Although theone-definition ruleisformulated somewhat differently inthefirst edition ofthisbook, it
isineffect identical totheonestated here. Some implementations relax itbygeneralizing thenotion
oftentative definition. Inthealternate formulation, which isusual inUNIX systems andrecognized as
acommon extension bytheStandard, allthetentative definitions foranexternally linked object,
throughout allthetranslation units oftheprogram, areconsidered together instead ofineach
translation unit separately. Ifadefinition occurs somewhere intheprogram, then thetentative
definitions become merely declarations, butifnodefinition appears, then allitstentative definitions
become a definition with initializer 0. 
A.11 Scope and Linkage
Aprogram need notallbecompiled atonetime: thesource textmay bekept inseveral files
containing translation units, and precompiled routines may beloaded from libraries.
Communication among thefunctions ofaprogram may becarried outboth through calls and
through manipulation of external data. 
Therefore, there aretwo kinds ofscope toconsider: first, thelexical scope ofanidentifier
which istheregion oftheprogram text within which theidentifier's characteristics are
understood; andsecond, thescope associated with objects andfunctions with external linkage,
which determines the connections between identifiers in separately compiled translation units. 
A.11.1 Lexical Scope
Identifiers fallinto several name spaces that donotinterfere with one another; thesame
identifier may beused fordifferent purposes, even inthesame scope, iftheuses areindifferent
name spaces. These classes are:objects, functions, typedef names, andenum constants; labels;
tags ofstructures orunions, and enumerations; and members ofeach structure orunion
individually. 
These rules differ inseveral ways from those described inthefirst edition ofthismanual. Labels did
notpreviously have their own name space; tags ofstructures andunions each hadaseparate space,
andinsome implementations enumerations tags didaswell; putting different kinds oftags into the
same space isanew restriction. The most important departure from thefirst edition isthat each
structure or union creates a separate name space for its members, so that the same name may appear in
several different structures. This rule has been common practice for several years. 
Thelexical scope ofanobject orfunction identifier inanexternal declaration begins attheend
ofitsdeclarator andpersists totheendofthetranslation unitinwhich itappears. Thescope of
aparameter ofafunction definition begins atthestart oftheblock defining thefunction, and
persists through thefunction; thescope ofaparameter inafunction declaration ends attheend
ofthedeclarator. Thescope ofanidentifier declared atthehead ofablock begins attheendof
itsdeclarator, andpersists totheendoftheblock. The scope ofalabel isthewhole ofthe
function inwhich itappears. The scope ofastructure, union, orenumeration tag, oran
enumeration constant, begins atitsappearance inatype specifier, andpersists totheendofa
translation unit (for declarations attheexternal level) ortotheend oftheblock (for
declarations within a function). 
Ifanidentifier isexplicitly declared atthehead ofablock, including theblock constituting a
function, anydeclaration oftheidentifier outside theblock issuspended until theendofthe
block. 
A.11.2 Linkage
Within atranslation unit, alldeclarations ofthesame object orfunction identifier with internal
linkage refer tothesame thing, andtheobject orfunction isunique tothattranslation unit. All188
declarations forthesame object orfunction identifier with external linkage refer tothesame
thing, and the object or function is shared by the entire program. 
Asdiscussed inPar.A.10.2 ,thefirst external declaration foranidentifier gives theidentifier
internal linkage ifthestatic specifier isused, external linkage otherwise. Ifadeclaration for
anidentifier within ablock does notinclude theextern specifier, then theidentifier hasno
linkage andisunique tothefunction. Ifitdoes includeextern ,andanexternal declaration for
isactive inthescope surrounding theblock, then theidentifier hasthesame linkage asthe
external declaration, andrefers tothesame object orfunction; butifnoexternal declaration is
visible, its linkage is external. 
A.12 Preprocessing
Apreprocessor performs macro substitution, conditional compilation, andinclusion ofnamed
files. Lines beginning with#,perhaps preceded bywhite space, communicate with this
preprocessor. The syntax ofthese lines isindependent oftherestofthelanguage; they may
appear anywhere and have effect that lasts (independent ofscope) until theend ofthe
translation unit. Line boundaries aresignificant; each lineisanalyzed individually (bus see
Par.A.12.2 forhow toadjoin lines). Tothepreprocessor, atoken isanylanguage token, ora
character sequence giving afilename asinthe#include directive (Par.A.12.4 );inaddition,
anycharacter nototherwise defined istaken asatoken. However, theeffect ofwhite spaces
other than space and horizontal tab is undefined within preprocessor lines. 
Preprocessing itself takes place inseveral logically successive phases thatmay, inaparticular
implementation, be condensed. 
1.First, trigraph sequences asdescribed inPar.A.12.1 arereplaced bytheir equivalents.
Should theoperating system environment require it,newline characters areintroduced
between the lines of the source file. 
2.Each occurrence ofabackslash character \followed byanewline isdeleted, this
splicing lines ( Par.A.12.2 ). 
3.The program issplit into tokens separated bywhite-space characters; comments are
replaced byasingle space. Then preprocessing directives areobeyed, and macros
(Pars. A.12.3 -A.12.10 ) are expanded. 
4.Escape sequences incharacter constants andstring literals (Pars. A.2.5.2 ,A.2.6 )are
replaced by their equivalents; then adjacent string literals are concatenated. 
5.The result istranslated, then linked together with other programs and libraries, by
collecting thenecessary programs and data, and connecting external functions and
object references to their definitions. 
A.12.1 Trigraph Sequences
Thecharacter setofCsource programs iscontained within seven-bit ASCII, butisasuperset
oftheISO 646-1983 Invariant Code Set.Inorder toenable programs toberepresented inthe
reduced set, alloccurrences ofthe following trigraph sequences arereplaced bythe
corresponding single character. This replacement occurs before any other processing. 
         ??=  #            ??(  [            ??<  {
         ??/  \            ??)  ]            ??>  }
         ??'  ^            ??!  |            ??-  ~
No other such replacements occur. 
Trigraph sequences are new with the ANSI standard. 
A.12.2 Line Splicing189
Lines that endwith thebackslash character \arefolded bydeleting thebackslash andthe
following newline character. This occurs before division into tokens. 
A.12.3 Macro Definition and Expansion
A control line of the form 
    # define  identifier token-sequence  
causes thepreprocessor toreplace subsequent instances oftheidentifier with thegiven
sequence oftokens; leading andtrailing white space around thetoken sequence isdiscarded. A
second#define forthesame identifier iserroneous unless thesecond token sequence is
identical to the first, where all white space separations are taken to be equivalent. 
A line of the form 
    # define  identifier  (identifier-list ) token-sequence  
where there isnospace between thefirst identifier and the(,isamacro definition with
parameters given bytheidentifier list.Aswith thefirst form, leading andtrailing white space
arround the token sequence is discarded, and the macro may be redefined only with a definition
in which the number and spelling of parameters, and the token sequence, is identical. 
A control line of the form 
    # undef  identifier  
causes theidentifier's preprocessor definition tobeforgotten. Itisnoterroneous toapply
#undef  to an unknown identifier. 
When amacro hasbeen defined inthesecond form, subsequent textual instances ofthemacro
identifier followed byoptional white space, andthen by(,asequence oftokens separated by
commas, anda)constitute acallofthemacro. The arguments ofthecallarethecomma-
separated token sequences; commas thatarequoted orprotected bynested parentheses donot
separate arguments. During collection, arguments arenotmacro-expanded. The number of
arguments inthecall must match thenumber ofparameters inthedefinition. After the
arguments areisolated, leading andtrailing white space isremoved from them. Then thetoken
sequence resulting from each argument issubstituted foreach unquoted occurrence ofthe
corresponding parameter's identifier inthereplacement token sequence ofthemacro. Unless
theparameter inthereplacement sequence ispreceded by#,orpreceded orfollowed by##,
theargument tokens areexamined formacro calls, andexpanded asnecessary, justbefore
insertion. 
Two special operators influence thereplacement process. First, ifanoccurrence ofaparameter
inthereplacement token sequence isimmediately preceded by#,string quotes (")areplaced
around thecorresponding parameter, andthen both the#andtheparameter identifier are
replaced bythequoted argument. A\character isinserted before each"or\character that
appears surrounding, or inside, a string literal or character constant in the argument. 
Second, ifthedefinition token sequence foreither kind ofmacro contains a##operator, then
justafter replacement oftheparameters, each##isdeleted, together with anywhite space on
either side, soastoconcatenate theadjacent tokens andform anew token. The effect is
undefined ifinvalid tokens areproduced, oriftheresult depends ontheorder ofprocessing of
the##operators. Also,##may notappear atthebeginning orendofareplacement token
sequence. 190
Inboth kinds ofmacro, thereplacement token sequence isrepeatedly rescanned formore
defined identifiers. However, once agiven identifier hasbeen replaced inagiven expansion, it
is not replaced if it turns up again during rescanning; instead it is left unchanged. 
Even ifthefinal value ofamacro expansion begins with with#,itisnottaken tobea
preprocessing directive. 
The details ofthemacro-expansion process aredescribed more precisely intheANSI standard than in
thefirst edition. The most important change istheaddition ofthe#and##operators, which make
quotation and concatenation admissible. Some ofthe new rules, especially those involving
concatenation, are bizarre. (See example below.) 
For example, this facility may be used for ``manifest-constants,'' as in 
   #define TABSIZE 100
   int table[TABSIZE];
The definition 
   #define ABSDIFF(a, b)  ((a)>(b) ? (a)-(b) : (b)-(a))
defines amacro toreturn theabsolute value ofthedifference between itsarguments. Unlike a
function todothesame thing, thearguments andreturned value may have anyarithmetic type
oreven bepointers. Also, thearguments, which might have side effects, areevaluated twice,
once for the test and once to produce the value. 
Given the definition 
   #define tempfile(dir)    #dir "%s"
the macro call tempfile(/usr/tmp)  yields 
   "/usr/tmp" "%s"
which will subsequently be catenated into a single string. After 
   #define cat(x, y)       x ## y
thecallcat(var, 123) yieldsvar123 .However, thecallcat(cat(1,2),3) isundefined: the
presence of##prevents thearguments oftheouter callfrom being expanded. Thus itproduces
the token string 
   cat  (  1  ,  2  )3
and)3(thecatenation ofthelasttoken ofthefirstargument with thefirsttoken ofthesecond)
is not a legal token. If a second level of macro definition is introduced, 
   #define xcat(x, y)      cat(x,y)
things work more smoothly; xcat(xcat(1, 2),3)does produce123,because theexpansion
of xcat  itself does not involve the ## operator. 
Likewise, ABSDIFF(ABSDIFF(a,b),c)  produces the expected, fully-expanded result. 
A.12.4 File Inclusion
A control line of the form 
  # include < filename> 
causes thereplacement ofthatlinebytheentire contents ofthefilefilename .Thecharacters in
thename filename must notinclude>ornewline, andtheeffect isundefined ifitcontains any
of",',\,or/*.The named fileissearched forinasequence ofimplementation-defined
places. 
Similarly, a control line of the form 
  # include " filename" 191
searches first inassociation with theoriginal source file(adeliberately implementation-
dependent phrase), andifthatsearch fails, then asinthefirstform. Theeffect ofusing',\,or
/* in the filename remains undefined, but > is permitted. 
Finally, a directive of the form 
  # include  token-sequence  
notmatching oneoftheprevious forms isinterpreted byexpanding thetoken sequence asfor
normal text; oneofthetwo forms with<...> or"..." must result, andisthen treated as
previously described. 
#include  files may be nested. 
A.12.5 Conditional Compilation
Parts ofaprogram may becompiled conditionally, according tothefollowing schematic
syntax. 
    preprocessor-conditional :
      if-line text elif-parts else-part opt #endif  
    if-line :
      # if  constant-expression
      # ifdef  identifier
      # ifndef  identifier  
    elif-parts :
      elif-line text
      elif-parts opt 
    elif-line :
      # elif  constant-expression  
    else-part :
      else-line text  
    else-line :
      #else  
Each ofthedirectives (if-line, elif-line, else-line, and#endif )appears alone onaline. The
constant expressions in#if and subsequent #elif lines areevaluated inorder until an
expression with anon-zero value isfound; textfollowing alinewith azero value isdiscarded.
The textfollowing thesuccessful directive lineistreated normally. ``Text'' here refers toany
material, including preprocessor lines, that isnotpart oftheconditional structure; itmay be
empty. Once asuccessful #ifor#elif linehasbeen found anditstextprocessed, succeeding
#elif and#else lines, together with their text, arediscarded. Ifalltheexpressions arezero,
andthere isan#else ,thetext following the#else istreated normally. Text controlled by
inactive arms of the conditional is ignored except for checking the nesting of conditionals. 
The constant expression in#if and#elif issubject toordinary macro replacement.
Moreover, any expressions of the form 
    defined  identifier  
or 
    defined  (identifier ) 192
arereplaced, before scanning formacros, by1Liftheidentifier isdefined inthepreprocessor,
andby0Lifnot. Any identifiers remaining after macro expansion arereplaced by0L.Finally,
each integer constant isconsidered tobesuffixed withL,sothatallarithmetic istaken tobe
long or unsigned long. 
The resulting constant expression (Par.A.7.19 )isrestricted: itmust beintegral, andmay not
contain sizeof , a cast, or an enumeration constant. 
The control lines 
    #ifdef  identifier
    #ifndef  identifier  
are equivalent to 
    # if defined  identifier
    # if ! defined  identifier  
respectively. 
#elif isnew since thefirst edition, although ithasbeen available issome preprocessors. The
defined  preprocessor operator is also new. 
A.12.6 Line Control
For the benefit of other preprocessors that generate C programs, a line in one of the forms 
    # line  constant  "filename"
    # line  constant  
causes thecompiler tobelieve, forpurposes oferror diagnostics, that thelinenumber ofthe
next source lineisgiven bythedecimal integer constant andthecurrent input fileisnamed by
theidentifier. Ifthequoted filename isabsent, theremembered name does notchange. Macros
in the line are expanded before it is interpreted. 
A.12.7 Error Generation
A preprocessor line of the form 
    # error  token-sequence opt 
causes the preprocessor to write a diagnostic message that includes the token sequence. 
A.12.8 Pragmas
A control line of the form 
    # pragma  token-sequence opt 
causes thepreprocessor toperform animplementation-dependent action. Anunrecognized
pragma is ignored. 
A.12.9 Null directive
A control line of the form 
    # 
has no effect. 
A.12.10 Predefined names193
Several identifiers arepredefined, andexpand toproduce special information. They, andalso
the preprocessor expansion operator defined , may not be undefined or redefined. 
__LINE__ A decimal constant containing the current source line number.
__FILE__ A string literal containing the name of the file being compiled.
__DATE__ A string literal containing the date of compilation, in the form "Mmmm dd yyyy"
__TIME__ A string literal containing the time of compilation, in the form "hh:mm:ss"
__STDC__The constant 1. It is intended that this identifier be defined to be 1 only in standard-
conforming implementations.
#error and#pragma arenew with theANSI standard; thepredefined preprocessor macros are
new, but some of them have been available in some implementations. 
A.13 Grammar
Below isarecapitulation ofthegrammar that was given throughout theearlier part ofthis
appendix. It has exactly the same content, but is in different order. 
The grammar hasundefined terminal symbols integer-constant ,character-constant ,floating-
constant ,identifier ,string ,and enumeration-constant ;thetypewriter style words and
symbols areterminals given literally. This grammar canbetransformed mechanically intoinput
acceptable foranautomatic parser-generator. Besides adding whatever syntactic marking is
used toindicate alternatives inproductions, itisnecessary toexpand the ``one of''
constructions, and (depending ontherules oftheparser-generator) toduplicate each
production with anoptsymbol, once with thesymbol andonce without. With one further
change, namely deleting theproduction typedef-name :identifier andmaking typedef-name a
terminal symbol, thisgrammar isacceptable totheYACC parser-generator. Ithasonly one
conflict, generated by the if-else  ambiguity. 
    translation-unit :
      external-declaration
      translation-unit external-declaration  
    external-declaration :
      function-definition
      declaration  
    function-definition :
      declaration-specifiers opt declarator declaration-list opt compound-statement  
    declaration :
      declaration-specifiers init-declarator-list opt; 
    declaration-list :
      declaration
      declaration-list declaration  
    declaration-specifiers :
      storage-class-specifier declaration-specifiers opt
      type-specifier declaration-specifiers opt
      type-qualifier declaration-specifiers opt 
    storage-class specifier : one of
      auto register static extern typedef  
    type specifier : one of
      void char short int long float double signed
      unsigned  struct-or-union-specifier enum-specifier typedef-name  194
    type-qualifier : one of
      const volatile  
    struct-or-union-specifier :
      struct-or-union identifier opt { struct-declaration-list  }
      struct-or-union identifier  
    struct-or-union : one of
      struct union  
    struct-declaration-list :
      struct declaration
      struct-declaration-list struct declaration  
    init-declarator-list :
      init-declarator
      init-declarator-list , init-declarator  
    init-declarator :
      declarator
      declarator  = initializer  
    struct-declaration :
      specifier-qualifier-list struct-declarator-list ; 
    specifier-qualifier-list :
      type-specifier specifier-qualifier-list opt
      type-qualifier specifier-qualifier-list opt 
    struct-declarator-list :
      struct-declarator
      struct-declarator-list  , struct-declarator  
    struct-declarator :
      declarator
      declarator opt : constant-expression  
    enum-specifier :
      enum  identifier opt { enumerator-list  }
      enum  identifier  
    enumerator-list :
      enumerator
      enumerator-list  , enumerator  
    enumerator :
      identifier
      identifier  = constant-expression  
    declarator :
      pointer opt direct-declarator  
    direct-declarator :
      identifier
      (declarator )
      direct-declarator  [ constant-expression opt ]195
      direct-declarator  ( parameter-type-list  )
      direct-declarator  ( identifier-list opt ) 
    pointer :
      * type-qualifier-list opt
      * type-qualifier-list opt pointer  
    type-qualifier-list :
      type-qualifier
      type-qualifier-list type-qualifier  
    parameter-type-list :
      parameter-list
      parameter-list  , ...  
    parameter-list :
      parameter-declaration
      parameter-list  , parameter-declaration  
    parameter-declaration :
      declaration-specifiers declarator
      declaration-specifiers abstract-declarator opt 
    identifier-list :
      identifier
      identifier-list  , identifier  
    initializer :
      assignment-expression
      { initializer-list  }
      { initializer-list  , } 
    initializer-list :
      initializer
      initializer-list  , initializer  
    type-name :
      specifier-qualifier-list abstract-declarator opt 
    abstract-declarator :
      pointer
      pointer opt direct-abstract-declarator  
    direct-abstract-declarator :
      ( abstract-declarator  )
      direct-abstract-declarator opt [constant-expression opt]
      direct-abstract-declarator opt (parameter-type-list opt) 
    typedef-name :
      identifier  
    statement :
      labeled-statement
      expression-statement
      compound-statement
      selection-statement196
      iteration-statement
      jump-statement  
    labeled-statement :
      identifier  : statement
      case  constant-expression  : statement
      default :  statement  
    expression-statement :
      expression opt; 
    compound-statement :
      { declaration-list opt statement-list opt } 
    statement-list :
      statement
      statement-list statement  
    selection-statement :
      if (expression ) statement
      if (expression ) statement  else  statement
      switch  (expression ) statement  
    iteration-statement :
      while  (expression ) statement
      do statement  while  (expression );
      for (expression opt; expression opt; expression opt) statement  
    jump-statement :
      goto  identifier;
      continue;
      break;
      return  expression opt; 
    expression :
      assignment-expression
      expression  , assignment-expression  
    assignment-expression :
      conditional-expression
      unary-expression assignment-operator assignment-expression  
    assignment-operator : one of
      = *= /= %= += -= <<= >>= &= ^= |=  
    conditional-expression :
      logical-OR-expression
      logical-OR-expression  ? expression  : conditional-expression  
    constant-expression :
      conditional-expression  
    logical-OR-expression :
      logical-AND-expression
      logical-OR-expression  || logical-AND-expression  197
    logical-AND-expression :
      inclusive-OR-expression
      logical-AND-expression  && inclusive-OR-expression  
    inclusive-OR-expression :
      exclusive-OR-expression
      inclusive-OR-expression  | exclusive-OR-expression  
    exclusive-OR-expression :
      AND-expression
      exclusive-OR-expression  ^ AND-expression  
    AND-expression :
      equality-expression
      AND-expression  & equality-expression  
    equality-expression :
      relational-expression
      equality-expression  == relational-expression
      equality-expression  != relational-expression  
    relational-expression :
      shift-expression
      relational-expression  < shift-expression
      relational-expression  > shift-expression
      relational-expression  <= shift-expression
      relational-expression  >= shift-expression  
    shift-expression :
      additive-expression
      shift-expression  << additive-expression
      shift-expression  >> additive-expression  
    additive-expression :
      multiplicative-expression
      additive-expression  + multiplicative-expression
      additive-expression  - multiplicative-expression  
    multiplicative-expression :
      multiplicative-expression  * cast-expression
      multiplicative-expression  / cast-expression
      multiplicative-expression  % cast-expression  
    cast-expression :
      unary expression
      (type-name ) cast-expression  
    unary-expression :
      postfix expression
      ++unary expression
      --unary expression
      unary-operator cast-expression
      sizeof  unary-expression
      sizeof  (type-name ) 198
    unary operator : one of
      & * + - ~ !  
    postfix-expression :
      primary-expression
      postfix-expression [expression ]
      postfix-expression (argument-expression-list opt)
      postfix-expression .identifier
      postfix-expression ->+identifier
      postfix-expression ++
      postfix-expression --
    primary-expression :
      identifier
      constant
      string
      (expression ) 
    argument-expression-list :
      assignment-expression
      assignment-expression-list  , assignment-expression  
    constant :
      integer-constant
      character-constant
      floating-constant
      enumeration-constant  
The following grammar forthepreprocessor summarizes thestructure ofcontrol lines, butis
not suitable for mechanized parsing. It includes the symbol text, which means ordinary program
text, non-conditional preprocessor control lines, orcomplete preprocessor conditional
instructions. 
    control-line :
      # define  identifier token-sequence
      # define  identifier (identifier, ... , identifier ) token-sequence
      # undef  identifier
      # include < filename>
      # include " filename"
      # line  constant  "filename"
      # line  constant
      # error  token-sequence opt
      # pragma  token-sequence opt
      #
      preprocessor-conditional  
    preprocessor-conditional :
      if-line text elif-parts else-part opt #endif  
    if-line :
      # if  constant-expression
      # ifdef  identifier
      # ifndef  identifier  199
    elif-parts :
      elif-line text
      elif-parts opt 
    elif-line :
      # elif  constant-expression  
    else-part :
      else-line text
    else-line :
      #else  200
Appendix B - Standard Library
This appendix isasummary ofthelibrary defined bytheANSI standard. Thestandard library
isnotpartoftheClanguage proper, butanenvironment thatsupports standard Cwillprovide
thefunction declarations andtype andmacro definitions ofthislibrary. Wehave omitted afew
functions that areoflimited utility oreasily synthesized from others; wehave omitted multi-
byte characters; andwehave omitted discussion oflocale issues; thatis,properties thatdepend
on local language, nationality, or culture. 
The functions, types and macros of the standard library are declared in standard headers : 
   <assert.h>  <float.h>   <math.h>    <stdarg.h>  <stdlib.h>
   <ctype.h>   <limits.h>  <setjmp.h>  <stddef.h>  <string.h>
   <errno.h>   <locale.h>  <signal.h>  <stdio.h>   <time.h>
A header can be accessed by 
  #include  <header > 
Headers may beincluded inanyorder andanynumber oftimes. Aheader must beincluded
outside ofanyexternal declaration ordefinition andbefore anyuseofanything itdeclares. A
header need not be a source file. 
External identifiers thatbegin with anunderscore arereserved forusebythelibrary, asareall
other identifiers that begin with an underscore and an upper-case letter or another underscore. 
B.1 Input and Output: <stdio.h>
Theinput andoutput functions, types, andmacros defined in<stdio.h> represent nearly one
third of the library. 
Astream isasource ordestination ofdata that may beassociated with adisk orother
peripheral. The library supports text streams andbinary streams, although onsome systems,
notably UNIX, these areidentical. Atextstream isasequence oflines; each linehaszero or
more characters andisterminated by'\n' .Anenvironment may need toconvert atextstream
toorfrom some other representation (such asmapping'\n' tocarriage return andlinefeed).
Abinary stream isasequence ofunprocessed bytes thatrecord internal data, with theproperty
that if it is written, then read back on the same system, it will compare equal. 
Astream isconnected toafileordevice byopening it;theconnection isbroken byclosing the
stream. Opening afilereturns apointer toanobject oftypeFILE ,which records whatever
information isnecessary tocontrol thestream. We will use``file pointer'' and ``stream''
interchangeably when there is no ambiguity. 
When aprogram begins execution, thethree streamsstdin ,stdout ,andstderr arealready
open. 
B.1.1 File Operations
Thefollowing functions deal with operations onfiles. Thetypesize_t istheunsigned integral
type produced by the sizeof  operator. 
FILE *fopen(const char *filename, const char *mode)  
fopen opens thenamed file,andreturns astream, orNULL iftheattempt fails. Legal
values for mode  include: 
"r" open text file for reading
"w" create text file for writing; discard previous contents if any
"a" append; open or create text file for writing at end of file201
"r+" open text file for update (i.e., reading and writing)
"w+" create text file for update, discard previous contents if any
"a+" append; open or create text file for update, writing at end 
Update mode permits reading andwriting thesame file;fflush orafile-positioning
function must be called between a read and a write or vice versa. If the mode includes b
after theinitial letter, asin"rb" or"w+b" ,that indicates abinary file.Filenames are
limited to FILENAME_MAX  characters. At most FOPEN_MAX  files may be open at once. 
FILE *freopen(const char *filename, const char *mode, FILE *stream)  
freopen opens thefilewith thespecified mode andassociates thestream with it.It
returnsstream ,orNULL ifanerror occurs.freopen isnormally used tochange the
files associated with stdin , stdout , or stderr . 
int fflush(FILE *stream)  
Onanoutput stream,fflush causes anybuffered butunwritten data tobewritten; on
aninput stream, theeffect isundefined. ItreturnsEOF forawrite error, andzero
otherwise. fflush(NULL)  flushes all output streams. 
int fclose(FILE *stream)  
fclose flushes anyunwritten data forstream ,discards anyunread buffered input,
frees anyautomatically allocated buffer, then closes thestream. ItreturnsEOF ifany
errors occurred, and zero otherwise. 
int remove(const char *filename)  
remove removes thenamed file, sothat asubsequent attempt toopen itwillfail. It
returns non-zero if the attempt fails. 
int rename(const char *oldname, const char *newname)  
rename  changes the name of a file; it returns non-zero if the attempt fails. 
FILE *tmpfile(void)  
tmpfile creates atemporary fileofmode"wb+" that willbeautomatically removed
when closed orwhen theprogram terminates normally. tmpfile returns astream, or
NULL  if it could not create the file. 
char *tmpnam(char s[L_tmpnam])  
tmpnam(NULL) creates astring that isnotthename ofanexisting file,andreturns a
pointer toaninternal static array.tmpnam(s) stores thestring insaswell asreturning
itasthefunction value;smust have room foratleastL_tmpnam characters. tmpnam
generates adifferent name each time itiscalled; atmostTMP_MAX different names are
guaranteed during execution oftheprogram. Note thattmpnam creates aname, nota
file. 
int setvbuf(FILE *stream, char *buf, int mode, size_t size)  
setvbuf controls buffering forthestream; itmust becalled before reading, writing or
anyother operation. Amode of_IOFBF causes fullbuffering, _IOLBF linebuffering of
text files, and_IONBF nobuffering. Ifbuf isnotNULL ,itwillbeused asthebuffer,
otherwise abuffer willbeallocated. size determines thebuffer size.setvbuf returns
non-zero for any error. 
void setbuf(FILE *stream, char *buf)  
IfbufisNULL ,buffering isturned offforthestream. Otherwise, setbuf isequivalent
to (void) setvbuf(stream, buf, _IOFBF, BUFSIZ) . 
B.1.2 Formatted Output
The printf  functions provide formatted output conversion. 
   int fprintf(FILE *stream, const char *format, ...)
fprintf converts andwrites output tostream under thecontrol offormat .Thereturn value
is the number of characters written, or negative if an error occurred. 
The format string contains twotypes ofobjects: ordinary characters, which arecopied tothe
output stream, andconversion specifications, each ofwhich causes conversion andprinting of202
thenext successive argument tofprintf .Each conversion specification begins with the
character %andends with aconversion character. Between the%andtheconversion character
there may be, in order: 
•Flags (in any order), which modify the specification: 
o-, which specifies left adjustment of the converted argument in its field. 
o+, which specifies that the number will always be printed with a sign. 
ospace : if the first character is not a sign, a space will be prefixed. 
o0:fornumeric conversions, specifies padding tothefield width with leading
zeros. 
o#,which specifies analternate output form. Foro,thefirst digit willbecome
zero. ForxorX,0xor0Xwillbeprefixed toanon-zero result. Fore,E,f,g,
andG,theoutput willalways have adecimal point; forgandG,trailing zeros
will not be removed. 
•Anumber specifying aminimum field width. Theconverted argument willbeprinted in
afield atleast thiswide, andwider ifnecessary. Iftheconverted argument hasfewer
characters than thefield width itwillbepadded ontheleft(orright, ifleftadjustment
hasbeen requested) tomake upthefield width. The padding character isnormally
space, but is 0 if the zero padding flag is present. 
•A period, which separates the field width from the precision. 
•A number, the precision, that specifies the maximum number of characters to be printed
from astring, orthenumber ofdigits tobeprinted after thedecimal point fore,E,orf
conversions, orthenumber ofsignificant digits forgorGconversion, orthenumber of
digits tobeprinted foraninteger (leading0swillbeadded tomake upthenecessary
width). 
•Alength modifierh,l(letter ell),orL.``h''indicates thatthecorresponding argument
istobeprinted asashort orunsigned short ;``l''indicates thattheargument isa
long  or unsigned long , ``L'' indicates that the argument is a long double . 
Width orprecision orboth may bespecified as*,inwhich case thevalue iscomputed by
converting the next argument(s), which must be int. 
Theconversion characters andtheir meanings areshown inTable B.1. Ifthecharacter after the
% is not a conversion character, the behavior is undefined. 
Table B.1  Printf Conversions  
Character Argument type; Printed As 
d,i int; signed decimal notation.
o int; unsigned octal notation (without a leading zero).
x,Xunsigned int ; unsigned hexadecimal notation (without a leading 0x or 0X),
using abcdef  for 0x or ABCDEF  for 0X.
u int; unsigned decimal notation.
c int; single character, after conversion to unsigned char
schar * ; characters from the string are printed until a '\0'  is reached or until the
number of characters indicated by the precision have been printed.203
fdouble ; decimal notation of the form [-]mmm.ddd , where the number of d's is
given by the precision. The default precision is 6; a precision of 0 suppresses the
decimal point.
e,Edouble ; decimal notation of the form [-]m.dddddd e+/- xx or [-]m.dddddd E+/-
xx, where the number of d's is specified by the precision. The default precision is
6; a precision of 0 suppresses the decimal point.
g,Gdouble ; %e or %E is used if the exponent is less than -4 or greater than or equal to
the precision; otherwise %f is used. Trailing zeros and a trailing decimal point are
not printed.
p void * ; print as a pointer (implementation-dependent representation).
nint * ; the number of characters written so far by this call to printf  is written
into the argument. No argument is converted.
% no argument is converted; print a %
int printf(const char *format, ...)  
printf(...)  is equivalent to fprintf(stdout, ...) . 
int sprintf(char *s, const char *format, ...)  
sprintf isthesame asprintf except that theoutput iswritten into thestrings,
terminated with'\0' .smust bebigenough tohold theresult. Thereturn count does
not include the '\0' . 
int vprintf(const char *format, va_list arg)
int vfprintf(FILE *stream, const char *format, va_list arg)
int vsprintf(char *s, const char *format, va_list arg)  
Thefunctions vprintf ,vfprintf ,andvsprintf areequivalent tothecorresponding
printf functions, except thatthevariable argument listisreplaced byarg,which has
been initialized bytheva_start macro andperhapsva_arg calls. Seethediscussion of
<stdarg.h>  in Section B.7 . 
B.1.3 Formatted Input
The scanf  function deals with formatted input conversion. 
int fscanf(FILE *stream, const char *format, ...)
fscanf reads fromstream under control offormat ,andassigns converted values through
subsequent arguments, each ofwhich must beapointer .Itreturns whenformat isexhausted.
fscanf returnsEOFifendoffileoranerror occurs before anyconversion; otherwise itreturns
the number of input items converted and assigned. 
The format string usually contains conversion specifications, which areused todirect
interpretation of input. The format string may contain: 
•Blanks or tabs, which are not ignored. 
•Ordinary characters (not %),which areexpected tomatch thenext non-white space
character of the input stream. 
•Conversion specifications, consisting ofa%,anoptional assignment suppression
character *,anoptional number specifying amaximum field width, anoptionalh,l,or
L indicating the width of the target, and a conversion character. 
Aconversion specification determines theconversion ofthenext input field. Normally the
result isplaced inthevariable pointed tobythecorresponding argument. Ifassignment
suppression isindicated by*,asin%*s,however, theinput field issimply skipped; no
assignment ismade. Aninput field isdefined asastring ofnon-white space characters; it
extends either tothenext white space character oruntil thefield width, ifspecified, is
exhausted. This implies thatscanf will read across lineboundaries tofind itsinput, since204
newlines arewhite space. (White space characters areblank, tab, newline, carriage return,
vertical tab, and formfeed.) 
The conversion character indicates theinterpretation oftheinput field. The corresponding
argument must be a pointer. The legal conversion characters are shown in Table B.2. 
The conversion characters d,i,n,o,u,andxmay bepreceded byhiftheargument isa
pointer toshort rather than int,orbyl(letter ell)iftheargument isapointer tolong .The
conversion characters e,f,andgmay bepreceded bylifapointer todouble rather than
float  is in the argument list, and by L if a pointer to a long double . 
Table B.2  Scanf Conversions  
Character Input Data; Argument type 
d decimal integer; int*  
iinteger; int* . The integer may be in octal (leading 0) or hexadecimal (leading 0x
or 0X). 
o octal integer (with or without leading zero); int * . 
u unsigned decimal integer; unsigned int * . 
x hexadecimal integer (with or without leading 0x or 0X); int* . 
ccharacters; char* . The next input characters are placed in the indicated array, up
to the number given by the width field; the default is 1. No '\0'  is added. The
normal skip over white space characters is suppressed in this case; to read the
next non-white space character, use %1s. 
sstring of non-white space characters (not quoted); char * , pointing to an array
of characters large enough to hold the string and a terminating '\0'  that will be
added. 
e,f,gfloating-point number; float * . The input format for float 's is an optional sign,
a string of numbers possibly containing a decimal point, and an optional exponent
field containing an E or e followed by a possibly signed integer. 
p pointer value as printed by printf("%p"); , void * . 
nwrites into the argument the number of characters read so far by this call; int * .
No input is read. The converted item count is not incremented. 
[...]matches the longest non-empty string of input characters from the set between
brackets; char * . A '\0'  is added. []...]  includes ] in the set. 
[^...]matches the longest non-empty string of input characters not from the set
between brackets; char * . A '\0'  is added. [^]...]  includes ] in the set. 
% literal %; no assignment is made.
int scanf(const char *format, ...)  
scanf(...)  is identical to fscanf(stdin, ...) . 
int sscanf(const char *s, const char *format, ...)  
sscanf(s, ...) isequivalent toscanf(...) except that theinput characters are
taken from the string s. 
B.1.4 Character Input and Output Functions
int fgetc(FILE *stream)  
fgetc returns thenext character ofstream asanunsigned char (converted toan
int), or EOF if end of file or error occurs. 
char *fgets(char *s, int n, FILE *stream)  
fgets reads atmost thenextn-1characters into thearrays,stopping ifanewline is
encountered; thenewline isincluded inthearray, which isterminated by'\0' .fgets
returns s, or NULL  if end of file or error occurs. 205
int fputc(int c, FILE *stream)  
fputc writes thecharacter c(converted toanunsigend char )onstream .Itreturns
the character written, or EOF for error. 
int fputs(const char *s, FILE *stream)  
fputs writes thestrings(which need notcontain\n)onstream ;itreturns non-
negative, or EOF for an error. 
int getc(FILE *stream)  
getc isequivalent tofgetc except thatifitisamacro, itmay evaluatestream more
than once. 
int getchar(void)  
getchar  is equivalent to getc(stdin) . 
char *gets(char *s)  
gets reads thenext input lineintothearrays;itreplaces theterminating newline with
'\0' . It returns s, or NULL  if end of file or error occurs. 
int putc(int c, FILE *stream)  
putc isequivalent tofputc except thatifitisamacro, itmay evaluatestream more
than once. 
int putchar(int c)  
putchar(c)  is equivalent to putc(c,stdout) . 
int puts(const char *s)  
puts writes thestringsandanewline tostdout .ItreturnsEOF ifanerror occurs,
non-negative otherwise. 
int ungetc(int c, FILE *stream)  
ungetc pushesc(converted toanunsigned char )back ontostream ,where itwillbe
returned onthenext read. Only onecharacter ofpushback perstream isguaranteed.
EOF may notbepushed back.ungetc returns thecharacter pushed back, orEOF for
error. 
B.1.5 Direct Input and Output Functions
size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream)  
fread reads fromstream intothearrayptratmostnobj objects ofsizesize .fread
returns thenumber ofobjects read; thismay belessthan thenumber requested. feof
and ferror  must be used to determine status. 
size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)  
fwrite writes, from thearrayptr,nobj objects ofsizesize onstream .Itreturns the
number of objects written, which is less than nobj  on error. 
B.1.6 File Positioning Functions
int fseek(FILE *stream, long offset, int origin)  
fseek sets thefileposition forstream ;asubsequent read orwrite willaccess data
beginning atthenew position. Forabinary file,theposition issettooffset characters
fromorigin ,which may beSEEK_SET (beginning), SEEK_CUR (current position), or
SEEK_END (end offile). Foratextstream,offset must bezero, oravalue returned by
ftell  (in which case origin  must be SEEK_SET ). fseek  returns non-zero on error. 
long ftell(FILE *stream)  
ftell  returns the current file position for stream , or -1 on error. 
void rewind(FILE *stream)  
rewind(fp)  is equivalent to fseek(fp, 0L, SEEK_SET); clearerr(fp) . 
int fgetpos(FILE *stream, fpos_t *ptr)  
fgetpos records thecurrent position instream in*ptr ,forsubsequent useby
fsetpos .Thetypefpos_t issuitable forrecording such values.fgetpos returns non-
zero on error. 
int fsetpos(FILE *stream, const fpos_t *ptr)  206
fsetpos positions stream attheposition recorded byfgetpos in*ptr .fsetpos
returns non-zero on error. 
B.1.7 Error Functions
Many ofthefunctions inthelibrary setstatus indicators when error orendoffileoccur. These
indicators may besetandtested explicitly. Inaddition, theinteger expression errno (declared
in<errno.h> )may contain anerror number that gives further information about themost
recent error. 
void clearerr(FILE *stream)  
clearerr  clears the end of file and error indicators for stream . 
int feof(FILE *stream)  
feof  returns non-zero if the end of file indicator for stream  is set. 
int ferror(FILE *stream)  
ferror  returns non-zero if the error indicator for stream  is set. 
void perror(const char *s)  
perror(s) printssandanimplementation-defined error message corresponding tothe
integer in errno , as if by 
    fprintf(stderr, "%s: %s\n", s, " error message "); 
See strerror  in Section B.3 . 
B.2 Character Class Tests: <ctype.h>
The header<ctype.h> declares functions fortesting characters. For each function, the
argument listisanint,whose value must beEOForrepresentable asanunsigned char ,and
thereturn value isanint.Thefunctions return non-zero (true) iftheargument csatisfies the
condition described, and zero if not. 
isalnum(c) isalpha(c)  or isdigit(c)  is true
isalpha(c) isupper(c)  or islower(c)  is true
iscntrl(c) control character
isdigit(c) decimal digit
isgraph(c) printing character except space
islower(c) lower-case letter
isprint(c) printing character including space
ispunct(c) printing character except space or letter or digit
isspace(c) space, formfeed, newline, carriage return, tab, vertical tab
isupper(c) upper-case letter
isxdigit(c) hexadecimal digit
Intheseven-bit ASCII character set,theprinting characters are0x20('')to0x7E('-') ;
the control characters are 0 NUL to 0x1F  (US), and 0x7F  (DEL). 
In addition, there are two functions that convert the case of letters: 
int tolower(c) convert c to lower case
int toupper(c) convert c to upper case
Ifcisanupper-case letter,tolower(c) returns the corresponding lower-case letter,
toupper(c)  returns the corresponding upper-case letter; otherwise it returns c. 
B.3 String Functions: <string.h>
There aretwo groups ofstring functions defined intheheader<string.h> .The first have
names beginning withstr;thesecond have names beginning withmem.Except formemmove ,
thebehavior isundefined ifcopying takes place between overlapping objects. Comparison
functions treat arguments as unsigned char  arrays. 207
Inthefollowing table, variablessandtareoftypechar*;csandctareoftypeconstchar
*; n is of type size_t ; and c is an int converted to char . 
char *strcpy(s,ct) copy string ct to string s, including '\0' ; return s.
char
*strncpy(s,ct,n)copy at most n characters of string ct to s; return s. Pad with '\0' 's
if ct has fewer than n characters.
char *strcat(s,ct) concatenate string ct to end of string s; return s.
char
*strncat(s,ct,n)concatenate at most n characters of string ct to string s, terminate s
with '\0' ; return s.
int strcmp(cs,ct)compare string cs to string ct, return <0 if cs<ct , 0 if cs==ct , or >0
if cs>ct .
int
strncmp(cs,ct,n)compare at most n characters of string cs to string ct; return <0 if
cs<ct , 0 if cs==ct , or >0 if cs>ct .
char *strchr(cs,c) return pointer to first occurrence of c in cs or NULL  if not present.
char *strrchr(cs,c) return pointer to last occurrence of c in cs or NULL  if not present.
size_t
strspn(cs,ct)return length of prefix of cs consisting of characters in ct.
size_t
strcspn(cs,ct)return length of prefix of cs consisting of characters not in ct.
char
*strpbrk(cs,ct)return pointer to first occurrence in string cs of any character string
ct, or NULL  if not present.
char *strstr(cs,ct)return pointer to first occurrence of string ct in cs, or NULL  if not
present.
size_t strlen(cs) return length of cs.
char *strerror(n)return pointer to implementation-defined string corresponding to
error n.
char *strtok(s,ct)strtok  searches s for tokens delimited by characters from ct; see
below.
Asequence ofcalls ofstrtok(s,ct) splitssintotokens, each delimited byacharacter from
ct.The first callinasequence hasanon-NULLs,itfinds thefirst token insconsisting of
characters notinct;itterminates that byoverwriting thenext character ofswith'\0' and
returns apointer tothetoken. Each subsequent call, indicated byaNULL value ofs,returns the
next such token, searching from justpast theendoftheprevious one.strtok returnsNULL
when no further token is found. The string ct may be different on each call. 
Themem... functions aremeant formanipulating objects ascharacter arrays; theintent isan
interface toefficient routines. Inthefollowing table,sandtareoftypevoid*;csandctare
of type const void * ; n is of type size_t ; and c is an int converted to an unsigned char . 
void
*memcpy(s,ct,n)copy n characters from ct to s, and return s.
void
*memmove(s,ct,n)same as memcpy  except that it works even if the objects overlap.
int memcmp(cs,ct,n) compare the first n characters of cs with ct; return as with strcmp .
void
*memchr(cs,c,n)return pointer to first occurrence of character c in cs, or NULL  if not
present among the first n characters.
void *memset(s,c,n) place character c into first n characters of s, return s.
B.4 Mathematical Functions: <math.h>
The header <math.h>  declares mathematical functions and macros. 
The macrosEDOM andERANGE (found in<errno.h> )arenon-zero integral constants that are
used tosignal domain andrange errors forthefunctions; HUGE_VAL isapositivedouble value.
Adomain error occurs ifanargument isoutside thedomain over which thefunction is
defined. Onadomain error,errno issettoEDOM ;thereturn value isimplementation-defined.
Arange error occurs iftheresult ofthefunction cannot berepresented asadouble .Ifthe208
result overflows, thefunction returnsHUGE_VAL with theright sign, anderrno issetto
ERANGE .Iftheresult underflows, thefunction returns zero; whethererrno issettoERANGE is
implementation-defined. 
In the following table, x and y are of type double , n is an int, and all functions return double .
Angles for trigonometric functions are expressed in radians. 
sin(x)  sine of x
cos(x)  cosine of x
tan(x)  tangent of x
asin(x)  sin-1(x) in range [-pi/2,pi/2], x in [-1,1].
acos(x)  cos-1(x) in range [0,pi], x in [-1,1].
atan(x)  tan-1(x) in range [-pi/2,pi/2].
atan2(y,x) tan-1(y/x) in range [-pi,pi].
sinh(x)  hyperbolic sine of x
cosh(x)  hyperbolic cosine of x
tanh(x)  hyperbolic tangent of x
exp(x)  exponential function ex
log(x)  natural logarithm ln(x), x>0.
log10(x)  base 10 logarithm log 10(x), x>0.
pow(x,y)  xy. A domain error occurs if x=0 and y<=0 , or if x<0 and y is not an
integer.
sqrt(x)  sqare root of x, x>=0.
ceil(x)  smallest integer not less than x, as a double .
floor(x)  largest integer not greater than x, as a double .
fabs(x)  absolute value |x|
ldexp(x,n) x*2n
frexp(x, int
*ip)splits x into a normalized fraction in the interval [1/2,1) which is returned,
and a power of 2, which is stored in *exp . If x is zero, both parts of the
result are zero.
modf(x, double
*ip)splits x into integral and fractional parts, each with the same sign as x. It
stores the integral part in *ip, and returns the fractional part.
fmod(x,y)floating-point remainder of x/y, with the same sign as x. If y is zero, the
result is implementation-defined. 
B.5 Utility Functions: <stdlib.h>
The header<stdlib.h> declares functions fornumber conversion, storage allocation, and
similar tasks. double atof(const char *s)  
atof  converts s to double ; it is equivalent to strtod(s, (char**)NULL) . 
int atoi(const char *s)  
converts s to int; it is equivalent to (int)strtol(s, (char**)NULL, 10) . 
long atol(const char *s)  
converts s to long ; it is equivalent to strtol(s, (char**)NULL, 10) . 
double strtod(const char *s, char **endp)  
strtod converts theprefix ofstodouble ,ignoring leading white space; itstores a
pointer toanyunconverted suffix in*endp unlessendp isNULL .Iftheanswer would
overflow, HUGE_VAL isreturned with theproper sign; iftheanswer would underflow,
zero is returned. In either case errno  is set to ERANGE . 
long strtol(const char *s, char **endp, int base)  
strtol converts theprefix ofstolong ,ignoring leading white space; itstores a
pointer toanyunconverted suffix in*endp unlessendp isNULL .Ifbase isbetween 2
and36,conversion isdone assuming that theinput iswritten inthat base. Ifbase is
zero, thebase is8,10,or16;leading 0implies octal andleading0xor0Xhexadecimal.209
Letters ineither case represent digits from 10tobase-1 ;aleading0xor0Xis
permitted inbase 16.Iftheanswer would overflow, LONG_MAX orLONG_MIN is
returned, depending on the sign of the result, and errno  is set to ERANGE . 
unsigned long strtoul(const char *s, char **endp, int base)  
strtoul isthesame asstrtol except thattheresult isunsigned long andtheerror
value is ULONG_MAX . 
int rand(void)  
rand returns apseudo-random integer intherange 0toRAND_MAX ,which isatleast
32767. 
void srand(unsigned int seed)  
srand usesseed astheseed foranew sequence ofpseudo-random numbers. The
initial seed is 1. 
void *calloc(size_t nobj, size_t size)  
calloc returns apointer tospace foranarray ofnobj objects, each ofsizesize ,or
NULL  if the request cannot be satisfied. The space is initialized to zero bytes. 
void *malloc(size_t size)  
malloc returns apointer tospace foranobject ofsizesize ,orNULL iftherequest
cannot be satisfied. The space is uninitialized. 
void *realloc(void *p, size_t size)  
realloc changes thesizeoftheobject pointed tobyptosize .The contents willbe
unchanged uptotheminimum oftheoldandnew sizes. Ifthenew sizeislarger, the
new space isuninitialized. realloc returns apointer tothenew space, orNULL ifthe
request cannot be satisfied, in which case *p is unchanged. 
void free(void *p)  
free deallocates thespace pointed tobyp;itdoes nothing ifpisNULL .pmust bea
pointer to space previously allocated by calloc , malloc , or realloc . 
void abort(void)  
abort  causes the program to terminate abnormally, as if by raise(SIGABRT) . 
void exit(int status)  
exit causes normal program termination. atexit functions arecalled inreverse order
ofregistration, open files areflushed, open streams areclosed, andcontrol isreturned
totheenvironment. Howstatus isreturned totheenvironment isimplementation-
dependent, butzero istaken assuccessful termination. ThevaluesEXIT_SUCCESS and
EXIT_FAILURE  may also be used. 
int atexit(void (*fcn)(void))  
atexit registers thefunctionfcntobecalled when theprogram terminates normally;
it returns non-zero if the registration cannot be made. 
int system(const char *s)  
system passes thestringstotheenvironment forexecution. IfsisNULL ,system
returns non-zero ifthere isacommand processor. IfsisnotNULL ,thereturn value is
implementation-dependent. 
char *getenv(const char *name)  
getenv  returns the environment string associated with name , or NULL  if no string exists.
Details are implementation-dependent. 
void *bsearch(const void *key, const void *base,
              size_t n, size_t size,
              int (*cmp)(const void *keyval, const void *datum))
bsearch searchesbase[0]...base[n-1] foranitem thatmatches*key .Thefunction
cmpmust return negative ifitsfirstargument (thesearch key) islessthan itssecond (a
table entry), zero ifequal, andpositive ifgreater. Items inthearraybase must bein
ascending order. bsearch  returns a pointer to a matching item, or NULL  if none exists. 
void qsort(void *base, size_t n, size_t size,210
           int (*cmp)(const void *, const void *))
qsort sorts into ascending order anarraybase[0]...base[n-1] ofobjects ofsize
size . The comparison function cmp is as in bsearch . 
int abs(int n)  
abs returns the absolute value of its int argument. 
long labs(long n)  
labs  returns the absolute value of its long  argument. 
div_t div(int num, int denom)  
divcomputes thequotient andremainder ofnum/denom .The results arestored inthe
int members quot  and rem of a structure of type div_t . 
ldiv_t ldiv(long num, long denom)  
ldiv computes thequotient andremainder ofnum/denom .Theresults arestored inthe
long  members quot  and rem of a structure of type ldiv_t . 
B.6 Diagnostics: <assert.h>
The assert  macro is used to add diagnostics to programs: 
  void assert(int expression ) 
If expression  is zero when 
  assert(expression ) 
is executed, the assert  macro will print on stderr  a message, such as 
  Assertion failed:  expression , file  filename , line  nnn 
Itthen callsabort toterminate execution. Thesource filename andlinenumber come from the
preprocessor macros __FILE__  and __LINE__ . 
If NDEBUG  is defined at the time <assert.h>  is included, the assert macro is ignored. 
B.7 Variable Argument Lists: <stdarg.h>
Theheader<stdarg.h> provides facilities forstepping through alistoffunction arguments of
unknown number and type. 
Suppose lastarg isthelastnamed parameter ofafunctionfwith avariable number of
arguments. Then declare withinfavariable oftypeva_list thatwillpoint toeach argument
in turn: 
   va_list ap;
apmust beinitialized once with themacrova_start before any unnamed argument is
accessed: 
  va_start(va_list ap, lastarg); 
Thereafter, each execution ofthemacrova_arg willproduce avalue that hasthetype and
value of the next unnamed argument, and will also modify ap so the next use of va_arg  returns
the next argument: 
  type va_arg(va_list ap, type); 
The macro 
   void va_end(va_list ap);
must be called once after the arguments have been processed but before f is exited. 211
B.8 Non-local Jumps: <setjmp.h>
The declarations in<setjmp.h> provide away toavoid thenormal function callandreturn
sequence, typically to permit an immediate return from a deeply nested function call. 
int setjmp(jmp_buf env)  
The macrosetjmp saves state information inenvforusebylongjmp .The return is
zero from adirect callofsetjmp ,andnon-zero from asubsequent calloflongjmp .A
calltosetjmp canonly occur incertain contexts, basically thetestofif,switch ,and
loops, and only in simple relational expressions. 
      if (setjmp(env) == 0)
          /* get here on direct call */
      else
          /* get here by calling longjmp */
void longjmp(jmp_buf env, int val)  
longjmp restores thestate saved bythemost recent call tosetjmp ,using the
information saved inenv,andexecution resumes asifthesetjmp function hadjust
executed andreturned thenon-zero valueval.The function containing thesetjmp
must nothave terminated. Accessible objects have thevalues they had atthetime
longjmp was called, except that non-volatile automatic variables inthefunction
calling setjmp  become undefined if they were changed after the setjmp  call. 
B.9 Signals: <signal.h>
The header <signal.h>  provides facilities for handling exceptional conditions that arise during
execution, such as an interrupt signal from an external source or an error in execution. 
void (*signal(int sig, void (*handler)(int)))(int)
signal determines how subsequent signals will behandled. Ifhandler isSIG_DFL ,the
implementation-defined default behavior isused, ifitisSIG_IGN ,thesignal isignored;
otherwise, thefunction pointed tobyhandler willbecalled, with theargument ofthetype of
signal. Valid signals include 
SIGABRT abnormal termination, e.g., from abort
SIGFPE arithmetic error, e.g., zero divide or overflow
SIGILL illegal function image, e.g., illegal instruction
SIGINT interactive attention, e.g., interrupt
SIGSEGV illegal storage access, e.g., access outside memory limits
SIGTERM  termination request sent to this program
signal returns theprevious value ofhandler forthespecific signal, orSIG_ERR ifanerror
occurs. 
When asignalsigsubsequently occurs, thesignal isrestored toitsdefault behavior; then the
signal-handler function iscalled, asifby(*handler)(sig) .Ifthehandler returns, execution
will resume where it was when the signal occurred. 
The initial state of signals is implementation-defined. 
int raise(int sig)
raise  sends the signal sig to the program; it returns non-zero if unsuccessful. 
B.10 Date and Time Functions: <time.h>
The header<time.h> declares types and functions formanipulating date and time. Some
functions process local time,which may differ from calendar time, forexample because oftime212
zone.clock_t andtime_t arearithmetic types representing times, andstructtmholds the
components of a calendar time: 
int tm_sec; seconds after the minute (0,61)
int tm_min; minutes after the hour (0,59)
int tm_hour; hours since midnight (0,23)
int tm_mday; day of the month (1,31)
int tm_mon; months since  January (0,11)
int tm_year; years since 1900
int tm_wday; days since Sunday (0,6)
int tm_yday; days since January 1 (0,365)
int tm_isdst; Daylight Saving Time flag
tm_isdst ispositive ifDaylight Saving Time isineffect, zero ifnot, and negative ifthe
information is not available. 
clock_t clock(void)  
clock  returns the processor time used by the program since the beginning of execution,
or -1 if unavailable. clock()/CLK_PER_SEC  is a time in seconds. 
time_t time(time_t *tp)  
time returns thecurrent calendar time or-1ifthetime isnotavailable. Iftpisnot
NULL , the return value is also assigned to *tp. 
double difftime(time_t time2, time_t time1)  
difftime  returns time2-time1  expressed in seconds. 
time_t mktime(struct tm *tp)  
mktime converts thelocal time inthestructure *tp into calendar time inthesame
representation used bytime .The components willhave values intheranges shown.
mktime  returns the calendar time or -1 if it cannot be represented. 
The next four functions return pointers to static objects that may be overwritten by other calls. 
char *asctime(const struct tm *tp)  
asctime</tt< converts thetimeinthestructure *tpintoastringof
the form 
      Sun Jan  3 15:14:13 1988\n\0
char *ctime(const time_t *tp)  
ctimeconverts thecalendar time*tptolocaltime;itisequivalent
to 
      asctime(localtime(tp)) 
struct tm *gmtime(const time_t *tp)  
gmtimeconverts thecalendar time*tpintoCoordinated Universal Time
(UTC).Itreturns NULLifUTCisnotavailable. Thenamegmtimehas
historical significance. 
struct tm *localtime(const time_t *tp)  
localtime  converts the calendar time *tp into local time. 
size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)
strftime formats dateandtimeinformation from*tpintosaccording
tofmt,whichisanalogous toaprintfformat. Ordinary characters
(including theterminating '\0')arecopied intos.Each%cis
replaced asdescribed below,usingvaluesappropriate forthelocal
environment. Nomorethansmaxcharacters areplacedintos.strftime
returns thenumberofcharacters, excluding the'\0',orzeroifmore
than smax characters were produced. 
%a abbreviated weekday name.
%A full weekday name.
%b abbreviated month name.
%B full month name.
%c local date and time representation.
%d day of the month ( 01-31 ).
%H hour (24-hour clock) (00-23) .213
%I hour (12-hour clock) (01-12) .
%j day of the year (001-366) .
%m month (01-12) .
%M minute (00-59) .
%p local equivalent of AM or PM.
%S second (00-61) .
%U week number of the year (Sunday as 1st day of week) (00-53) .
%w weekday ( 0-6, Sunday is 0).
%W week number of the year (Monday as 1st day of week) (00-53) .
%x local date representation.
%X local time representation.
%y year without century (00-99) .
%Y year with century.
%Z time zone name, if any.
%%  %
B.11 Implementation-defined Limits:
<limits.h> and <float.h>
Theheader<limits.h> defines constants forthesizesofintegral types.
Thevaluesbelowareacceptable minimum magnitudes; largervaluesmaybe
used. 
CHAR_BIT   8 bits in a char
CHAR_MAX UCHAR_MAX  or
SCHAR_MAX   maximum value of char 
CHAR_MIN 0 or SCHAR_MIN maximum value of char
INT_MAX 32767 maximum value of int
INT_MIN -32767 minimum value of int
LONG_MAX 2147483647 maximum value of long
LONG_MIN -2147483647 minimum value of long
SCHAR_MAX +127 maximum value of signed char
SCHAR_MIN -127 minimum value of signed char
SHRT_MAX +32767 maximum value of short
SHRT_MIN -32767 minimum value of short
UCHAR_MAX 255 maximum value of unsigned char
UINT_MAX 65535 maximum value of unsigned int
ULONG_MAX 4294967295 maximum value of unsigned long
USHRT_MAX 65535maximum value of unsigned
short
Thenamesinthetablebelow,asubsetof<float.h> ,areconstants related
tofloating-point arithmetic. Whenavalueisgiven, itrepresents the
minimum magnitude forthecorresponding quantity. Eachimplementation
defines appropriate values. 
FLT_RADIX 2 radix of exponent, representation, e.g., 2, 16
FLT_ROUNDS floating-point rounding mode for addition
FLT_DIG 6 decimal digits of precision
FLT_EPSILON 1E-5 smallest number x such that 1.0+x != 1.0
FLT_MANT_DIG   number of base FLT_RADIX  in mantissa
FLT_MAX 1E+37  maximum floating-point number
FLT_MAX_EXP maximum n such that FLT_RADIXn-1 is representable
FLT_MIN 1E-37 minimum normalized floating-point number
FLT_MIN_EXP minimum n such that 10n is a normalized number
DBL_DIG 10 decimal digits of precision
DBL_EPSILON 1E-9 smallest number x such that 1.0+x != 1.0
DBL_MANT_DIG number of base FLT_RADIX  in mantissa214
DBL_MAX 1E+37 maximum double  floating-point number
DBL_MAX_EXP maximum n such that FLT_RADIXn-1 is representable
DBL_MIN 1E-37 minimum normalized double  floating-point number
DBL_MIN_EXP minimum n such that 10n is a normalized number215
Appendix C - Summary of Changes
Since thepublication ofthefirst edition ofthisbook, thedefinition oftheClanguage has
undergone changes. Almost allwere extensions oftheoriginal language, andwere carefully
designed toremain compatible with existing practice; some repaired ambiguities intheoriginal
description; andsome represent modifications thatchange existing practice. Many ofthenew
facilities were announced inthedocuments accompanying compilers available from AT&T,
andhave subsequently been adopted byother suppliers ofCcompilers. More recently, the
ANSI committee standardizing thelanguage incorporated most ofthechanges, and also
introduced other significant modifications. Their report was inpart participated bysome
commercial compilers even before issuance of the formal C standard. 
This Appendix summarizes thedifferences between thelanguage defined bythefirstedition of
thisbook, andthat expected tobedefined bythefinal standard. Ittreats only thelanguage
itself, notitsenvironment andlibrary; although these areanimportant part ofthestandard,
there islittle tocompare with, because thefirst edition didnotattempt toprescribe an
environment or library. 
•Preprocessing ismore carefully defined intheStandard than inthefirst edition, andis
extended: itisexplicitly token based; there arenew operators forconcatenation of
tokens (##),andcreation ofstrings (#);there arenew control lines like#elif and
#pragma ;redeclaration ofmacros bythesame token sequence isexplicitly permitted;
parameters inside strings arenolonger replaced. Splicing oflines by\ispermitted
everywhere, not just in strings and macro definitions. See Par.A.12 . 
•The minimum significance ofallinternal identifiers increased to31characters; the
smallest mandated significance ofidentifiers with external linkage remains 6monocase
letters. (Many implementations provide more.) 
•Trigraph sequences introduced by??allow representation ofcharacters lacking in
some character sets. Escapes for#\^[]{}|~ aredefined, seePar.A.12.1 .Observe that
theintroduction oftrigraphs may change themeaning ofstrings containing the
sequence ??. 
•New keywords (void,const,volatile, signed, enum )areintroduced. The
stillborn entry  keyword is withdrawn. 
•New escape sequences, forusewithin character constants and string literals, are
defined. The effect offollowing \byacharacter notpart ofanapproved escape
sequence is undefined. See Par.A.2.5.2 . 
•Everyone's favorite trivial change: 8 and 9 are not octal digits. 
•Thestandard introduces alarger setofsuffixes tomake thetype ofconstants explicit:U
orLforintegers,ForLforfloating. Italso refines therules forthetype ofunsiffixed
constants ( Par.A.2.5 ). 
•Adjacent string literals are concatenated. 
•There isanotation forwide-character string literals and character constants; see
Par.A.2.6 . 
•Characters aswell asother types, may beexplicitly declared tocarry, ornottocarry, a
sign byusing thekeywords signed orunsigned .The locutionlongfloat asa216
synonym fordouble iswithdrawn, butlongdouble may beused todeclare anextra-
precision floating quantity. 
•Forsome time, typeunsigned char hasbeen available. The standard introduces the
signed  keyword to make signedness explicit for char  and other integral objects. 
•Thevoid type hasbeen available inmost implementations forsome years. The
Standard introduces theuseofthevoid*type asageneric pointer type; previously
char*played thisrole. Atthesame time, explicit rules areenacted against mixing
pointers and integers, and pointers of different type, without the use of casts. 
•The Standard places explicit minima ontheranges ofthearithmetic types, and
mandates headers (<limits.h> and<float.h> )giving thecharacteristics ofeach
particular implementation. 
•Enumerations are new since the first edition of this book. 
•The Standard adopts from C++ thenotion oftype qualifier, forexample const
(Par.A.8.2 ). 
•Strings are no longer modifiable, and so may be placed in read-only memory. 
•The ``usual arithmetic conversions'' arechanged, essentially from ``for integers,
unsigned always wins; forfloating point, always usedouble ''to``promote tothe
smallest capacious-enough type.'' See Par.A.6.5 . 
•The oldassignment operators like=+aretruly gone. Also, assignment operators are
now single tokens; inthefirstedition, they were pairs, andcould beseparated bywhite
space. 
•Acompiler's license totreat mathematically associative operators ascomputationally
associative is revoked. 
•A unary + operator is introduced for symmetry with unary -. 
•Apointer toafunction may beused asafunction designator without anexplicit*
operator. See Par.A.7.3.2 . 
•Structures may be assigned, passed to functions, and returned by functions. 
•Applying theaddress-of operator toarrays ispermitted, andtheresult isapointer to
the array. 
•Thesizeof operator, inthefirst edition, yielded typeint;subsequently, many
implementations made itunsigned .The Standard makes itstype explicitly
implementation-dependent, butrequires thetype,size_t ,tobedefined inastandard
header (<stddef.h> ).Asimilar change occurs inthetype (ptrdiff_t )ofthe
difference between pointers. See Par.A.7.4.8  and Par.A.7.7 . 
•Theaddress-of operator&may notbeapplied toanobject declaredregister ,even if
the implementation chooses not to keep the object in a register. 
•The type ofashift expression isthat oftheleftoperand; theright operand can't
promote the result. See Par.A.7.8 . 
•The Standard legalizes thecreation ofapointer justbeyond theendofanarray, and
allows arithmetic and relations on it; see Par.A.7.7 . 217
•The Standard introduces (borrowing from C++) thenotion ofafunction prototype
declaration that incorporates thetypes oftheparameters, and includes anexplicit
recognition ofvariadic functions together with anapproved way ofdealing with them.
See Pars. A.7.3.2 , A.8.6.3 , B.7. The older style is still accepted, with restrictions. 
•Empty declarations, which have nodeclarators anddon't declare atleast astructure,
union, orenumeration, areforbidden bytheStandard. Ontheother hand, adeclaration
with justastructure orunion tagredeclares thattageven ifitwasdeclared inanouter
scope. 
•External data declarations without anyspecifiers orqualifiers (just anaked declarator)
are forbidden. 
•Some implementations, when presented with anextern declaration inaninner block,
would export thedeclaration totherestofthefile.TheStandard makes itclear thatthe
scope of such a declaration is just the block. 
•The scope ofparameters isinjected into afunction's compound statement, sothat
variable declarations at the top level of the function cannot hide the parameters. 
•The name spaces ofidentifiers aresomewhat different. TheStandard puts alltags ina
single name space, and also introduces aseparate name space forlabels; see
Par.A.11.1 .Also, member names areassociated with thestructure orunion ofwhich
they are a part. (This has been common practice from some time.) 
•Unions may be initialized; the initializer refers to the first member. 
•Automatic structures, unions, and arrays may be initialized, albeit in a restricted way. 
•Character arrays with anexplicit sizemay beinitialized byastring literal with exactly
that many characters (the \0 is quietly squeezed out). 
•The controlling expression, and the case labels, of a switch may have any integral type. 